{"version":3,"file":"ably-chat.js","sources":["../../src/core/logger.ts","../../src/core/config.ts","../../src/core/utils/event-emitter.ts","../../src/core/connection.ts","../../node_modules/dequal/dist/index.mjs","../../src/core/events.ts","../../node_modules/lodash.clonedeep/index.js","../../src/core/message.ts","../../src/core/message-parser.ts","../../src/core/serial.ts","../../src/core/messages-reactions.ts","../../src/core/rest-types.ts","../../src/core/messages.ts","../../src/core/chat-api.ts","../../src/core/errors.ts","../../src/core/id.ts","../../src/core/channel.ts","../../src/core/version.ts","../../src/core/channel-manager.ts","../../src/core/occupancy.ts","../../src/core/presence.ts","../../node_modules/async-mutex/index.mjs","../../src/core/room-status.ts","../../src/core/room-lifecycle-manager.ts","../../src/core/room-options.ts","../../src/core/realtime.ts","../../src/core/room-reaction.ts","../../src/core/room-reaction-parser.ts","../../src/core/room-reactions.ts","../../src/core/typing.ts","../../src/core/room.ts","../../src/core/rooms.ts","../../src/core/chat.ts"],"sourcesContent":["import * as Ably from 'ably';\n\nimport { NormalizedChatClientOptions } from './config.js';\n\n/**\n * Interface for loggers.\n */\nexport interface Logger {\n  /**\n   * Log a message at the trace level.\n   * @param message The message to log.\n   * @param context The context of the log message as key-value pairs.\n   */\n  trace(message: string, context?: LogContext): void;\n\n  /**\n   * Log a message at the debug level.\n   * @param message The message to log.\n   * @param context The context of the log message as key-value pairs.\n   */\n  debug(message: string, context?: LogContext): void;\n\n  /**\n   * Log a message at the info level.\n   * @param message The message to log.\n   * @param context The context of the log message as key-value pairs.\n   */\n  info(message: string, context?: LogContext): void;\n\n  /**\n   * Log a message at the warn level.\n   * @param message The message to log.\n   * @param context The context of the log message as key-value pairs.\n   */\n  warn(message: string, context?: LogContext): void;\n\n  /**\n   * Log a message at the error level.\n   * @param message The message to log.\n   * @param context The context of the log message as key-value pairs.\n   */\n  error(message: string, context?: LogContext): void;\n\n  /**\n   * Creates a new logger with a context that will be merged with any context provided to individual log calls.\n   * The context will be overridden by any matching keys in the individual log call's context.\n   * @param context The context to use for all log calls.\n   * @returns A new logger instance with the context.\n   */\n  withContext(context: LogContext): Logger;\n}\n\n/**\n * Represents the different levels of logging that can be used.\n */\nexport enum LogLevel {\n  /**\n   * Something routine and expected has occurred. This level will provide logs for the vast majority of operations\n   * and function calls.\n   */\n  Trace = 'trace',\n\n  /**\n   * Development information, messages that are useful when trying to debug library behavior,\n   * but superfluous to normal operation.\n   */\n  Debug = 'debug',\n\n  /**\n   * Informational messages. Operationally significant to the library but not out of the ordinary.\n   */\n  Info = 'info',\n\n  /**\n   * Anything that is not immediately an error, but could cause unexpected behavior in the future. For example,\n   * passing an invalid value to an option. Indicates that some action should be taken to prevent future errors.\n   */\n  Warn = 'warn',\n\n  /**\n   * A given operation has failed and cannot be automatically recovered. The error may threaten the continuity\n   * of operation.\n   */\n  Error = 'error',\n\n  /**\n   * No logging will be performed.\n   */\n  Silent = 'silent',\n}\n\n/**\n * Represents the context of a log message.\n * It is an object of key-value pairs that can be used to provide additional context to a log message.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type LogContext = Record<string, any>;\n\n/**\n * A function that can be used to handle log messages.\n * @param message The message to log.\n * @param level The log level of the message.\n * @param context The context of the log message as key-value pairs.\n */\nexport type LogHandler = (message: string, level: LogLevel, context?: LogContext) => void;\n\n/**\n * A simple console logger that logs messages to the console.\n *\n * @param message The message to log.\n * @param level The log level of the message.\n * @param context - The context of the log message as key-value pairs.\n */\nexport const consoleLogger = (message: string, level: LogLevel, context?: LogContext) => {\n  const contextString = context ? `, context: ${JSON.stringify(context)}` : '';\n  const formattedMessage = `[${new Date().toISOString()}] ${level.valueOf().toUpperCase()} ably-chat: ${message}${contextString}`;\n\n  switch (level) {\n    case LogLevel.Trace:\n    case LogLevel.Debug: {\n      console.log(formattedMessage);\n      break;\n    }\n    case LogLevel.Info: {\n      console.info(formattedMessage);\n      break;\n    }\n    case LogLevel.Warn: {\n      console.warn(formattedMessage);\n      break;\n    }\n    case LogLevel.Error: {\n      console.error(formattedMessage);\n      break;\n    }\n    case LogLevel.Silent: {\n      break;\n    }\n  }\n};\n\nexport const makeLogger = (options: NormalizedChatClientOptions): Logger => {\n  const logHandler = options.logHandler ?? consoleLogger;\n\n  return new DefaultLogger(logHandler, options.logLevel);\n};\n\n/**\n * A convenient list of log levels as numbers that can be used for easier comparison.\n */\nenum LogLevelNumber {\n  Trace = 0,\n  Debug = 1,\n  Info = 2,\n  Warn = 3,\n  Error = 4,\n  Silent = 5,\n}\n\n/**\n * A mapping of log levels to their numeric equivalents.\n */\nconst logLevelNumberMap = new Map<LogLevel, LogLevelNumber>([\n  [LogLevel.Trace, LogLevelNumber.Trace],\n  [LogLevel.Debug, LogLevelNumber.Debug],\n  [LogLevel.Info, LogLevelNumber.Info],\n  [LogLevel.Warn, LogLevelNumber.Warn],\n  [LogLevel.Error, LogLevelNumber.Error],\n  [LogLevel.Silent, LogLevelNumber.Silent],\n]);\n\n/**\n * A default logger implementation.\n */\nclass DefaultLogger implements Logger {\n  private readonly _handler: LogHandler;\n  private readonly _levelNumber: LogLevelNumber;\n  private readonly _context?: LogContext;\n\n  constructor(handler: LogHandler, level: LogLevel, context?: LogContext) {\n    this._handler = handler;\n    this._context = context;\n\n    const levelNumber = logLevelNumberMap.get(level);\n    if (levelNumber === undefined) {\n      throw new Ably.ErrorInfo(`Invalid log level: ${level}`, 50000, 500);\n    }\n\n    this._levelNumber = levelNumber;\n  }\n\n  trace(message: string, context?: LogContext): void {\n    this._write(message, LogLevel.Trace, LogLevelNumber.Trace, context);\n  }\n\n  debug(message: string, context?: LogContext): void {\n    this._write(message, LogLevel.Debug, LogLevelNumber.Debug, context);\n  }\n\n  info(message: string, context?: LogContext): void {\n    this._write(message, LogLevel.Info, LogLevelNumber.Info, context);\n  }\n\n  warn(message: string, context?: LogContext): void {\n    this._write(message, LogLevel.Warn, LogLevelNumber.Warn, context);\n  }\n\n  error(message: string, context?: LogContext): void {\n    this._write(message, LogLevel.Error, LogLevelNumber.Error, context);\n  }\n\n  withContext(context: LogContext): Logger {\n    // Get the original log level by finding the key in logLevelNumberMap that matches this._levelNumber\n    const originalLevel =\n      [...logLevelNumberMap.entries()].find(([, value]) => value === this._levelNumber)?.[0] ?? LogLevel.Error;\n\n    return new DefaultLogger(this._handler, originalLevel, this._mergeContext(context));\n  }\n\n  private _write(message: string, level: LogLevel, levelNumber: LogLevelNumber, context?: LogContext): void {\n    if (levelNumber >= this._levelNumber) {\n      this._handler(message, level, this._mergeContext(context));\n    }\n  }\n\n  private _mergeContext(context?: LogContext): LogContext | undefined {\n    if (!this._context) {\n      return context ?? undefined;\n    }\n\n    return context ? { ...this._context, ...context } : this._context;\n  }\n}\n","import { LogHandler, LogLevel } from './logger.js';\n\n/**\n * Configuration options for the chat client.\n */\nexport interface ChatClientOptions {\n  /**\n   * A custom log handler that will be used to log messages from the client.\n   * @defaultValue The client will log messages to the console.\n   */\n  logHandler?: LogHandler;\n\n  /**\n   * The minimum log level at which messages will be logged.\n   * @defaultValue LogLevel.error\n   */\n  logLevel?: LogLevel;\n}\n\n/**\n * Default configuration options for the chat client.\n */\nconst defaultClientOptions = {\n  logLevel: LogLevel.Error,\n};\n\n/**\n * This type is used to modify the properties of one type with the properties of another type and thus\n * can be used to turn client options into normalized client options.\n */\ntype Modify<T, R> = Omit<T, keyof R> & R;\n\n/**\n * These are the normalized client options, with default values filled in for any missing properties.\n */\nexport type NormalizedChatClientOptions = Modify<\n  ChatClientOptions,\n  {\n    logLevel: LogLevel;\n  }\n>;\n\nexport const normalizeClientOptions = (options?: ChatClientOptions): NormalizedChatClientOptions => {\n  options = options ?? {};\n\n  return {\n    ...options,\n    logLevel: options.logLevel ?? defaultClientOptions.logLevel,\n  };\n};\n","import * as Ably from 'ably';\n\n/**\n * This type represents a callback that can be registered with an EventEmitter.\n *\n * The EventsMap is an interface of event names to the types of the payloads of\n * those events. For example:\n *\n *     interface MyEvents {\n *         reaction: {emoji: string}\n *     }\n *\n * There is no need to use this type directly, it is used for defining the\n * InterfaceEventEmitter.\n */\ntype Callback<EventsMap> = (arg: EventsMap[keyof EventsMap]) => void;\ntype CallbackSingle<K> = (arg: K) => void;\n\n/**\n * This interface extends the Ably.EventEmitter interface to add a type-safe\n * emit method as well as convert an EventsMap into the type parameters used by\n * Ably.EventEmitter.\n */\ninterface InterfaceEventEmitter<EventsMap> extends Ably.EventEmitter<Callback<EventsMap>, void, keyof EventsMap> {\n  emit<K extends keyof EventsMap>(event: K, arg: EventsMap[K]): void;\n\n  on<K extends keyof EventsMap>(event: K, callback: CallbackSingle<EventsMap[K]>): void;\n  on<K1 extends keyof EventsMap, K2 extends keyof EventsMap>(\n    events: [K1, K2],\n    callback: CallbackSingle<EventsMap[K1] | EventsMap[K2]>,\n  ): void;\n  on<K1 extends keyof EventsMap, K2 extends keyof EventsMap, K3 extends keyof EventsMap>(\n    events: [K1, K2, K3],\n    callback: CallbackSingle<EventsMap[K1] | EventsMap[K2] | EventsMap[K3]>,\n  ): void;\n  on(events: (keyof EventsMap)[], callback: Callback<EventsMap>): void;\n  on(callback: Callback<EventsMap>): void;\n\n  off<K extends keyof EventsMap>(event: K, listener: CallbackSingle<EventsMap[K]>): void;\n  off(listener?: Callback<EventsMap>): void;\n  off<K extends EventsMap[keyof EventsMap]>(listener: CallbackSingle<K>): void;\n}\n\n/**\n * This is a workaround for the fact that the EventEmitter constructor is only\n * exported from the ably-js package for internal use by other Ably SDKs (like\n * this one).\n *\n * It is a correctly-typed constructor for the ably-js EventEmitter.\n *\n * We do not export this directly because we prefer to export a class, which is\n * what we normally expect EventEmitter to be.\n */\nconst InternalEventEmitter: new <EventsMap>() => InterfaceEventEmitter<EventsMap> = (\n  Ably.Realtime as unknown as { EventEmitter: new <EventsMap>() => InterfaceEventEmitter<EventsMap> }\n).EventEmitter;\n\n/**\n * EventEmitter class based on the internal ably-js EventEmitter. It is\n * different from the ably-js EventEmitter because it takes an EventsMap type\n * parameter as opposed to the three type parameters required by\n * {@link Ably.EventEmitter}.\n *\n * We find the EventsMap type parameter to be more convenient to use in this\n * Chat SDK.\n *\n * The EventsMap is an interface of event names to the types of the payloads of\n * those events. For example:\n *\n *     interface MyEvents {\n *         reaction: {emoji: string}\n *     }\n *\n * There is no need to use this type directly, it is used for defining the\n * InterfaceEventEmitter.\n */\nclass EventEmitter<EventsMap> extends InternalEventEmitter<EventsMap> {}\n\nexport default EventEmitter;\n\n/**\n * Creates a wrapper function that forwards all arguments to the provided function.\n * @param fn The function to wrap\n * @returns A new function with the same signature as the input function\n */\nexport const wrap = <Args extends unknown[], Return>(fn: (...args: Args) => Return): ((...args: Args) => Return) => {\n  return (...args: Args) => fn(...args);\n};\n","import * as Ably from 'ably';\n\nimport { Logger } from './logger.js';\nimport { StatusSubscription } from './subscription.js';\nimport EventEmitter, { wrap } from './utils/event-emitter.js';\n\n/**\n * The different states that the connection can be in through its lifecycle.\n */\nexport enum ConnectionStatus {\n  /**\n   * A temporary state for when the library is first initialized.\n   */\n  Initialized = 'initialized',\n\n  /**\n   * The library is currently connecting to Ably.\n   */\n  Connecting = 'connecting',\n\n  /**\n   * The library is currently connected to Ably.\n   */\n  Connected = 'connected',\n\n  /**\n   * The library is currently disconnected from Ably, but will attempt to reconnect.\n   */\n  Disconnected = 'disconnected',\n\n  /**\n   * The library is in an extended state of disconnection, but will attempt to reconnect.\n   */\n  Suspended = 'suspended',\n\n  /**\n   * The library is currently disconnected from Ably and will not attempt to reconnect.\n   */\n  Failed = 'failed',\n}\n\n/**\n * Represents a change in the status of the connection.\n */\nexport interface ConnectionStatusChange {\n  /**\n   * The new status of the connection.\n   */\n  current: ConnectionStatus;\n\n  /**\n   * The previous status of the connection.\n   */\n  previous: ConnectionStatus;\n\n  /**\n   * An error that provides a reason why the connection has\n   * entered the new status, if applicable.\n   */\n  error?: Ably.ErrorInfo;\n\n  /**\n   * The time in milliseconds that the client will wait before attempting to reconnect.\n   */\n  retryIn?: number;\n}\n\n/**\n * A function that can be called when the connection status changes.\n * @param change The change in status.\n */\nexport type ConnectionStatusListener = (change: ConnectionStatusChange) => void;\n\n/**\n * Represents a connection to Ably.\n */\nexport interface Connection {\n  /**\n   * The current status of the connection.\n   */\n  get status(): ConnectionStatus;\n\n  /**\n   * The current error, if any, that caused the connection to enter the current status.\n   */\n  get error(): Ably.ErrorInfo | undefined;\n\n  /**\n   * Registers a listener that will be called whenever the connection status changes.\n   * @param listener The function to call when the status changes.\n   * @returns An object that can be used to unregister the listener.\n   */\n  onStatusChange(listener: ConnectionStatusListener): StatusSubscription;\n}\n\ntype ConnectionEventsMap = Record<ConnectionStatus, ConnectionStatusChange>;\n\n/**\n * An implementation of the `Connection` interface.\n * @internal\n */\nexport class DefaultConnection implements Connection {\n  private _status: ConnectionStatus = ConnectionStatus.Initialized;\n  private _error?: Ably.ErrorInfo;\n  private readonly _connection: Ably.Connection;\n  private readonly _logger: Logger;\n  private _emitter = new EventEmitter<ConnectionEventsMap>();\n\n  /**\n   * Constructs a new `DefaultConnection` instance.\n   * @param ably The Ably Realtime client.\n   * @param logger The logger to use.\n   */\n  constructor(ably: Ably.Realtime, logger: Logger) {\n    this._logger = logger;\n\n    // Set our initial status and error\n    // CHA-RS5\n    this._status = this._mapAblyStatusToChat(ably.connection.state);\n    this._error = ably.connection.errorReason;\n\n    // Listen for changes to the connection status\n    this._connection = ably.connection;\n    this._connection.on((change: Ably.ConnectionStateChange) => {\n      const chatState = this._mapAblyStatusToChat(change.current);\n      if (chatState === this._status) {\n        return;\n      }\n\n      const stateChange: ConnectionStatusChange = {\n        current: chatState,\n        previous: this._status,\n        error: change.reason,\n        retryIn: change.retryIn,\n      };\n\n      this._applyStatusChange(stateChange);\n    });\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get status(): ConnectionStatus {\n    return this._status;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get error(): Ably.ErrorInfo | undefined {\n    return this._error;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  onStatusChange(listener: ConnectionStatusListener): StatusSubscription {\n    const wrapped = wrap(listener);\n    this._emitter.on(wrapped);\n\n    return {\n      off: () => {\n        this._emitter.off(wrapped);\n      },\n    };\n  }\n\n  private _applyStatusChange(change: ConnectionStatusChange): void {\n    this._status = change.current;\n    this._error = change.error;\n    this._logger.info(`Connection state changed`, change);\n    this._emitter.emit(change.current, change);\n  }\n\n  private _mapAblyStatusToChat(status: Ably.ConnectionState): ConnectionStatus {\n    switch (status) {\n      case 'closing':\n      case 'closed': {\n        return ConnectionStatus.Failed;\n      }\n      default: {\n        return status as ConnectionStatus;\n      }\n    }\n  }\n}\n","var has = Object.prototype.hasOwnProperty;\n\nfunction find(iter, tar, key) {\n\tfor (key of iter.keys()) {\n\t\tif (dequal(key, tar)) return key;\n\t}\n}\n\nexport function dequal(foo, bar) {\n\tvar ctor, len, tmp;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ctor === Set) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len;\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!bar.has(tmp)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === Map) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len[0];\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!dequal(len[1], bar.get(tmp))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === ArrayBuffer) {\n\t\t\tfoo = new Uint8Array(foo);\n\t\t\tbar = new Uint8Array(bar);\n\t\t} else if (ctor === DataView) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo.getInt8(len) === bar.getInt8(len));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ArrayBuffer.isView(foo)) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo[len] === bar[len]);\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n","import * as Ably from 'ably';\n\nimport { Message } from './message.js';\nimport { RoomReaction } from './room-reaction.js';\n\n/**\n * All chat message events.\n */\nexport enum ChatMessageEventType {\n  /** Fires when a new chat message is received. */\n  Created = 'message.created',\n\n  /** Fires when a chat message is updated. */\n  Updated = 'message.updated',\n\n  /** Fires when a chat message is deleted. */\n  Deleted = 'message.deleted',\n}\n\n/**\n * Realtime chat message names.\n */\nexport enum RealtimeMessageName {\n  /** Represents a regular chat message. */\n  ChatMessage = 'chat.message',\n}\n\n/**\n * Realtime meta event types.\n */\nexport enum RealtimeMetaEventType {\n  /** Represents a meta occupancy event. */\n  Occupancy = '[meta]occupancy',\n}\n\n/**\n * Chat Message Actions.\n */\nexport enum ChatMessageAction {\n  /** Action applied to a new message. */\n  MessageCreate = 'message.create',\n\n  /** Action applied to an updated message. */\n  MessageUpdate = 'message.update',\n\n  /** Action applied to a deleted message. */\n  MessageDelete = 'message.delete',\n\n  /** Action applied to an annotation summary message. */\n  MessageAnnotationSummary = 'message.summary',\n\n  /** Action applied to a meta occupancy message. */\n  MessageMetaOccupancy = 'meta.occupancy',\n}\n\n/**\n * Enum representing presence events.\n */\nexport enum PresenceEventType {\n  /**\n   * Event triggered when a user enters.\n   */\n  Enter = 'enter',\n\n  /**\n   * Event triggered when a user leaves.\n   */\n  Leave = 'leave',\n\n  /**\n   * Event triggered when a user updates their presence data.\n   */\n  Update = 'update',\n  /**\n   * Event triggered when a user initially subscribes to presence.\n   */\n  Present = 'present',\n}\n\n/**\n * Enum representing the typing event types.\n */\nexport enum TypingEventType {\n  /**\n   * Event triggered when a user is typing.\n   */\n  Start = 'typing.started',\n\n  /**\n   * Event triggered when a user stops typing.\n   */\n  Stop = 'typing.stopped',\n}\n\n/**\n * Enum representing the typing set event types.\n */\nexport enum TypingSetEventType {\n  /**\n   * Event triggered when a change occurs in the set of typers.\n   */\n  SetChanged = 'typing.set.changed',\n}\n\n/**\n * Represents a change in the state of current typers.\n */\nexport interface TypingSetEvent {\n  /**\n   * The type of the event.\n   */\n  type: TypingSetEventType;\n\n  /**\n   * The set of clientIds that are currently typing.\n   */\n  currentlyTyping: Set<string>;\n\n  /**\n   * Represents the change that resulted in the new set of typers.\n   */\n  change: {\n    /**\n     * The client ID of the user who stopped/started typing.\n     */\n    clientId: string;\n\n    /**\n     * Type of the change.\n     */\n    type: TypingEventType;\n  };\n}\n\n/**\n * Room reaction events. This is used for the realtime system since room reactions\n * have only one event: \"roomReaction\".\n */\nexport enum RoomReactionRealtimeEventType {\n  /**\n   * Event triggered when a room reaction was received.\n   */\n  Reaction = 'roomReaction',\n}\n\n/**\n * The type of room reaction events.\n */\nexport enum RoomReactionEventType {\n  /**\n   * Event triggered when a room reaction was received.\n   */\n  Reaction = 'reaction',\n}\n\n/**\n * Event that is emitted when a room reaction is received.\n */\nexport interface RoomReactionEvent {\n  /**\n   * The type of the event.\n   */\n  readonly type: RoomReactionEventType;\n\n  /**\n   * The reaction that was received.\n   */\n  readonly reaction: RoomReaction;\n}\n\n/**\n * Payload for a message event.\n */\nexport interface ChatMessageEvent {\n  /**\n   * The type of the message event.\n   */\n  type: ChatMessageEventType;\n\n  /**\n   * The message that was received.\n   */\n  message: Message;\n}\n\n/**\n * All annotation types supported by Chat Message Reactions.\n */\nexport enum MessageReactionType {\n  /**\n   * Allows for at most one reaction per client per message. If a client reacts\n   * to a message a second time, only the second reaction is counted in the\n   * summary.\n   *\n   * This is similar to reactions on iMessage, Facebook Messenger or WhatsApp.\n   */\n  Unique = 'unique',\n\n  /**\n   * Allows for at most one reaction of each type per client per message. It is\n   * possible for a client to add multiple reactions to the same message as\n   * long as they are different (eg different emojis). Duplicates are not\n   * counted in the summary.\n   *\n   * This is similar to reactions on Slack.\n   */\n  Distinct = 'distinct',\n\n  /**\n   * Allows any number of reactions, including repeats, and they are counted in\n   * the summary. The reaction payload also includes a count of how many times\n   * each reaction should be counted (defaults to 1 if not set).\n   *\n   * This is similar to the clap feature on Medium or how room reactions work.\n   */\n  Multiple = 'multiple',\n}\n\n/**\n * Enum representing the different annotation types used for message reactions.\n */\nexport enum ReactionAnnotationType {\n  Unique = 'reaction:unique.v1',\n  Distinct = 'reaction:distinct.v1',\n  Multiple = 'reaction:multiple.v1',\n}\n\n/**\n * Maps Ably PubSub annotation types to Ably Chat message reaction types.\n *\n * The key type is string because we use it to lookup by PubSub event.type, which is a string.\n */\nexport const AnnotationTypeToReactionType: Record<string, MessageReactionType> = {\n  [ReactionAnnotationType.Unique]: MessageReactionType.Unique,\n  [ReactionAnnotationType.Distinct]: MessageReactionType.Distinct,\n  [ReactionAnnotationType.Multiple]: MessageReactionType.Multiple,\n} as const;\n\n/**\n * Enum representing different message reaction events in the chat system.\n * @enum {string}\n */\nexport enum MessageReactionEventType {\n  /**\n   * A reaction was added to a message.\n   */\n  Create = 'reaction.create',\n  /**\n   * A reaction was removed from a message.\n   */\n  Delete = 'reaction.delete',\n  /**\n   * A reactions summary was updated for a message.\n   */\n  Summary = 'reaction.summary',\n}\n\n/**\n * Represents an individual message reaction event.\n */\nexport interface MessageReactionRawEvent {\n  /** Whether reaction was added or removed */\n  type: MessageReactionEventType.Create | MessageReactionEventType.Delete;\n\n  /** The timestamp of this event */\n  timestamp: Date;\n\n  /** The message reaction that was received. */\n  reaction: {\n    /** Serial of the message this reaction is for */\n    messageSerial: string;\n\n    /** Type of reaction */\n    type: MessageReactionType;\n\n    /** The reaction name (typically an emoji) */\n    name: string;\n\n    /** Count of the reaction (only for type Multiple, if set) */\n    count?: number;\n\n    /** The client ID of the user who added/removed the reaction */\n    clientId: string;\n  };\n}\n\n/**\n * Event interface representing a summary of message reactions.\n * This event aggregates different types of reactions (single, distinct, counter) for a specific message.\n */\nexport interface MessageReactionSummaryEvent {\n  /** The type of the event */\n  type: MessageReactionEventType.Summary;\n\n  /** The message reactions summary. */\n  summary: {\n    /** Reference to the original message's serial number */\n    messageSerial: string;\n\n    /** Map of unique-type reactions summaries */\n    unique: Ably.SummaryUniqueValues;\n\n    /** Map of distinct-type reactions summaries */\n    distinct: Ably.SummaryDistinctValues;\n\n    /** Map of multiple-type reactions summaries */\n    multiple: Ably.SummaryMultipleValues;\n  };\n}\n\n/**\n * Enum representing occupancy events.\n */\nexport enum OccupancyEventType {\n  /**\n   * Event triggered when occupancy is updated.\n   */\n  Updated = 'occupancy.updated',\n}\n\n/**\n * Represents an occupancy event.\n */\nexport interface OccupancyEvent {\n  /**\n   * The type of the occupancy event.\n   */\n  type: OccupancyEventType;\n\n  /**\n   * The occupancy data.\n   */\n  occupancy: {\n    /**\n     * The number of connections to the chat room.\n     */\n    connections: number;\n\n    /**\n     * The number of presence members in the chat room - members who have entered presence.\n     */\n    presenceMembers: number;\n  };\n}\n\n/**\n * Room events.\n */\nexport enum RoomEventType {\n  /**\n   * Event triggered when a discontinuity is detected in the room's channel connection.\n   * A discontinuity occurs when an attached or update event comes from the channel with resume=false,\n   * except for the first attach or attaches after explicit detach calls.\n   */\n  Discontinuity = 'room.discontinuity',\n}\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/**\n * Adds the key-value `pair` to `map`.\n *\n * @private\n * @param {Object} map The map to modify.\n * @param {Array} pair The key-value pair to add.\n * @returns {Object} Returns `map`.\n */\nfunction addMapEntry(map, pair) {\n  // Don't return `map.set` because it's not chainable in IE 11.\n  map.set(pair[0], pair[1]);\n  return map;\n}\n\n/**\n * Adds `value` to `set`.\n *\n * @private\n * @param {Object} set The set to modify.\n * @param {*} value The value to add.\n * @returns {Object} Returns `set`.\n */\nfunction addSetEntry(set, value) {\n  // Don't return `set.add` because it's not chainable in IE 11.\n  set.add(value);\n  return set;\n}\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    getPrototype = overArg(Object.getPrototypeOf, Object),\n    objectCreate = Object.create,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  this.__data__ = new ListCache(entries);\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  return this.__data__['delete'](key);\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var cache = this.__data__;\n  if (cache instanceof ListCache) {\n    var pairs = cache.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      return this;\n    }\n    cache = this.__data__ = new MapCache(pairs);\n  }\n  cache.set(key, value);\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = (isArray(value) || isArguments(value))\n    ? baseTimes(value.length, String)\n    : [];\n\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    object[key] = value;\n  }\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @param {boolean} [isFull] Specify a clone including symbols.\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, isDeep, isFull, customizer, key, object, stack) {\n  var result;\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      if (isHostObject(value)) {\n        return object ? value : {};\n      }\n      result = initCloneObject(isFunc ? {} : value);\n      if (!isDeep) {\n        return copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, baseClone, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (!isArr) {\n    var props = isFull ? getAllKeys(value) : keys(value);\n  }\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));\n  });\n  return result;\n}\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} prototype The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nfunction baseCreate(proto) {\n  return isObject(proto) ? objectCreate(proto) : {};\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  return objectToString.call(value);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var result = new buffer.constructor(buffer.length);\n  buffer.copy(result);\n  return result;\n}\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\n/**\n * Creates a clone of `map`.\n *\n * @private\n * @param {Object} map The map to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned map.\n */\nfunction cloneMap(map, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);\n  return arrayReduce(array, addMapEntry, new map.constructor);\n}\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\n/**\n * Creates a clone of `set`.\n *\n * @private\n * @param {Object} set The set to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned set.\n */\nfunction cloneSet(set, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);\n  return arrayReduce(array, addSetEntry, new set.constructor);\n}\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    assignValue(object, key, newValue === undefined ? source[key] : newValue);\n  }\n  return object;\n}\n\n/**\n * Copies own symbol properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Creates an array of the own enumerable symbol properties of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11,\n// for data views in Edge < 14, and promises in Node.js.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = objectToString.call(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : undefined;\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, cloneFunc, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return cloneMap(object, isDeep, cloneFunc);\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return cloneSet(object, isDeep, cloneFunc);\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, true, true);\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = cloneDeep;\n","import * as Ably from 'ably';\nimport cloneDeep from 'lodash.clonedeep';\n\nimport {\n  ChatMessageAction,\n  ChatMessageEvent,\n  ChatMessageEventType,\n  MessageReactionEventType,\n  MessageReactionSummaryEvent,\n} from './events.js';\nimport { Headers } from './headers.js';\nimport { Metadata } from './metadata.js';\nimport { OperationMetadata } from './operation-metadata.js';\n\n/**\n * {@link Headers} type for chat messages.\n */\nexport type MessageHeaders = Headers;\n\n/**\n * {@link Metadata} type for chat messages.\n */\nexport type MessageMetadata = Metadata;\n\n/**\n * {@link OperationMetadata} type for a chat messages {@link Operation}.\n */\nexport type MessageOperationMetadata = OperationMetadata;\n\n/**\n * Represents the detail of a message deletion or update.\n */\nexport interface Operation {\n  /**\n   * The optional clientId of the user who performed the update or deletion.\n   */\n  clientId?: string;\n  /**\n   * The optional description for the update or deletion.\n   */\n  description?: string;\n  /**\n   * The optional metadata associated with the update or deletion.\n   */\n  metadata?: MessageOperationMetadata;\n}\n\n/**\n * Represents a single message in a chat room.\n */\nexport interface Message {\n  /**\n   * The unique identifier of the message.\n   */\n  readonly serial: string;\n\n  /**\n   * The clientId of the user who created the message.\n   */\n  readonly clientId: string;\n\n  /**\n   * The text of the message.\n   */\n  readonly text: string;\n\n  /**\n   * The timestamp at which the message was created.\n   */\n  readonly createdAt: Date;\n\n  /**\n   * The metadata of a chat message. Allows for attaching extra info to a message,\n   * which can be used for various features such as animations, effects, or simply\n   * to link it to other resources such as images, relative points in time, etc.\n   *\n   * Metadata is part of the Ably Pub/sub message content and is not read by Ably.\n   *\n   * This value is always set. If there is no metadata, this is an empty object.\n   *\n   * Do not use metadata for authoritative information. There is no server-side\n   * validation. When reading the metadata treat it like user input.\n   */\n  readonly metadata: MessageMetadata;\n\n  /**\n   * The headers of a chat message. Headers enable attaching extra info to a message,\n   * which can be used for various features such as linking to a relative point in\n   * time of a livestream video or flagging this message as important or pinned.\n   *\n   * Headers are part of the Ably realtime message extras.headers and they can be used\n   * for Filtered Subscriptions and similar.\n   *\n   * This value is always set. If there are no headers, this is an empty object.\n   *\n   * Do not use the headers for authoritative information. There is no server-side\n   * validation. When reading the headers, treat them like user input.\n   */\n  readonly headers: MessageHeaders;\n\n  /**\n   * The action type of the message. This can be used to determine if the message was created, updated, or deleted.\n   */\n  readonly action: ChatMessageAction;\n\n  /**\n   * A unique identifier for the latest version of this message.\n   */\n  readonly version: string;\n\n  /**\n   * The timestamp at which this version was updated, deleted, or created.\n   */\n  readonly timestamp: Date;\n\n  /**\n   * The details of the operation that modified the message. This is only set for update and delete actions. It contains\n   * information about the operation: the clientId of the user who performed the operation, a description, and metadata.\n   */\n  readonly operation?: Operation;\n\n  /**\n   * The reactions summary for this message.\n   */\n  readonly reactions: MessageReactions;\n\n  /**\n   * Indicates if the message has been updated.\n   */\n  get isUpdated(): boolean;\n\n  /**\n   * Indicates if the message has been deleted.\n   */\n  get isDeleted(): boolean;\n\n  /**\n   * The clientId of the user who deleted the message.\n   */\n  get deletedBy(): string | undefined;\n\n  /**\n   * The clientId of the user who updated the message.\n   */\n  get updatedBy(): string | undefined;\n\n  /**\n   * The timestamp at which the message was deleted.\n   */\n  get deletedAt(): Date | undefined;\n\n  /**\n   * The timestamp at which the message was updated.\n   */\n  get updatedAt(): Date | undefined;\n\n  /**\n   * Determines if this message is an older version of the given message.\n   *\n   * **Note** that negating this function does not mean that the message is a newer\n   * version of the same message, as the two may be different messages entirely.\n   *\n   * ```ts\n   *  !message.isOlderVersionOf(other) !== message.isNewerVersionOf(other)\n   * ```\n   * @param message The message to compare against.\n   * @returns true if the two messages are the same message (isSameAs returns true) and this message is an older version.\n   */\n  isOlderVersionOf(message: Message): boolean;\n\n  /**\n   * Determines if this message is a newer version of the given message.\n   *\n   * **Note** that negating this function does not mean that the message is an older\n   * version of the same message, as the two may be different messages entirely.\n   *\n   * ```ts\n   *  !message.isNewerVersionOf(other) !== message.isOlderVersionOf(other)\n   * ```\n   *\n   * @param message The message to compare against.\n   * @returns true if the two messages are the same message (isSameAs returns true) and this message is a newer version.\n   */\n  isNewerVersionOf(message: Message): boolean;\n\n  /**\n   * Determines if this message is the same version as the given message.\n   * @param message The message to compare against.\n   * @returns true if the two messages are the same message and have the same version.\n   */\n  isSameVersionAs(message: Message): boolean;\n\n  /**\n   * Determines if this message was created before the given message. This comparison is based on\n   * global order, so does not necessarily represent the order that messages are received in realtime\n   * from the backend.\n   * @param message The message to compare against.\n   * @returns true if this message was created before the given message, in global order.\n   * @throws {@link ErrorInfo} if serials of either message is invalid.\n   */\n  before(message: Message): boolean;\n\n  /**\n   * Determines if this message was created after the given message. This comparison is based on\n   * global order, so does not necessarily represent the order that messages are received in realtime\n   * from the backend.\n   * @param message The message to compare against.\n   * @returns true if this message was created after the given message, in global order.\n   * @throws {@link ErrorInfo} if serials of either message is invalid.\n   */\n  after(message: Message): boolean;\n\n  /**\n   * Determines if this message is equal to the given message.\n   *\n   * Note that this method compares messages based on {@link Message.serial} alone. It returns true if the\n   * two messages represent different versions of the same message.\n   * @param message The message to compare against.\n   * @returns true if the two messages are the same message.\n   */\n  equal(message: Message): boolean;\n\n  /**\n   * Alias for {@link equal}.\n   * @param message The message to compare against.\n   * @returns true if the two messages are the same message.\n   */\n  isSameAs(message: Message): boolean;\n\n  /**\n   * Creates a new message instance with the event applied.\n   *\n   * NOTE: This method will not replace the message reactions if the event is of type `Message`.\n   *\n   * @param event The event to be applied to the returned message.\n   * @throws {@link ErrorInfo} if the event is for a different message.\n   * @throws {@link ErrorInfo} if the event is a {@link ChatMessageEventType.Created}.\n   * @returns A new message instance with the event applied. If the event is a no-op, such\n   *    as an event for an old version, the same message is returned (not a copy).\n   */\n  with(event: Message | ChatMessageEvent | MessageReactionSummaryEvent): Message;\n\n  /**\n   * Creates a copy of the message with fields replaced per the parameters.\n   *\n   * @param params The parameters to replace in the message.\n   * @return The message copy.\n   */\n  copy(params?: MessageCopyParams): Message;\n}\n\n/**\n * Parameters for copying a message.\n */\nexport interface MessageCopyParams {\n  /**\n   * The text of the copied message.\n   */\n  text?: string;\n\n  /**\n   * The metadata of the copied message.\n   */\n  metadata?: MessageMetadata;\n\n  /**\n   * The headers of the copied message.\n   */\n  headers?: MessageHeaders;\n}\n\n/**\n * Represents a summary of all reactions on a message.\n */\nexport interface MessageReactions {\n  /**\n   * Map of reaction to the summary (total and clients) for reactions of type {@link MessageReactionType.Unique}.\n   */\n  unique: Ably.SummaryUniqueValues;\n\n  /**\n   * Map of reaction to the summary (total and clients) for reactions of type {@link MessageReactionType.Distinct}.\n   */\n  distinct: Ably.SummaryDistinctValues;\n\n  /**\n   * Map of reaction to the summary (total and clients) for reactions of type {@link MessageReactionType.Multiple}.\n   */\n  multiple: Ably.SummaryMultipleValues;\n}\n\n/**\n * Parameters for creating a new DefaultMessage instance.\n */\nexport interface DefaultMessageParams {\n  serial: string;\n  clientId: string;\n  text: string;\n  metadata: MessageMetadata;\n  headers: MessageHeaders;\n  action: ChatMessageAction;\n  version: string;\n  createdAt: Date;\n  timestamp: Date;\n  reactions: MessageReactions;\n  operation?: Operation;\n}\n\n/**\n * An implementation of the Message interface for chat messages.\n *\n * Allows for comparison of messages based on their serials.\n */\nexport class DefaultMessage implements Message {\n  public readonly serial: string;\n  public readonly clientId: string;\n  public readonly text: string;\n  public readonly metadata: MessageMetadata;\n  public readonly headers: MessageHeaders;\n  public readonly action: ChatMessageAction;\n  public readonly version: string;\n  public readonly createdAt: Date;\n  public readonly timestamp: Date;\n  public readonly reactions: MessageReactions;\n  public readonly operation?: Operation;\n\n  constructor({\n    serial,\n    clientId,\n    text,\n    metadata,\n    headers,\n    action,\n    version,\n    createdAt,\n    timestamp,\n    reactions,\n    operation,\n  }: DefaultMessageParams) {\n    this.serial = serial;\n    this.clientId = clientId;\n    this.text = text;\n    this.metadata = metadata;\n    this.headers = headers;\n    this.action = action;\n    this.version = version;\n    this.createdAt = createdAt;\n    this.timestamp = timestamp;\n    this.reactions = reactions;\n    this.operation = operation;\n    // The object is frozen after constructing to enforce readonly at runtime too\n    Object.freeze(this.reactions);\n    Object.freeze(this.reactions.multiple);\n    Object.freeze(this.reactions.distinct);\n    Object.freeze(this.reactions.unique);\n    Object.freeze(this);\n  }\n\n  get isUpdated(): boolean {\n    return this.action === ChatMessageAction.MessageUpdate;\n  }\n\n  get isDeleted(): boolean {\n    return this.action === ChatMessageAction.MessageDelete;\n  }\n\n  get updatedBy(): string | undefined {\n    return this.isUpdated ? this.operation?.clientId : undefined;\n  }\n\n  get deletedBy(): string | undefined {\n    return this.isDeleted ? this.operation?.clientId : undefined;\n  }\n\n  get updatedAt(): Date | undefined {\n    return this.isUpdated ? this.timestamp : undefined;\n  }\n\n  get deletedAt(): Date | undefined {\n    return this.isDeleted ? this.timestamp : undefined;\n  }\n\n  isOlderVersionOf(message: Message): boolean {\n    if (!this.equal(message)) {\n      return false;\n    }\n\n    return this.version < message.version;\n  }\n\n  isNewerVersionOf(message: Message): boolean {\n    if (!this.equal(message)) {\n      return false;\n    }\n\n    return this.version > message.version;\n  }\n\n  isSameVersionAs(message: Message): boolean {\n    if (!this.equal(message)) {\n      return false;\n    }\n\n    return this.version === message.version;\n  }\n\n  before(message: Message): boolean {\n    return this.serial < message.serial;\n  }\n\n  after(message: Message): boolean {\n    return this.serial > message.serial;\n  }\n\n  equal(message: Message): boolean {\n    return this.serial === message.serial;\n  }\n\n  isSameAs(message: Message): boolean {\n    return this.equal(message);\n  }\n\n  with(event: Message | ChatMessageEvent | MessageReactionSummaryEvent): Message {\n    // If event has the property \"serial\", then it's a message\n    if ('serial' in event) {\n      return this._getLatestMessageVersion(event);\n    }\n\n    // If the event is a created event, throw an error\n    if (event.type === ChatMessageEventType.Created) {\n      throw new Ably.ErrorInfo('cannot apply a created event to a message', 40000, 400);\n    }\n\n    // reaction summary\n    if (event.type === MessageReactionEventType.Summary) {\n      if (event.summary.messageSerial !== this.serial) {\n        throw new Ably.ErrorInfo('cannot apply event for a different message', 40000, 400);\n      }\n\n      const newReactions: MessageReactions = {\n        unique: cloneDeep(event.summary.unique),\n        distinct: cloneDeep(event.summary.distinct),\n        multiple: cloneDeep(event.summary.multiple),\n      };\n\n      return DefaultMessage._clone(this, { reactions: newReactions });\n    }\n\n    // Message event (update or delete)\n    return this._getLatestMessageVersion(event.message);\n  }\n\n  /**\n   * Get the latest message version, based on the event.\n   * If \"this\" is the latest version, return \"this\", otherwise clone the message and apply the reactions.\n   *\n   * @param message The message to get the latest version of\n   * @returns The latest message version\n   */\n  private _getLatestMessageVersion(message: Message): Message {\n    // message event (update or delete)\n    if (message.serial !== this.serial) {\n      throw new Ably.ErrorInfo('cannot apply event for a different message', 40000, 400);\n    }\n\n    // event is older, keep this instead\n    if (this.version >= message.version) {\n      return this;\n    }\n\n    // event is newer, copy reactions from this and make new message from event\n    // TODO: This ignores summaries being newer on the message passed in, and is something we need to address\n    return DefaultMessage._clone(message, { reactions: this.reactions });\n  }\n\n  // Clone a message, optionally replace the given fields\n  private static _clone(source: Message, replace?: Partial<Message>): DefaultMessage {\n    return new DefaultMessage({\n      serial: replace?.serial ?? source.serial,\n      clientId: replace?.clientId ?? source.clientId,\n      text: replace?.text ?? source.text,\n      metadata: replace?.metadata ?? cloneDeep(source.metadata),\n      headers: replace?.headers ?? cloneDeep(source.headers),\n      action: replace?.action ?? source.action,\n      version: replace?.version ?? source.version,\n      createdAt: replace?.createdAt ?? source.createdAt,\n      timestamp: replace?.timestamp ?? source.timestamp,\n      reactions: replace?.reactions ?? cloneDeep(source.reactions),\n      operation: replace?.operation ?? cloneDeep(source.operation),\n    });\n  }\n\n  copy(params: MessageCopyParams = {}): Message {\n    return DefaultMessage._clone(this, params);\n  }\n}\n\nexport function emptyMessageReactions(): MessageReactions {\n  return {\n    unique: {},\n    distinct: {},\n    multiple: {},\n  };\n}\n","import * as Ably from 'ably';\n\nimport { ChatMessageAction } from './events.js';\nimport {\n  DefaultMessage,\n  emptyMessageReactions,\n  Message,\n  MessageHeaders,\n  MessageMetadata,\n  Operation,\n} from './message.js';\n\ninterface MessagePayload {\n  data?: {\n    text?: string;\n    metadata?: MessageMetadata;\n  };\n  clientId?: string;\n  timestamp: number;\n  extras?: {\n    headers?: MessageHeaders;\n  };\n\n  serial: string;\n  createdAt: number;\n  version: string;\n  action: Ably.MessageAction;\n  operation?: Ably.Operation;\n}\n\n// Parse a realtime message to a chat message\nexport const parseMessage = (inboundMessage: Ably.InboundMessage): Message => {\n  const message = inboundMessage as MessagePayload;\n\n  if (!message.data) {\n    throw new Ably.ErrorInfo(`received incoming message without data`, 50000, 500);\n  }\n\n  if (!message.clientId) {\n    throw new Ably.ErrorInfo(`received incoming message without clientId`, 50000, 500);\n  }\n\n  if (!message.extras) {\n    throw new Ably.ErrorInfo(`received incoming message without extras`, 50000, 500);\n  }\n\n  // For non-delete messages, text is required\n  if (message.action !== ChatMessageAction.MessageDelete && message.data.text === undefined) {\n    throw new Ably.ErrorInfo(`received incoming message without text`, 50000, 500);\n  }\n\n  // For non-delete messages, extras.headers is required\n  if (message.action !== ChatMessageAction.MessageDelete && !message.extras.headers) {\n    throw new Ably.ErrorInfo(`received incoming message without headers`, 50000, 500);\n  }\n\n  // For non-delete messages, metadata is required\n  if (message.action !== ChatMessageAction.MessageDelete && !message.data.metadata) {\n    throw new Ably.ErrorInfo(`received incoming message without metadata`, 50000, 500);\n  }\n\n  if (!message.serial) {\n    throw new Ably.ErrorInfo(`received incoming message without serial`, 50000, 500);\n  }\n\n  if (!message.version) {\n    throw new Ably.ErrorInfo(`received incoming message without version`, 50000, 500);\n  }\n\n  if (!message.createdAt) {\n    throw new Ably.ErrorInfo(`received incoming message without createdAt`, 50000, 500);\n  }\n\n  if (!message.timestamp) {\n    throw new Ably.ErrorInfo(`received incoming message without timestamp`, 50000, 500);\n  }\n\n  switch (message.action) {\n    case ChatMessageAction.MessageCreate:\n    case ChatMessageAction.MessageUpdate:\n    case ChatMessageAction.MessageDelete: {\n      break;\n    }\n    default: {\n      throw new Ably.ErrorInfo(`received incoming message with unhandled action; ${message.action}`, 50000, 500);\n    }\n  }\n\n  // If it's a deleted message, we'll set message.data to an empty object and message.extras to an empty object\n  const data = message.action === ChatMessageAction.MessageDelete ? {} : message.data;\n  const extras = message.action === ChatMessageAction.MessageDelete ? {} : message.extras;\n\n  return new DefaultMessage({\n    serial: message.serial,\n    clientId: message.clientId,\n    text: data.text ?? '',\n    metadata: data.metadata ?? {},\n    headers: extras.headers ?? {},\n    action: message.action as ChatMessageAction,\n    version: message.version,\n    createdAt: new Date(message.createdAt),\n    timestamp: new Date(message.timestamp),\n    reactions: emptyMessageReactions(),\n    operation: message.operation as Operation,\n  });\n};\n","import * as Ably from 'ably';\n\nimport { Message } from './message.js';\n\n/**\n * A serial is used to identify a particular message, reaction or other chat event. It is the identifier\n * for that event in the chat history.\n *\n * Serials can be conveyed either as a string, or an object that contains `serial` as a property. Message is included\n * for type hinting and LLM purposes.\n *\n * The string-form of the serial should not be parsed or interpreted in any way, as it is subject to change without\n * warning.\n */\nexport type Serial =\n  | Message\n  | string\n  | {\n      /**\n       * The serial of the message.\n       */\n      serial: string;\n    };\n\n/**\n * Convert a type that may contain a serial into a string.\n *\n * @param serial - The serial to convert.\n * @returns The serial as a string.\n */\nexport const serialToString = (serial: Serial): string => {\n  let serialString = '';\n  if (typeof serial === 'string') {\n    serialString = serial;\n  } else {\n    try {\n      if ('serial' in serial) {\n        serialString = serial.serial;\n      }\n    } catch {\n      // 'in' operator failed, fall through to error\n    }\n  }\n\n  if (serialString === '') {\n    throw new Ably.ErrorInfo('invalid serial; must be string or object with serial property', 40000, 400);\n  }\n\n  return serialString;\n};\n","import * as Ably from 'ably';\n\nimport { ChannelOptionsMerger } from './channel-manager.js';\nimport {\n  AddMessageReactionParams as APIAddMessageReactionParams,\n  ChatApi,\n  DeleteMessageReactionParams as APIDeleteMessageReactionParams,\n} from './chat-api.js';\nimport {\n  AnnotationTypeToReactionType,\n  ChatMessageAction,\n  MessageReactionEventType,\n  MessageReactionRawEvent,\n  MessageReactionSummaryEvent,\n  MessageReactionType,\n  ReactionAnnotationType,\n} from './events.js';\nimport { Logger } from './logger.js';\nimport { InternalRoomOptions, MessageOptions } from './room-options.js';\nimport { Serial, serialToString } from './serial.js';\nimport { Subscription } from './subscription.js';\nimport EventEmitter, { wrap } from './utils/event-emitter.js';\n\n/**\n * A listener for summary message reaction events.\n * @param event The message reaction summary event that was received. Use it\n *   with {@link Message.with} to keep an up-to-date reaction count.\n */\nexport type MessageReactionListener = (event: MessageReactionSummaryEvent) => void;\n\n/**\n * A listener for individual message reaction events.\n * @param event The message reaction event that was received.\n */\nexport type MessageRawReactionListener = (event: MessageReactionRawEvent) => void;\n\n/**\n * Parameters for adding a message reaction.\n */\nexport interface AddMessageReactionParams {\n  /**\n   * The reaction name to add; ie. the emoji.\n   */\n  name: string;\n\n  /**\n   * The type of reaction, must be one of {@link MessageReactionType}.\n   * If not set, the default type will be used which is configured in the {@link MessageOptions.defaultMessageReactionType} of the room.\n   */\n  type?: MessageReactionType;\n\n  /**\n   * The count of the reaction for type {@link MessageReactionType.Multiple}.\n   * Defaults to 1 if not set. Not supported for other reaction types.\n   * @default 1\n   */\n  count?: number;\n}\n\n/**\n * Parameters for deleting a message reaction.\n */\nexport interface DeleteMessageReactionParams {\n  /**\n   * The reaction name to delete; ie. the emoji. Required for all reaction types\n   * except {@link MessageReactionType.Unique}.\n   */\n  name?: string;\n\n  /**\n   * The type of reaction, must be one of {@link MessageReactionType}.\n   * If not set, the default type will be used which is configured in the {@link MessageOptions.defaultMessageReactionType} of the room.\n   */\n  type?: MessageReactionType;\n}\n\n/**\n * Add, delete, and subscribe to message reactions.\n */\nexport interface MessagesReactions {\n  /**\n   * Add a message reactions\n   * @param messageSerial The serial of the message to react to\n   * @param params Describe the reaction to add.\n   * @returns A promise that resolves when the reaction is added.\n   */\n  send(messageSerial: Serial, params: AddMessageReactionParams): Promise<void>;\n\n  /**\n   * Delete a message reaction\n   * @param messageSerial The serial of the message to remove the reaction from.\n   * @param params The type of reaction annotation and the specific reaction to remove. The reaction to remove is required for all types except {@link MessageReactionType.Unique}.\n   * @returns A promise that resolves when the reaction is deleted.\n   */\n  delete(messageSerial: Serial, params?: DeleteMessageReactionParams): Promise<void>;\n\n  /**\n   * Subscribe to message reaction summaries. Use this to keep message reaction\n   * counts up to date efficiently in the UI.\n   * @param listener The listener to call when a message reaction summary is received.\n   * @returns A subscription object that should be used to unsubscribe.\n   */\n  subscribe(listener: MessageReactionListener): Subscription;\n\n  /**\n   * Subscribe to individual reaction events.\n   * @remarks If you only need to keep track of reaction counts and clients, use\n   *  {@link subscribe} instead.\n   * @param listener The listener to call when a message reaction event is received.\n   * @returns A subscription object that should be used to unsubscribe.\n   */\n  subscribeRaw(listener: MessageRawReactionListener): Subscription;\n}\n\n/**\n * Maps Ably PubSub annotation action to message reaction event type.\n */\nconst eventTypeMap: Record<string, MessageReactionEventType.Create | MessageReactionEventType.Delete> = {\n  'annotation.create': MessageReactionEventType.Create,\n  'annotation.delete': MessageReactionEventType.Delete,\n};\n\n/**\n * @inheritDoc\n */\nexport class DefaultMessageReactions implements MessagesReactions {\n  private _emitter = new EventEmitter<{\n    [MessageReactionEventType.Create]: MessageReactionRawEvent;\n    [MessageReactionEventType.Delete]: MessageReactionRawEvent;\n    [MessageReactionEventType.Summary]: MessageReactionSummaryEvent;\n  }>();\n\n  private readonly _defaultType: MessageReactionType;\n\n  constructor(\n    private readonly _logger: Logger,\n    private readonly _options: MessageOptions | undefined,\n    private readonly _api: ChatApi,\n    private readonly _roomName: string,\n    private readonly _channel: Ably.RealtimeChannel,\n  ) {\n    void _channel.subscribe(this._processMessageEvent.bind(this));\n    if (this._options?.rawMessageReactions) {\n      void _channel.annotations.subscribe(this._processAnnotationEvent.bind(this));\n    }\n    this._defaultType = this._options?.defaultMessageReactionType ?? MessageReactionType.Distinct;\n  }\n\n  private _processAnnotationEvent(event: Ably.Annotation) {\n    this._logger.trace('MessagesReactions._processAnnotationEvent();', { event });\n\n    if (!event.messageSerial) {\n      this._logger.warn(\n        'DefaultMessageReactions._processAnnotationEvent(); received event with missing messageSerial',\n        {\n          event,\n        },\n      );\n      return;\n    }\n\n    const reactionType = AnnotationTypeToReactionType[event.type];\n\n    // unknown reaction type, meaning we've received an unknown annotation type\n    if (!reactionType) {\n      this._logger.debug('DefaultMessageReactions._processAnnotationEvent(); received event with unknown type', {\n        event,\n      });\n      return;\n    }\n\n    const eventType = eventTypeMap[event.action];\n    if (!eventType) {\n      // unknown action\n      this._logger.warn('DefaultMessageReactions._processAnnotationEvent(); received event with unknown action', {\n        event,\n      });\n      return;\n    }\n\n    let name = event.name;\n    if (!name) {\n      if (eventType === MessageReactionEventType.Delete && reactionType === MessageReactionType.Unique) {\n        // deletes of type unique are allowed to have no data\n        name = '';\n      } else {\n        return;\n      }\n    }\n\n    const reactionEvent: MessageReactionRawEvent = {\n      type: eventType,\n      timestamp: new Date(event.timestamp),\n      reaction: {\n        messageSerial: event.messageSerial,\n        type: reactionType,\n        name: name,\n        clientId: event.clientId ?? '',\n      },\n    };\n    if (event.count) {\n      reactionEvent.reaction.count = event.count;\n    } else if (eventType === MessageReactionEventType.Create && reactionType === MessageReactionType.Multiple) {\n      reactionEvent.reaction.count = 1; // count defaults to 1 for multiple if not set\n    }\n    this._emitter.emit(eventType, reactionEvent);\n  }\n\n  private _processMessageEvent(event: Ably.InboundMessage) {\n    this._logger.trace('MessagesReactions._processMessageEvent();', { event });\n\n    // only process summary events\n    if (event.action !== ChatMessageAction.MessageAnnotationSummary) {\n      return;\n    }\n    if (!event.summary) {\n      // This means the summary is now empty, which is valid.\n      // Happens when there are no reactions such as after deleting the last reaction.\n      event.summary = {};\n    }\n\n    // they must have a serial\n    if (!event.serial) {\n      this._logger.warn('DefaultMessageReactions._processMessageEvent(); received summary without serial', {\n        event,\n      });\n      return;\n    }\n\n    const unique = (event.summary[ReactionAnnotationType.Unique] ?? {}) as unknown as Ably.SummaryUniqueValues;\n    const distinct = (event.summary[ReactionAnnotationType.Distinct] ?? {}) as unknown as Ably.SummaryDistinctValues;\n    const multiple = (event.summary[ReactionAnnotationType.Multiple] ?? {}) as Ably.SummaryMultipleValues;\n\n    this._emitter.emit(MessageReactionEventType.Summary, {\n      type: MessageReactionEventType.Summary,\n      summary: {\n        messageSerial: event.serial,\n        unique: unique,\n        distinct: distinct,\n        multiple: multiple,\n      },\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  send(messageSerial: Serial, params: AddMessageReactionParams): Promise<void> {\n    this._logger.trace('MessagesReactions.add();', { messageSerial, params });\n    const serial = serialToString(messageSerial);\n\n    let { type, count } = params;\n    if (!type) {\n      type = this._defaultType;\n    }\n    if (type === MessageReactionType.Multiple && !count) {\n      count = 1;\n    }\n    const apiParams: APIAddMessageReactionParams = { type, name: params.name };\n    if (count) {\n      apiParams.count = count;\n    }\n    return this._api.addMessageReaction(this._roomName, serial, apiParams);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  delete(messageSerial: Serial, params?: DeleteMessageReactionParams): Promise<void> {\n    this._logger.trace('MessagesReactions.delete();', { messageSerial, params });\n    const serial = serialToString(messageSerial);\n\n    let type = params?.type;\n    if (!type) {\n      type = this._defaultType;\n    }\n    if (type !== MessageReactionType.Unique && !params?.name) {\n      throw new Ably.ErrorInfo(`cannot delete reaction of type ${type} without a name`, 40001, 400);\n    }\n    const apiParams: APIDeleteMessageReactionParams = { type };\n    if (type !== MessageReactionType.Unique) {\n      apiParams.name = params?.name;\n    }\n    return this._api.deleteMessageReaction(this._roomName, serial, apiParams);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  subscribe(listener: MessageReactionListener): Subscription {\n    this._logger.trace('MessagesReactions.subscribe();');\n\n    const wrapped = wrap(listener);\n    this._emitter.on(MessageReactionEventType.Summary, wrapped);\n    return {\n      unsubscribe: () => {\n        this._emitter.off(wrapped);\n      },\n    };\n  }\n\n  /**\n   * @inheritDoc\n   */\n  subscribeRaw(listener: MessageRawReactionListener): Subscription {\n    this._logger.trace('MessagesReactions.subscribeRaw();');\n\n    if (!this._options?.rawMessageReactions) {\n      throw new Ably.ErrorInfo('Raw message reactions are not enabled', 40001, 400);\n    }\n    const wrapped = wrap(listener);\n    this._emitter.on([MessageReactionEventType.Create, MessageReactionEventType.Delete], wrapped);\n    return {\n      unsubscribe: () => {\n        this._emitter.off(wrapped);\n      },\n    };\n  }\n\n  /**\n   * Merges the channel options to add support for message reactions.\n   *\n   * @param roomOptions The room options to merge for.\n   * @returns A function that merges the channel options for the room with the ones required for presence.\n   */\n  static channelOptionMerger(roomOptions: InternalRoomOptions): ChannelOptionsMerger {\n    return (options) => {\n      // annotation publish is always required for message reactions\n      if (!options.modes.includes('ANNOTATION_PUBLISH')) {\n        options.modes.push('ANNOTATION_PUBLISH');\n      }\n      // annotation subscribe is only required if the room has raw message reactions\n      if (roomOptions.messages.rawMessageReactions && !options.modes.includes('ANNOTATION_SUBSCRIBE')) {\n        options.modes.push('ANNOTATION_SUBSCRIBE');\n      }\n      return options;\n    };\n  }\n}\n","import { ChatMessageAction } from './events.js';\nimport { DefaultMessage, emptyMessageReactions, Message } from './message.js';\n\n// RestClientIdList represents a list of client IDs with aggregation data\nexport interface RestClientIdList {\n  total: number;\n  clientIds: string[];\n}\n\n// RestClientIdCounts represents client ID counts with aggregation data\nexport interface RestClientIdCounts {\n  total: number;\n  clientIds: Record<string, number>;\n  totalUnidentified: number;\n}\n\n// RestOperation represents an operation performed on a chat message\nexport interface RestOperation {\n  clientId?: string;\n  description?: string;\n  metadata?: Record<string, string>;\n}\n\n// ChatMessageReactions represents reactions on a chat message\nexport interface RestChatMessageReactions {\n  unique?: Record<string, RestClientIdList>;\n  distinct?: Record<string, RestClientIdList>;\n  multiple?: Record<string, RestClientIdCounts>;\n}\n\n// RestMessage represents a message in V3 of the REST API.\nexport interface RestMessage {\n  serial: string;\n  version: string;\n  text: string;\n  clientId: string;\n  action: 'message.create' | 'message.update' | 'message.delete';\n  metadata: Record<string, unknown>;\n  headers: Record<string, string>;\n  createdAt: number;\n  timestamp: number;\n  operation?: RestOperation;\n  reactions?: RestChatMessageReactions;\n}\n\n/**\n * Converts a message object from its REST representation to the standard message object in the SDK.\n *\n * @param message The message to convert from REST.\n * @returns The converted message.\n */\nexport const messageFromRest = (message: RestMessage): Message => {\n  const reactions = {\n    ...emptyMessageReactions(),\n    ...message.reactions,\n  };\n\n  // Convert the action to a ChatMessageAction enum, defaulting to MessageCreate if the action is not found.\n  const action = Object.values(ChatMessageAction).includes(message.action as ChatMessageAction)\n    ? (message.action as ChatMessageAction)\n    : ChatMessageAction.MessageCreate;\n\n  return new DefaultMessage({\n    ...message,\n    action,\n    createdAt: new Date(message.createdAt),\n    timestamp: new Date(message.timestamp),\n    reactions: reactions,\n  });\n};\n","import * as Ably from 'ably';\n\nimport { ChatApi } from './chat-api.js';\nimport { ChatMessageAction, ChatMessageEvent, ChatMessageEventType, RealtimeMessageName } from './events.js';\nimport { Logger } from './logger.js';\nimport {\n  DefaultMessage,\n  emptyMessageReactions,\n  Message,\n  MessageHeaders,\n  MessageMetadata,\n  MessageOperationMetadata,\n} from './message.js';\nimport { parseMessage } from './message-parser.js';\nimport { DefaultMessageReactions, MessagesReactions } from './messages-reactions.js';\nimport { PaginatedResult } from './query.js';\nimport { messageFromRest } from './rest-types.js';\nimport { MessageOptions } from './room-options.js';\nimport { Serial, serialToString } from './serial.js';\nimport { Subscription } from './subscription.js';\nimport EventEmitter, { wrap } from './utils/event-emitter.js';\n\n/**\n * Event names and their respective payloads emitted by the messages feature.\n */\ninterface MessageEventsMap {\n  [ChatMessageEventType.Created]: ChatMessageEvent;\n  [ChatMessageEventType.Updated]: ChatMessageEvent;\n  [ChatMessageEventType.Deleted]: ChatMessageEvent;\n}\n\n/**\n * Mapping of chat message actions to message events.\n */\nconst MessageActionsToEventsMap: Map<ChatMessageAction, ChatMessageEventType> = new Map<\n  ChatMessageAction,\n  ChatMessageEventType\n>([\n  [ChatMessageAction.MessageCreate, ChatMessageEventType.Created],\n  [ChatMessageAction.MessageUpdate, ChatMessageEventType.Updated],\n  [ChatMessageAction.MessageDelete, ChatMessageEventType.Deleted],\n]);\n\n/**\n * The order in which results should be returned when performing a paginated query (e.g. message history).\n */\nexport enum OrderBy {\n  /**\n   * Return results in ascending order (oldest first).\n   */\n  OldestFirst = 'oldestFirst',\n\n  /**\n   * Return results in descending order (newest first).\n   */\n  NewestFirst = 'newestFirst',\n}\n\n/**\n * Options for querying messages in a chat room.\n */\nexport interface QueryOptions {\n  /**\n   * The start of the time window to query from. If provided, the response will include\n   * messages with timestamps equal to or greater than this value.\n   *\n   * @defaultValue The beginning of time\n   */\n  start?: number;\n\n  /**\n   * The end of the time window to query from. If provided, the response will include\n   * messages with timestamps less than this value.\n   *\n   * @defaultValue Now\n   */\n  end?: number;\n\n  /**\n   * The maximum number of messages to return in the response.\n   *\n   * @defaultValue 100\n   */\n  limit?: number;\n\n  /**\n   * The direction to query messages in.\n   * If {@link OrderBy.OldestFirst}, the response will include messages from the start of the time window to the end.\n   * If {@link OrderBy.NewestFirst}, the response will include messages from the end of the time window to the start.\n   * If not provided, the default is {@link OrderBy.NewestFirst}.\n   *\n   * @defaultValue {@link OrderBy.NewestFirst}\n   */\n  orderBy?: OrderBy;\n}\n\n/**\n * The parameters supplied to a message action like delete or update.\n */\nexport interface OperationDetails {\n  /**\n   * Optional description for the message action.\n   */\n  description?: string;\n\n  /**\n   * Optional metadata that will be added to the action. Defaults to empty.\n   *\n   */\n  metadata?: MessageOperationMetadata;\n}\n\n/**\n * Parameters for updating a message.\n */\nexport interface UpdateMessageParams {\n  /**\n   * The new text of the message.\n   */\n  text: string;\n\n  /**\n   * Optional metadata of the message.\n   */\n  metadata?: MessageMetadata;\n\n  /**\n   * Optional headers of the message.\n   */\n  headers?: MessageHeaders;\n}\n\n/**\n * Parameters for deleting a message.\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface DeleteMessageParams extends OperationDetails {}\n\n/**\n * Params for sending a text message. Only `text` is mandatory.\n */\nexport interface SendMessageParams {\n  /**\n   * The text of the message.\n   */\n  text: string;\n\n  /**\n   * Optional metadata of the message.\n   *\n   * The metadata is a map of extra information that can be attached to chat\n   * messages. It is not used by Ably and is sent as part of the realtime\n   * message payload. Example use cases are setting custom styling like\n   * background or text colors or fonts, adding links to external images,\n   * emojis, etc.\n   *\n   * Do not use metadata for authoritative information. There is no server-side\n   * validation. When reading the metadata, treat it like user input.\n   *\n   */\n  metadata?: MessageMetadata;\n\n  /**\n   * Optional headers of the message.\n   *\n   * The headers are a flat key-value map and are sent as part of the realtime\n   * message's extras inside the `headers` property. They can serve similar\n   * purposes as the metadata, but they are read by Ably and can be used for\n   * features such as\n   * [subscription filters](https://faqs.ably.com/subscription-filters).\n   *\n   * Do not use the headers for authoritative information. There is no\n   * server-side validation. When reading the headers, treat them like user\n   * input.\n   *\n   */\n  headers?: MessageHeaders;\n}\n\n/**\n * A listener for message events in a chat room.\n * @param event The message event that was received.\n */\nexport type MessageListener = (event: ChatMessageEvent) => void;\n\n/**\n * A response object that allows you to control a message subscription.\n */\nexport interface MessageSubscriptionResponse extends Subscription {\n  /**\n   * Get the previous messages that were sent to the room before the listener was subscribed.\n   *\n   * If the client experiences a discontinuity event (i.e. the connection was lost and could not be resumed), the starting point of\n   * historyBeforeSubscribe will be reset.\n   *\n   * Calls to historyBeforeSubscribe will wait for continuity to be restored before resolving.\n   *\n   * Once continuity is restored, the subscription point will be set to the beginning of this new period of continuity. To\n   * ensure that no messages are missed, you should call historyBeforeSubscribe after any period of discontinuity to\n   * fill any gaps in the message history.\n   *\n   * ```typescript\n   * const { historyBeforeSubscribe } = room.messages.subscribe(listener);\n   * await historyBeforeSubscribe({ limit: 10 });\n   * ```\n   *\n   * @param params Options for the history query.\n   * @returns A promise that resolves with the paginated result of messages, in newest-to-oldest order.\n   */\n  historyBeforeSubscribe(params: Omit<QueryOptions, 'orderBy'>): Promise<PaginatedResult<Message>>;\n}\n\n/**\n * This interface is used to interact with messages in a chat room: subscribing\n * to new messages, fetching history, or sending messages.\n *\n * Get an instance via {@link Room.messages}.\n */\nexport interface Messages {\n  /**\n   * Subscribe to new messages in this chat room.\n   * @param listener callback that will be called\n   * @returns A response object that allows you to control the subscription.\n   */\n  subscribe(listener: MessageListener): MessageSubscriptionResponse;\n\n  /**\n   * Get messages that have been previously sent to the chat room, based on the provided options.\n   *\n   * @param options Options for the query.\n   * @returns A promise that resolves with the paginated result of messages. This paginated result can\n   * be used to fetch more messages if available.\n   */\n  history(options: QueryOptions): Promise<PaginatedResult<Message>>;\n\n  /**\n   * Send a message in the chat room.\n   *\n   * This method uses the Ably Chat API endpoint for sending messages.\n   *\n   * Note that the Promise may resolve before OR after the message is received\n   * from the realtime channel. This means you may see the message that was just\n   * sent in a callback to `subscribe` before the returned promise resolves.\n   *\n   * @param params an object containing {text, headers, metadata} for the message\n   * to be sent. Text is required, metadata and headers are optional.\n   * @returns A promise that resolves when the message was published.\n   */\n  send(params: SendMessageParams): Promise<Message>;\n\n  /**\n   * Delete a message in the chat room.\n   *\n   * This method uses the Ably Chat API REST endpoint for deleting messages.\n   * It performs a `soft` delete, meaning the message is marked as deleted.\n   *\n   * Note that the Promise may resolve before OR after the message is deleted\n   * from the realtime channel. This means you may see the message that was just\n   * deleted in a callback to `subscribe` before the returned promise resolves.\n   *\n   * NOTE: The Message instance returned by this method is the state of the message as a result of the delete operation.\n   * If you have a subscription to message events via `subscribe`, you should discard the message instance returned by\n   * this method and use the event payloads from the subscription instead.\n   *\n   * Should you wish to restore a deleted message, and providing you have the appropriate permissions,\n   * you can simply send an update to the original message.\n   * Note: This is subject to change in future versions, whereby a new permissions model will be introduced\n   * and a deleted message may not be restorable in this way.\n   *\n   * @returns A promise that resolves when the message was deleted.\n   * @param serial - A string or object that conveys the serial of the message to delete.\n   * @param deleteMessageParams - Optional details to record about the delete action.\n   * @return A promise that resolves to the deleted message.\n   */\n  delete(serial: Serial, deleteMessageParams?: DeleteMessageParams): Promise<Message>;\n\n  /**\n   * Update a message in the chat room.\n   *\n   * Note that the Promise may resolve before OR after the updated message is\n   * received from the realtime channel. This means you may see the update that\n   * was just sent in a callback to `subscribe` before the returned promise\n   * resolves.\n   *\n   * NOTE: The Message instance returned by this method is the state of the message as a result of the update operation.\n   * If you have a subscription to message events via `subscribe`, you should discard the message instance returned by\n   * this method and use the event payloads from the subscription instead.\n   *\n   * This method uses PUT-like semantics: if headers and metadata are omitted from the updateParams, then\n   * the existing headers and metadata are replaced with the empty objects.\n   *\n   * @param serial - A string or object that conveys the serial of the message to update.\n   * @param updateParams - The parameters for updating the message.\n   * @param details - Optional details to record about the update action.\n   * @returns A promise of the updated message.\n   */\n  update(serial: Serial, updateParams: UpdateMessageParams, details?: OperationDetails): Promise<Message>;\n\n  /**\n   * Add, delete, and subscribe to message reactions.\n   */\n  reactions: MessagesReactions;\n}\n\n/**\n * @inheritDoc\n */\nexport class DefaultMessages implements Messages {\n  private readonly _roomName: string;\n  private readonly _options: MessageOptions;\n  private readonly _channel: Ably.RealtimeChannel;\n  private readonly _chatApi: ChatApi;\n  private readonly _clientId: string;\n  private readonly _listenerSubscriptionPoints: Map<\n    MessageListener,\n    Promise<{\n      fromSerial: string;\n    }>\n  >;\n  private readonly _logger: Logger;\n  private readonly _emitter = new EventEmitter<MessageEventsMap>();\n\n  public readonly reactions: MessagesReactions;\n\n  /**\n   * Constructs a new `DefaultMessages` instance.\n   * @param roomName The unique identifier of the room.\n   * @param channel An instance of the Realtime channel for the room.\n   * @param chatApi An instance of the ChatApi.\n   * @param clientId The client ID of the user.\n   * @param logger An instance of the Logger.\n   */\n  constructor(\n    roomName: string,\n    options: MessageOptions,\n    channel: Ably.RealtimeChannel,\n    chatApi: ChatApi,\n    clientId: string,\n    logger: Logger,\n  ) {\n    this._roomName = roomName;\n    this._options = options;\n    this._channel = channel;\n    this._chatApi = chatApi;\n    this._clientId = clientId;\n    this._logger = logger;\n    this._listenerSubscriptionPoints = new Map<MessageListener, Promise<{ fromSerial: string }>>();\n\n    this.reactions = new DefaultMessageReactions(this._logger, options, this._chatApi, this._roomName, this._channel);\n    this._applyChannelSubscriptions();\n  }\n\n  /**\n   * Sets up channel subscriptions for messages.\n   */\n  private _applyChannelSubscriptions(): void {\n    // attachOnSubscribe is set to false in the default channel options, so this call cannot fail\n    void this._channel.subscribe([RealtimeMessageName.ChatMessage], this._processEvent.bind(this));\n\n    // Handles the case where channel attaches and resume state is false. This can happen when the channel is first attached,\n    // or when the channel is reattached after a detach. In both cases, we reset the subscription points for all listeners.\n    this._channel.on('attached', (message) => {\n      this._handleAttach(message.resumed);\n    });\n\n    // Handles the case where an update message is received from a channel after a detach and reattach.\n    this._channel.on('update', (message) => {\n      if (message.current === 'attached' && message.previous === 'attached') {\n        this._handleAttach(message.resumed);\n      }\n    });\n  }\n\n  /**\n   * @inheritdoc Messages\n   */\n  private async _getBeforeSubscriptionStart(\n    listener: MessageListener,\n    params: Omit<QueryOptions, 'orderBy'>,\n  ): Promise<PaginatedResult<Message>> {\n    this._logger.trace(`DefaultSubscriptionManager.getBeforeSubscriptionStart();`);\n\n    const subscriptionPoint = this._listenerSubscriptionPoints.get(listener);\n\n    if (subscriptionPoint === undefined) {\n      this._logger.error(\n        `DefaultSubscriptionManager.getBeforeSubscriptionStart(); listener has not been subscribed yet`,\n      );\n      throw new Ably.ErrorInfo(\n        'cannot query history; listener has not been subscribed yet',\n        40000,\n        400,\n      ) as unknown as Error;\n    }\n\n    // Get the subscription point of the listener\n    const subscriptionPointParams = await subscriptionPoint;\n\n    // Query messages from the subscription point to the start of the time window\n    return this._chatApi.getMessages(this._roomName, {\n      ...params,\n      orderBy: OrderBy.NewestFirst,\n      ...subscriptionPointParams,\n    });\n  }\n\n  /**\n   * Handle the case where the channel experiences a detach and reattaches.\n   */\n  private _handleAttach(fromResume: boolean) {\n    this._logger.trace(`DefaultSubscriptionManager.handleAttach();`);\n\n    // Do nothing if we have resumed as there is no discontinuity in the message stream\n    if (fromResume) return;\n\n    // Reset subscription points for all listeners\n    const newSubscriptionStartResolver = this._subscribeAtChannelAttach();\n    for (const [listener] of this._listenerSubscriptionPoints.entries()) {\n      this._listenerSubscriptionPoints.set(listener, newSubscriptionStartResolver);\n    }\n  }\n\n  /**\n   * Create a promise that resolves with the attachSerial of the channel or the serial of the latest message.\n   */\n  private async _resolveSubscriptionStart(): Promise<{\n    fromSerial: string;\n  }> {\n    const channelWithProperties = this._getChannelProperties();\n\n    // If we are attached, we can resolve with the channelSerial\n    if (channelWithProperties.state === 'attached') {\n      if (channelWithProperties.properties.channelSerial) {\n        return { fromSerial: channelWithProperties.properties.channelSerial };\n      }\n      this._logger.error(`DefaultSubscriptionManager.handleAttach(); channelSerial is undefined`);\n      throw new Ably.ErrorInfo('channel is attached, but channelSerial is not defined', 40000, 400) as unknown as Error;\n    }\n\n    return this._subscribeAtChannelAttach();\n  }\n\n  private _getChannelProperties(): Ably.RealtimeChannel & {\n    properties: { attachSerial: string | undefined; channelSerial: string | undefined };\n  } {\n    // Get the attachSerial from the channel properties\n    return this._channel as Ably.RealtimeChannel & {\n      properties: {\n        attachSerial: string | undefined;\n        channelSerial: string | undefined;\n      };\n    };\n  }\n\n  private async _subscribeAtChannelAttach(): Promise<{ fromSerial: string }> {\n    const channelWithProperties = this._getChannelProperties();\n    return new Promise((resolve, reject) => {\n      // Check if the state is now attached\n      if (channelWithProperties.state === 'attached') {\n        // Get the attachSerial from the channel properties\n        // AttachSerial should always be defined at this point, but we check just in case\n        this._logger.debug('Messages._subscribeAtChannelAttach(); channel is attached already, using attachSerial', {\n          attachSerial: channelWithProperties.properties.attachSerial,\n        });\n        if (channelWithProperties.properties.attachSerial) {\n          resolve({ fromSerial: channelWithProperties.properties.attachSerial });\n        } else {\n          this._logger.error(`DefaultSubscriptionManager.handleAttach(); attachSerial is undefined`);\n          reject(\n            new Ably.ErrorInfo('channel is attached, but attachSerial is not defined', 40000, 400) as unknown as Error,\n          );\n        }\n      }\n\n      channelWithProperties.once('attached', () => {\n        // Get the attachSerial from the channel properties\n        // AttachSerial should always be defined at this point, but we check just in case\n        this._logger.debug('Messages._subscribeAtChannelAttach(); channel is now attached, using attachSerial', {\n          attachSerial: channelWithProperties.properties.attachSerial,\n        });\n        if (channelWithProperties.properties.attachSerial) {\n          resolve({ fromSerial: channelWithProperties.properties.attachSerial });\n        } else {\n          this._logger.error(`DefaultSubscriptionManager.handleAttach(); attachSerial is undefined`);\n          reject(\n            new Ably.ErrorInfo('channel is attached, but attachSerial is not defined', 40000, 400) as unknown as Error,\n          );\n        }\n      });\n    });\n  }\n\n  /**\n   * @inheritdoc Messages\n   */\n  async history(options: QueryOptions): Promise<PaginatedResult<Message>> {\n    this._logger.trace('Messages.query();');\n    return this._chatApi.getMessages(this._roomName, options);\n  }\n\n  /**\n   * @inheritdoc Messages\n   */\n  async send(params: SendMessageParams): Promise<Message> {\n    this._logger.trace('Messages.send();', { params });\n\n    const { text, metadata, headers } = params;\n\n    const response = await this._chatApi.sendMessage(this._roomName, { text, headers, metadata });\n    return new DefaultMessage({\n      serial: response.serial,\n      clientId: this._clientId,\n      text: text,\n      metadata: metadata ?? {},\n      headers: headers ?? {},\n      action: ChatMessageAction.MessageCreate,\n      version: response.serial,\n      createdAt: new Date(response.createdAt),\n      timestamp: new Date(response.createdAt), // timestamp is the same as createdAt for new messages\n      reactions: emptyMessageReactions(),\n    });\n  }\n\n  /**\n   * @inheritdoc Messages\n   */\n  async delete(serial: Serial, params?: DeleteMessageParams): Promise<Message> {\n    this._logger.trace('Messages.delete();', { params });\n\n    serial = serialToString(serial);\n    this._logger.debug('Messages.delete(); serial', { serial });\n    const response = await this._chatApi.deleteMessage(this._roomName, serial, params);\n\n    return messageFromRest(response.message);\n  }\n\n  /**\n   * @inheritdoc Messages\n   */\n  async update(serial: Serial, updateParams: UpdateMessageParams, details?: OperationDetails): Promise<Message> {\n    this._logger.trace('Messages.update();', { updateParams, details });\n\n    serial = serialToString(serial);\n    this._logger.debug('Messages.update(); serial', { serial });\n    const response = await this._chatApi.updateMessage(this._roomName, serial, {\n      message: {\n        text: updateParams.text,\n        metadata: updateParams.metadata,\n        headers: updateParams.headers,\n      },\n      ...details,\n    });\n\n    this._logger.debug('Messages.update(); message update successfully', { updateParams });\n    return messageFromRest(response.message);\n  }\n\n  /**\n   * @inheritdoc Messages\n   */\n  subscribe(listener: MessageListener): MessageSubscriptionResponse {\n    this._logger.trace('Messages.subscribe();');\n    const wrapped = wrap(listener);\n    this._emitter.on(\n      [ChatMessageEventType.Created, ChatMessageEventType.Updated, ChatMessageEventType.Deleted],\n      wrapped,\n    );\n\n    // Set the subscription point to a promise that resolves when the channel attaches or with the latest message\n    const resolvedSubscriptionStart = this._resolveSubscriptionStart();\n\n    // Add a handler for unhandled rejections in case the room is released before the subscription point is resolved\n    resolvedSubscriptionStart.catch(() => {\n      this._logger.debug('Messages.subscribe(); subscription point was not resolved before the room was released');\n    });\n\n    this._listenerSubscriptionPoints.set(wrapped, resolvedSubscriptionStart);\n\n    return {\n      unsubscribe: () => {\n        // Remove the wrapped listener from the subscription points\n        this._listenerSubscriptionPoints.delete(wrapped);\n        this._logger.trace('Messages.unsubscribe();');\n        this._emitter.off(wrapped);\n      },\n      historyBeforeSubscribe: (params: Omit<QueryOptions, 'orderBy'>) =>\n        this._getBeforeSubscriptionStart(wrapped, params),\n    };\n  }\n\n  private _processEvent(channelEventMessage: Ably.InboundMessage) {\n    this._logger.trace('Messages._processEvent();', {\n      channelEventMessage,\n    });\n    const { action } = channelEventMessage;\n    const event = MessageActionsToEventsMap.get(action as ChatMessageAction);\n    if (!event) {\n      this._logger.debug('Messages._processEvent(); received unknown message action', { action });\n      return;\n    }\n    // Send the message to the listeners\n    const message = this._parseNewMessage(channelEventMessage);\n    if (!message) {\n      return;\n    }\n\n    this._emitter.emit(event, { type: event, message: message });\n  }\n\n  /**\n   * Validate the realtime message and convert it to a chat message.\n   */\n  private _parseNewMessage(channelEventMessage: Ably.InboundMessage): Message | undefined {\n    try {\n      return parseMessage(channelEventMessage);\n    } catch (error: unknown) {\n      this._logger.error(`failed to parse incoming message;`, { channelEventMessage, error: error as Ably.ErrorInfo });\n    }\n  }\n}\n","import * as Ably from 'ably';\n\nimport { Logger } from './logger.js';\nimport { Message, MessageHeaders, MessageMetadata, MessageOperationMetadata } from './message.js';\nimport { OrderBy } from './messages.js';\nimport { OccupancyData } from './occupancy.js';\nimport { PaginatedResult } from './query.js';\nimport { messageFromRest, RestMessage } from './rest-types.js';\n\nexport interface GetMessagesQueryParams {\n  start?: number;\n  end?: number;\n  orderBy?: OrderBy;\n  limit?: number;\n  /**\n   * Serial indicating the starting point for message retrieval.\n   * This serial is specific to the region of the channel the client is connected to. Messages published within\n   * the same region of the channel are guaranteed to be received in increasing serial order.\n   *\n   * @defaultValue undefined (not used if not specified)\n   */\n  fromSerial?: string;\n}\n\n/**\n * In the REST API, we currently use the `direction` query parameter to specify the order of messages instead\n * of orderBy. So define this type for conversion purposes.\n */\ntype ApiGetMessagesQueryParams = Omit<GetMessagesQueryParams, 'orderBy'> & {\n  direction?: 'forwards' | 'backwards';\n};\n\nexport interface CreateMessageResponse {\n  serial: string;\n  createdAt: number;\n}\n\ninterface SendMessageParams {\n  text: string;\n  metadata?: MessageMetadata;\n  headers?: MessageHeaders;\n}\n\n/**\n * Represents the response for deleting or updating a message.\n */\nexport interface MessageOperationResponse {\n  /**\n   * The new message version.\n   */\n  version: string;\n\n  /**\n   * The timestamp of the operation.\n   */\n  timestamp: number;\n\n  /**\n   * The message that was created or updated.\n   */\n  message: RestMessage;\n}\n\ntype UpdateMessageResponse = MessageOperationResponse;\n\ntype DeleteMessageResponse = MessageOperationResponse;\n\ninterface UpdateMessageParams {\n  /**\n   * Message data to update. All fields are updated and, if omitted, they are\n   * set to empty.\n   */\n  message: {\n    text: string;\n    metadata?: MessageMetadata;\n    headers?: MessageHeaders;\n  };\n\n  /** Description of the update action */\n  description?: string;\n\n  /** Metadata of the update action */\n  metadata?: MessageOperationMetadata;\n}\n\ninterface DeleteMessageParams {\n  /** Description of the delete action */\n  description?: string;\n\n  /** Metadata of the delete action */\n  metadata?: MessageOperationMetadata;\n}\n\n/**\n * Parameters for adding a message reaction.\n */\nexport interface AddMessageReactionParams {\n  /**\n   * The type of reaction, must be one of {@link MessageReactionType}.\n   */\n  type: string;\n\n  /**\n   * The reaction name to add; ie. the emoji.\n   */\n  name: string;\n\n  /**\n   * The count of the reaction for type {@link MessageReactionType.Multiple}.\n   * Defaults to 1 if not set. Not supported for other reaction types.\n   * @default 1\n   */\n  count?: number;\n}\n\n/**\n * Parameters for deleting a message reaction.\n */\nexport interface DeleteMessageReactionParams {\n  /**\n   * The type of reaction, must be one of {@link MessageReactionType}.\n   */\n  type: string;\n\n  /**\n   * The reaction name to remove, ie. the emoji. Required for all reaction types\n   * except {@link MessageReactionType.Unique}.\n   */\n  name?: string;\n}\n\n/**\n * Chat SDK Backend\n */\nexport class ChatApi {\n  private readonly _realtime: Ably.Realtime;\n  private readonly _logger: Logger;\n  private readonly _apiProtocolVersion: number = 3;\n\n  constructor(realtime: Ably.Realtime, logger: Logger) {\n    this._realtime = realtime;\n    this._logger = logger;\n  }\n\n  async getMessages(roomName: string, params: GetMessagesQueryParams): Promise<PaginatedResult<Message>> {\n    roomName = encodeURIComponent(roomName);\n\n    // convert the params into internal format\n    const apiParams: ApiGetMessagesQueryParams = { ...params };\n    if (params.orderBy) {\n      switch (params.orderBy) {\n        case OrderBy.NewestFirst: {\n          apiParams.direction = 'backwards';\n          break;\n        }\n        case OrderBy.OldestFirst: {\n          apiParams.direction = 'forwards';\n          break;\n        }\n        default: {\n          // in vanilla JS use-cases, without types, we need to check non-enum values\n          // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n          throw new Ably.ErrorInfo(`invalid orderBy value: ${params.orderBy}`, 40000, 400);\n        }\n      }\n    }\n\n    const data = await this._makeAuthorizedPaginatedRequest<RestMessage>(\n      `/chat/v3/rooms/${roomName}/messages`,\n      apiParams,\n    );\n    return this._recursivePaginateMessages(data);\n  }\n\n  private _recursivePaginateMessages(data: PaginatedResult<RestMessage>): PaginatedResult<Message> {\n    const paginatedResult: PaginatedResult<Message> = {} as PaginatedResult<Message>;\n    paginatedResult.items = data.items.map((payload) => messageFromRest(payload));\n\n    // Recursively map the next paginated data\n    paginatedResult.next = () =>\n      data.next().then((nextData) => {\n        // eslint-disable-next-line unicorn/no-null\n        return nextData ? this._recursivePaginateMessages(nextData) : null;\n      });\n\n    paginatedResult.first = () => data.first().then((firstData) => this._recursivePaginateMessages(firstData));\n\n    paginatedResult.current = () => data.current().then((currentData) => this._recursivePaginateMessages(currentData));\n\n    paginatedResult.hasNext = () => data.hasNext();\n\n    paginatedResult.isLast = () => data.isLast();\n\n    return { ...data, ...paginatedResult };\n  }\n\n  deleteMessage(roomName: string, serial: string, params?: DeleteMessageParams): Promise<DeleteMessageResponse> {\n    const body: { description?: string; metadata?: MessageOperationMetadata } = {\n      description: params?.description,\n      metadata: params?.metadata,\n    };\n    serial = encodeURIComponent(serial);\n    roomName = encodeURIComponent(roomName);\n    return this._makeAuthorizedRequest<DeleteMessageResponse>(\n      `/chat/v3/rooms/${roomName}/messages/${serial}/delete`,\n      'POST',\n      body,\n      {},\n    );\n  }\n\n  sendMessage(roomName: string, params: SendMessageParams): Promise<CreateMessageResponse> {\n    const body: {\n      text: string;\n      metadata?: MessageMetadata;\n      headers?: MessageHeaders;\n    } = { text: params.text };\n    if (params.metadata) {\n      body.metadata = params.metadata;\n    }\n    if (params.headers) {\n      body.headers = params.headers;\n    }\n    roomName = encodeURIComponent(roomName);\n    return this._makeAuthorizedRequest<CreateMessageResponse>(`/chat/v3/rooms/${roomName}/messages`, 'POST', body);\n  }\n\n  updateMessage(roomName: string, serial: string, params: UpdateMessageParams): Promise<UpdateMessageResponse> {\n    const encodedSerial = encodeURIComponent(serial);\n    roomName = encodeURIComponent(roomName);\n    return this._makeAuthorizedRequest<UpdateMessageResponse>(\n      `/chat/v3/rooms/${roomName}/messages/${encodedSerial}`,\n      'PUT',\n      params,\n    );\n  }\n\n  addMessageReaction(roomName: string, serial: string, data: AddMessageReactionParams): Promise<void> {\n    const encodedSerial = encodeURIComponent(serial);\n    roomName = encodeURIComponent(roomName);\n    return this._makeAuthorizedRequest(`/chat/v3/rooms/${roomName}/messages/${encodedSerial}/reactions`, 'POST', data);\n  }\n\n  deleteMessageReaction(roomName: string, serial: string, data: DeleteMessageReactionParams): Promise<void> {\n    const encodedSerial = encodeURIComponent(serial);\n    roomName = encodeURIComponent(roomName);\n    return this._makeAuthorizedRequest(\n      `/chat/v3/rooms/${roomName}/messages/${encodedSerial}/reactions`,\n      'DELETE',\n      undefined,\n      data,\n    );\n  }\n\n  getOccupancy(roomName: string): Promise<OccupancyData> {\n    roomName = encodeURIComponent(roomName);\n    return this._makeAuthorizedRequest<OccupancyData>(`/chat/v3/rooms/${roomName}/occupancy`, 'GET');\n  }\n\n  private async _makeAuthorizedRequest<RES = undefined>(\n    url: string,\n    method: 'POST' | 'GET' | 'PUT' | 'DELETE' | 'PATCH',\n    body?: unknown,\n    params?: unknown,\n  ): Promise<RES> {\n    const response = await this._realtime.request<RES>(method, url, this._apiProtocolVersion, params, body);\n    if (!response.success) {\n      this._logger.error('ChatApi._makeAuthorizedRequest(); failed to make request', {\n        url,\n        statusCode: response.statusCode,\n        errorCode: response.errorCode,\n        errorMessage: response.errorMessage,\n      });\n      throw new Ably.ErrorInfo(response.errorMessage, response.errorCode, response.statusCode);\n    }\n\n    return response.items[0] as RES;\n  }\n\n  private async _makeAuthorizedPaginatedRequest<RES>(\n    url: string,\n    params?: unknown,\n    body?: unknown,\n  ): Promise<PaginatedResult<RES>> {\n    const response = await this._realtime.request('GET', url, this._apiProtocolVersion, params, body);\n    if (!response.success) {\n      this._logger.error('ChatApi._makeAuthorizedPaginatedRequest(); failed to make request', {\n        url,\n        statusCode: response.statusCode,\n        errorCode: response.errorCode,\n        errorMessage: response.errorMessage,\n      });\n      throw new Ably.ErrorInfo(response.errorMessage, response.errorCode, response.statusCode);\n    }\n    return response;\n  }\n}\n","import * as Ably from 'ably';\n\n/**\n * Error codes for the Chat SDK.\n */\nexport enum ErrorCode {\n  /**\n   * The request was invalid.\n   */\n  BadRequest = 40000,\n\n  /**\n   * The message was rejected before publishing by a rule on the chat room.\n   */\n  MessageRejectedByBeforePublishRule = 42211,\n\n  /**\n   * The message was rejected before publishing by a moderation rule on the chat room.\n   */\n  MessageRejectedByModeration = 42213,\n\n  /**\n   * The room has experienced a discontinuity.\n   */\n  RoomDiscontinuity = 102100,\n\n  // Unable to perform operation;\n\n  /**\n   * Cannot perform operation because the room is in a failed state.\n   */\n  RoomInFailedState = 102101,\n\n  /**\n   * Cannot perform operation because the room is in a releasing state.\n   */\n  RoomIsReleasing = 102102,\n\n  /**\n   * Cannot perform operation because the room is in a released state.\n   */\n  RoomIsReleased = 102103,\n\n  /**\n   * Room was released before the operation could complete.\n   */\n  RoomReleasedBeforeOperationCompleted = 102106,\n}\n\n/**\n * Returns true if the {@link Ably.ErrorInfo} code matches the provided ErrorCode value.\n *\n * @param errorInfo The error info to check.\n * @param error The error code to compare against.\n * @returns true if the error code matches, false otherwise.\n */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\nexport const errorInfoIs = (errorInfo: Ably.ErrorInfo, error: ErrorCode): boolean => errorInfo.code === error;\n","/**\n * Generates a random string that can be used as an identifier, for instance, in identifying specific room\n * objects.\n *\n * @returns A random string that can be used as an identifier.\n */\nexport const randomId = (): string => Math.random().toString(36).slice(2);\n","/**\n * Gets the single main channel for the chat room.\n *\n * @param roomName The room name.\n * @returns  The channel name.\n */\nexport const roomChannelName = (roomName: string): string => `${roomName}::$chat`;\n","import * as Ably from 'ably';\n\n// Update this when you release a new version\nexport const VERSION = '0.10.0';\nexport const CHANNEL_OPTIONS_AGENT_STRING = `chat-js/${VERSION}`;\nexport const CHANNEL_OPTIONS_AGENT_STRING_REACT = `chat-react/${VERSION}`;\n// Modes required for basic message functionality\nexport const DEFAULT_CHANNEL_MODES: Ably.ChannelMode[] = ['PUBLISH', 'SUBSCRIBE'];\nexport const DEFAULT_CHANNEL_OPTIONS: Ably.ChannelOptions = {\n  params: { agent: CHANNEL_OPTIONS_AGENT_STRING },\n  attachOnSubscribe: false,\n  modes: DEFAULT_CHANNEL_MODES,\n};\n\nexport const DEFAULT_CHANNEL_OPTIONS_REACT: Ably.ChannelOptions = {\n  params: { agent: CHANNEL_OPTIONS_AGENT_STRING_REACT },\n  attachOnSubscribe: false,\n  modes: DEFAULT_CHANNEL_MODES,\n};\n","import * as Ably from 'ably';\n\nimport { roomChannelName } from './channel.js';\nimport { Logger } from './logger.js';\nimport { DEFAULT_CHANNEL_OPTIONS, DEFAULT_CHANNEL_OPTIONS_REACT } from './version.js';\n\nexport type ChannelOptionsWithModes = Omit<Ably.ChannelOptions, 'modes'> & Required<Pick<Ably.ChannelOptions, 'modes'>>;\n\nexport type ChannelOptionsMerger = (options: ChannelOptionsWithModes) => ChannelOptionsWithModes;\n\nexport class ChannelManager {\n  private readonly _realtime: Ably.Realtime;\n  private readonly _logger: Logger;\n  private _registeredOptions: ChannelOptionsWithModes;\n  private readonly _isReact: boolean;\n  private _resolvedChannel?: Ably.RealtimeChannel;\n  private readonly _channelId: string;\n\n  constructor(roomName: string, realtime: Ably.Realtime, logger: Logger, isReact: boolean) {\n    logger.trace('ChannelManager();', { isReact });\n    this._realtime = realtime;\n    this._logger = logger;\n    this._isReact = isReact;\n    this._registeredOptions = this._defaultChannelOptions();\n    this._channelId = roomChannelName(roomName);\n  }\n\n  mergeOptions(merger: ChannelOptionsMerger): void {\n    this._logger.trace('ChannelManager.mergeOptions();');\n    if (this._resolvedChannel) {\n      this._logger.error('channel options cannot be modified after the channel has been requested');\n      throw new Ably.ErrorInfo('channel options cannot be modified after the channel has been requested', 40000, 400);\n    }\n\n    this._registeredOptions = merger(this._registeredOptions);\n  }\n\n  get(): Ably.RealtimeChannel {\n    this._logger.trace('ChannelManager.get();');\n\n    this._resolvedChannel ??= this._realtime.channels.get(this._channelId, this._registeredOptions);\n\n    return this._resolvedChannel;\n  }\n\n  release(): void {\n    this._logger.trace('ChannelManager.release();', { channelId: this._channelId });\n    if (!this._resolvedChannel) {\n      return;\n    }\n\n    this._realtime.channels.release(this._channelId);\n  }\n\n  private _defaultChannelOptions(): ChannelOptionsWithModes {\n    this._logger.trace('ChannelManager._defaultChannelOptions();');\n\n    const baseOptions = this._isReact ? DEFAULT_CHANNEL_OPTIONS_REACT : DEFAULT_CHANNEL_OPTIONS;\n    this._logger.trace(this._isReact ? 'using react channel options' : 'using default channel options');\n\n    // Create a deep copy of the options, ensuring modes array is also copied\n    return { ...baseOptions, modes: [...(baseOptions.modes ?? [])] } as ChannelOptionsWithModes;\n  }\n}\n","import * as Ably from 'ably';\n\nimport { ChannelOptionsMerger } from './channel-manager.js';\nimport { ChatApi } from './chat-api.js';\nimport { OccupancyEvent, OccupancyEventType, RealtimeMetaEventType } from './events.js';\nimport { Logger } from './logger.js';\nimport { InternalRoomOptions } from './room-options.js';\nimport { Subscription } from './subscription.js';\nimport EventEmitter, { wrap } from './utils/event-emitter.js';\n\n/**\n * This interface is used to interact with occupancy in a chat room: subscribing to occupancy updates and\n * fetching the current room occupancy metrics.\n *\n * Get an instance via {@link Room.occupancy}.\n */\nexport interface Occupancy {\n  /**\n   * Subscribe a given listener to occupancy updates of the chat room.\n   *\n   * Note: This requires occupancy events to be enabled via the `enableEvents` option in\n   * the {@link OccupancyOptions} options provided to the room. If this is not enabled, an error will be thrown.\n   *\n   * @param listener A listener to be called when the occupancy of the room changes.\n   * @returns A subscription object that can be used to unsubscribe the listener.\n   * @throws {Ably.ErrorInfo} If occupancy events are not enabled for this room.\n   */\n  subscribe(listener: OccupancyListener): Subscription;\n\n  /**\n   * Get the current occupancy of the chat room.\n   *\n   * @returns A promise that resolves to the current occupancy of the chat room.\n   */\n  get(): Promise<OccupancyData>;\n\n  /**\n   * Get the latest occupancy data received from realtime events.\n   *\n   * @returns The latest occupancy data, or undefined if no realtime events have been received yet.\n   * @throws {Ably.ErrorInfo} If occupancy events are not enabled for this room.\n   */\n  current(): OccupancyData | undefined;\n}\n\n/**\n * Represents the occupancy data of a chat room.\n */\nexport interface OccupancyData {\n  /**\n   * The number of connections to the chat room.\n   */\n  connections: number;\n\n  /**\n   * The number of presence members in the chat room - members who have entered presence.\n   */\n  presenceMembers: number;\n}\n\n/**\n * A listener that is called when the occupancy of a chat room changes.\n * @param event The occupancy event.\n */\nexport type OccupancyListener = (event: OccupancyEvent) => void;\n\ninterface OccupancyEventsMap {\n  [OccupancyEventType.Updated]: OccupancyEvent;\n}\n\n/**\n * @inheritDoc\n */\nexport class DefaultOccupancy implements Occupancy {\n  private readonly _roomName: string;\n  private readonly _channel: Ably.RealtimeChannel;\n  private readonly _chatApi: ChatApi;\n  private readonly _logger: Logger;\n  private readonly _emitter = new EventEmitter<OccupancyEventsMap>();\n  private readonly _roomOptions: InternalRoomOptions;\n  private _latestOccupancyData?: OccupancyData;\n\n  /**\n   * Constructs a new `DefaultOccupancy` instance.\n   * @param roomName The unique identifier of the room.\n   * @param channel An instance of the Realtime channel.\n   * @param chatApi An instance of the ChatApi.\n   * @param logger An instance of the Logger.\n   * @param roomOptions The room options.\n   */\n  constructor(\n    roomName: string,\n    channel: Ably.RealtimeChannel,\n    chatApi: ChatApi,\n    logger: Logger,\n    roomOptions: InternalRoomOptions,\n  ) {\n    this._roomName = roomName;\n    this._channel = channel;\n    this._chatApi = chatApi;\n    this._logger = logger;\n    this._roomOptions = roomOptions;\n\n    this._applyChannelSubscriptions();\n  }\n\n  /**\n   * Sets up channel subscriptions for occupancy.\n   */\n  private _applyChannelSubscriptions(): void {\n    // attachOnSubscribe is set to false in the default channel options, so this call cannot fail\n    void this._channel.subscribe([RealtimeMetaEventType.Occupancy], this._internalOccupancyListener.bind(this));\n  }\n\n  /**\n   * @inheritdoc Occupancy\n   */\n  subscribe(listener: OccupancyListener): Subscription {\n    this._logger.trace('Occupancy.subscribe();');\n\n    if (!this._roomOptions.occupancy.enableEvents) {\n      throw new Ably.ErrorInfo(\n        'cannot subscribe to occupancy; occupancy events are not enabled in room options',\n        40000,\n        400,\n      ) as unknown as Error;\n    }\n\n    const wrapped = wrap(listener);\n    this._emitter.on(wrapped);\n\n    return {\n      unsubscribe: () => {\n        this._logger.trace('Occupancy.unsubscribe();');\n        this._emitter.off(wrapped);\n      },\n    };\n  }\n\n  /**\n   * @inheritdoc Occupancy\n   */\n  async get(): Promise<OccupancyData> {\n    this._logger.trace('Occupancy.get();');\n    return this._chatApi.getOccupancy(this._roomName);\n  }\n\n  /**\n   * @inheritdoc Occupancy\n   */\n  current(): OccupancyData | undefined {\n    this._logger.trace('Occupancy.current();');\n\n    // CHA-O7c\n    if (!this._roomOptions.occupancy.enableEvents) {\n      throw new Ably.ErrorInfo(\n        'cannot get current occupancy; occupancy events are not enabled in room options',\n        40000,\n        400,\n      ) as unknown as Error;\n    }\n\n    // CHA-07a\n    // CHA-07b\n    return this._latestOccupancyData;\n  }\n\n  /**\n   * An internal listener that listens for occupancy events from the underlying channel and translates them into\n   * occupancy events for the public API.\n   */\n  private _internalOccupancyListener(message: Ably.InboundMessage): void {\n    this._logger.trace('Occupancy._internalOccupancyListener();', message);\n    if (typeof message.data !== 'object') {\n      this._logger.error(\n        'Occupancy._internalOccupancyListener(); invalid occupancy event received; data is not an object',\n        message,\n      );\n      return;\n    }\n\n    const { metrics } = message.data as { metrics?: { connections?: number; presenceMembers?: number } };\n\n    if (metrics === undefined) {\n      this._logger.error(\n        'Occupancy._internalOccupancyListener(); invalid occupancy event received; metrics is missing',\n        message,\n      );\n      return;\n    }\n\n    const { connections, presenceMembers } = metrics;\n\n    if (connections === undefined) {\n      this._logger.error(\n        'Occupancy._internalOccupancyListener(); invalid occupancy event received; connections is missing',\n        message,\n      );\n      return;\n    }\n\n    if (!Number.isInteger(connections)) {\n      this._logger.error(\n        'Occupancy._internalOccupancyListener(); invalid occupancy event received; connections is not a number',\n        message,\n      );\n      return;\n    }\n\n    if (presenceMembers === undefined) {\n      this._logger.error(\n        'Occupancy._internalOccupancyListener(); invalid occupancy event received; presenceMembers is missing',\n        message,\n      );\n      return;\n    }\n\n    if (!Number.isInteger(presenceMembers)) {\n      this._logger.error(\n        'Occupancy._internalOccupancyListener(); invalid occupancy event received; presenceMembers is not a number',\n        message,\n      );\n      return;\n    }\n\n    this._latestOccupancyData = {\n      connections: connections,\n      presenceMembers: presenceMembers,\n    };\n\n    this._emitter.emit(OccupancyEventType.Updated, {\n      type: OccupancyEventType.Updated,\n      occupancy: this._latestOccupancyData,\n    });\n  }\n\n  /**\n   * Merges the channel options for the room with the ones required for occupancy.\n   *\n   * @returns A function that merges the channel options for the room with the ones required for occupancy.\n   */\n  static channelOptionMerger(roomOptions: InternalRoomOptions): ChannelOptionsMerger {\n    return (options) => {\n      // Occupancy not required, so we can skip this.\n      if (!roomOptions.occupancy.enableEvents) {\n        return options;\n      }\n\n      return { ...options, params: { ...options.params, occupancy: 'metrics' } };\n    };\n  }\n}\n","import * as Ably from 'ably';\n\nimport { ChannelOptionsMerger } from './channel-manager.js';\nimport { PresenceEventType } from './events.js';\nimport { Logger } from './logger.js';\nimport { InternalRoomOptions } from './room-options.js';\nimport { Subscription } from './subscription.js';\nimport EventEmitter, { wrap } from './utils/event-emitter.js';\n\n/**\n * Interface for PresenceEventsMap\n */\ninterface PresenceEventsMap {\n  [PresenceEventType.Enter]: PresenceEvent;\n  [PresenceEventType.Leave]: PresenceEvent;\n  [PresenceEventType.Update]: PresenceEvent;\n  [PresenceEventType.Present]: PresenceEvent;\n}\n\n/**\n * Type for PresenceData. Any JSON serializable data type.\n */\nexport type PresenceData = unknown;\n\n/**\n * Type for AblyPresenceData\n */\ninterface AblyPresenceData {\n  userCustomData: PresenceData;\n\n  [key: string]: unknown;\n}\n\n/**\n * Type for PresenceEvent\n */\nexport interface PresenceEvent {\n  /**\n   * The type of the presence event.\n   */\n  type: PresenceEventType;\n\n  /**\n   * The presence member associated with this event.\n   */\n  member: PresenceMember;\n}\n\n/**\n * Type for PresenceMember\n */\nexport interface PresenceMember {\n  /**\n   * The clientId of the presence member.\n   */\n  clientId: string;\n\n  /**\n   * The data associated with the presence member.\n   */\n  data: PresenceData;\n\n  /**\n   * The extras associated with the presence member.\n   */\n  extras: unknown;\n\n  /**\n   * The timestamp of when the last change in state occurred for this presence member.\n   */\n  updatedAt: number;\n}\n\n/**\n * Type for PresenceListener\n * @param event The presence event that was received.\n */\nexport type PresenceListener = (event: PresenceEvent) => void;\n\n/**\n * This interface is used to interact with presence in a chat room: subscribing to presence events,\n * fetching presence members, or sending presence events (join,update,leave).\n *\n * Get an instance via {@link Room.presence}.\n */\nexport interface Presence {\n  /**\n   * Method to get list of the current online users and returns the latest presence messages associated to it.\n   * @param {Ably.RealtimePresenceParams} params - Parameters that control how the presence set is retrieved.\n   * @throws If the room is not in the `attached` or `attaching` state.\n   * @returns {Promise<PresenceMessage[]>} or upon failure, the promise will be rejected with an {@link Ably.ErrorInfo} object which explains the error.\n   */\n  get(params?: Ably.RealtimePresenceParams): Promise<PresenceMember[]>;\n\n  /**\n   * Method to check if user with supplied clientId is online\n   * @param {string} clientId - The client ID to check if it is present in the room.\n   * @throws If the room is not in the `attached` or `attaching` state.\n   * @returns {Promise<{boolean}>} or upon failure, the promise will be rejected with an {@link Ably.ErrorInfo} object which explains the error.\n   */\n  isUserPresent(clientId: string): Promise<boolean>;\n\n  /**\n   * Method to join room presence, will emit an enter event to all subscribers. Repeat calls will trigger more enter events.\n   * @param {PresenceData} data - The users data, a JSON serializable object that will be sent to all subscribers.\n   * @throws If the room is not in the `attached` or `attaching` state.\n   * @returns {Promise<void>} or upon failure, the promise will be rejected with an {@link Ably.ErrorInfo} object which explains the error.\n   */\n  enter(data?: PresenceData): Promise<void>;\n\n  /**\n   * Method to update room presence, will emit an update event to all subscribers. If the user is not present, it will be treated as a join event.\n   * @param {PresenceData} data - The users data, a JSON serializable object that will be sent to all subscribers.\n   * @throws If the room is not in the `attached` or `attaching` state.\n   * @returns {Promise<void>} or upon failure, the promise will be rejected with an {@link Ably.ErrorInfo} object which explains the error.\n   */\n  update(data?: PresenceData): Promise<void>;\n\n  /**\n   * Method to leave room presence, will emit a leave event to all subscribers. If the user is not present, it will be treated as a no-op.\n   * @param {PresenceData} data - The users data, a JSON serializable object that will be sent to all subscribers.\n   * @throws If the room is not in the `attached` or `attaching` state.\n   * @returns {Promise<void>} or upon failure, the promise will be rejected with an {@link Ably.ErrorInfo} object which explains the error.\n   */\n  leave(data?: PresenceData): Promise<void>;\n\n  /**\n   * Subscribe the given listener from the given list of events.\n   *\n   * Note: This requires presence events to be enabled via the `enableEvents` option in\n   * the {@link PresenceOptions} provided to the room. If this is not enabled, an error will be thrown.\n   *\n   * @param eventOrEvents {'enter' | 'leave' | 'update' | 'present'} single event name or array of events to subscribe to\n   * @param listener listener to subscribe\n   * @throws An {@link Ably.ErrorInfo} with code 40000 if presence events are not enabled\n   */\n  subscribe(eventOrEvents: PresenceEventType | PresenceEventType[], listener?: PresenceListener): Subscription;\n\n  /**\n   * Subscribe the given listener to all presence events.\n   *\n   * Note: This requires presence events to be enabled via the `enableEvents` option in\n   * the {@link PresenceOptions} provided to the room. If this is not enabled, an error will be thrown.\n   *\n   * @param listener listener to subscribe\n   * @throws An {@link Ably.ErrorInfo} with code 40000 if presence events are not enabled\n   */\n  subscribe(listener?: PresenceListener): Subscription;\n}\n\n/**\n * @inheritDoc\n */\nexport class DefaultPresence implements Presence {\n  private readonly _channel: Ably.RealtimeChannel;\n  private readonly _clientId: string;\n  private readonly _logger: Logger;\n  private readonly _emitter = new EventEmitter<PresenceEventsMap>();\n  private readonly _options: InternalRoomOptions;\n\n  /**\n   * Constructs a new `DefaultPresence` instance.\n   * @param channel The Realtime channel instance.\n   * @param clientId The client ID, attached to presences messages as an identifier of the sender.\n   * A channel can have multiple connections using the same clientId.\n   * @param logger An instance of the Logger.\n   * @param options The room options.\n   */\n  constructor(channel: Ably.RealtimeChannel, clientId: string, logger: Logger, options: InternalRoomOptions) {\n    this._channel = channel;\n    this._clientId = clientId;\n    this._logger = logger;\n    this._options = options;\n\n    this._applyChannelSubscriptions();\n  }\n\n  /**\n   * Sets up channel subscriptions for presence.\n   */\n  private _applyChannelSubscriptions(): void {\n    // attachOnSubscribe is set to false in the default channel options, so this call cannot fail\n    void this._channel.presence.subscribe(this.subscribeToEvents.bind(this));\n  }\n\n  /**\n   * @inheritDoc\n   */\n  async get(params?: Ably.RealtimePresenceParams): Promise<PresenceMember[]> {\n    this._logger.trace('Presence.get()', { params });\n    this._assertChannelState();\n    const userOnPresence = await this._channel.presence.get(params);\n\n    // ably-js never emits the 'absent' event, so we can safely ignore it here.\n    return userOnPresence.map((user) => ({\n      clientId: user.clientId,\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      data: user.data?.userCustomData as PresenceData,\n      updatedAt: user.timestamp,\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      extras: user.extras,\n    }));\n  }\n\n  /**\n   * @inheritDoc\n   */\n  async isUserPresent(clientId: string): Promise<boolean> {\n    this._logger.trace(`Presence.isUserPresent()`, { clientId });\n    this._assertChannelState();\n    const presenceSet = await this._channel.presence.get({ clientId: clientId });\n    return presenceSet.length > 0;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  async enter(data?: PresenceData): Promise<void> {\n    this._logger.trace(`Presence.enter()`, { data });\n    this._assertChannelState();\n    const presenceEventToSend: AblyPresenceData = {\n      userCustomData: data,\n    };\n    return this._channel.presence.enterClient(this._clientId, presenceEventToSend);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  async update(data?: PresenceData): Promise<void> {\n    this._logger.trace(`Presence.update()`, { data });\n    this._assertChannelState();\n    const presenceEventToSend: AblyPresenceData = {\n      userCustomData: data,\n    };\n    return this._channel.presence.updateClient(this._clientId, presenceEventToSend);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  async leave(data?: PresenceData): Promise<void> {\n    this._logger.trace(`Presence.leave()`, { data });\n    this._assertChannelState();\n    const presenceEventToSend: AblyPresenceData = {\n      userCustomData: data,\n    };\n    return this._channel.presence.leaveClient(this._clientId, presenceEventToSend);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  subscribe(eventOrEvents: PresenceEventType | PresenceEventType[], listener?: PresenceListener): Subscription;\n  /**\n   * @inheritDoc\n   */\n  subscribe(listener?: PresenceListener): Subscription;\n  subscribe(\n    listenerOrEvents?: PresenceEventType | PresenceEventType[] | PresenceListener,\n    listener?: PresenceListener,\n  ): Subscription {\n    this._logger.trace('Presence.subscribe(); listenerOrEvents', { listenerOrEvents });\n\n    // Check if presence events are enabled\n    if (!this._options.presence.enableEvents) {\n      this._logger.error('could not subscribe to presence; presence events are not enabled');\n      throw new Ably.ErrorInfo('could not subscribe to presence; presence events are not enabled', 40000, 400);\n    }\n\n    if (!listenerOrEvents && !listener) {\n      this._logger.error('could not subscribe to presence; invalid arguments');\n      throw new Ably.ErrorInfo('could not subscribe listener: invalid arguments', 40000, 400);\n    }\n\n    // Add listener to all events\n    if (listener) {\n      const wrapped = wrap(listener);\n      this._emitter.on(listenerOrEvents as PresenceEventType, wrapped);\n      return {\n        unsubscribe: () => {\n          this._logger.trace('Presence.unsubscribe();', { events: listenerOrEvents });\n          this._emitter.off(wrapped);\n        },\n      };\n    } else {\n      const wrapped = wrap(listenerOrEvents as PresenceListener);\n      this._emitter.on(wrapped);\n      return {\n        unsubscribe: () => {\n          this._logger.trace('Presence.unsubscribe();');\n          this._emitter.off(wrapped);\n        },\n      };\n    }\n  }\n\n  /**\n   * Method to handle and emit presence events\n   * @param member - PresenceMessage ably-js object\n   * @returns void - Emits a transformed event to all subscribers, or upon failure,\n   * the promise will be rejected with an {@link ErrorInfo} object which explains the error.\n   */\n  subscribeToEvents = (member: Ably.PresenceMessage) => {\n    try {\n      const presenceData = member.data as AblyPresenceData;\n\n      // Ably-js never emits the 'absent' event, so we can safely ignore it here.\n      this._emitter.emit(member.action as PresenceEventType, {\n        type: member.action as PresenceEventType,\n        member: {\n          clientId: member.clientId,\n          data: presenceData.userCustomData,\n          extras: member.extras,\n          updatedAt: member.timestamp,\n        },\n      });\n    } catch (error) {\n      this._logger.error(`unable to handle presence event: not a valid presence event`, { action: member.action });\n      throw new Ably.ErrorInfo(\n        `unable to handle ${member.action} presence event: not a valid presence event`,\n        50000,\n        500,\n        (error as Error).message,\n      );\n    }\n  };\n\n  /**\n   * Merges the channel options for the room with the ones required for presence.\n   *\n   * @param roomOptions The room options to merge for.\n   * @returns A function that merges the channel options for the room with the ones required for presence.\n   */\n  static channelOptionMerger(roomOptions: InternalRoomOptions): ChannelOptionsMerger {\n    return (options) => {\n      // Presence mode is always required\n      if (!options.modes.includes('PRESENCE')) {\n        options.modes.push('PRESENCE');\n      }\n      // If presence events are enabled, add the PRESENCE_SUBSCRIBE mode\n      if (roomOptions.presence.enableEvents && !options.modes.includes('PRESENCE_SUBSCRIBE')) {\n        options.modes.push('PRESENCE_SUBSCRIBE');\n      }\n      return options;\n    };\n  }\n\n  private _assertChannelState(): void {\n    if (this._channel.state !== 'attaching' && this._channel.state !== 'attached') {\n      this._logger.error('could not perform presence operation; room is not attached');\n      throw new Ably.ErrorInfo('could not perform presence operation; room is not attached', 40000, 400);\n    }\n  }\n}\n","const E_TIMEOUT = new Error('timeout while waiting for mutex to become available');\nconst E_ALREADY_LOCKED = new Error('mutex already locked');\nconst E_CANCELED = new Error('request for lock canceled');\n\nvar __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Semaphore {\n    constructor(_value, _cancelError = E_CANCELED) {\n        this._value = _value;\n        this._cancelError = _cancelError;\n        this._queue = [];\n        this._weightedWaiters = [];\n    }\n    acquire(weight = 1, priority = 0) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        return new Promise((resolve, reject) => {\n            const task = { resolve, reject, weight, priority };\n            const i = findIndexFromEnd(this._queue, (other) => priority <= other.priority);\n            if (i === -1 && weight <= this._value) {\n                // Needs immediate dispatch, skip the queue\n                this._dispatchItem(task);\n            }\n            else {\n                this._queue.splice(i + 1, 0, task);\n            }\n        });\n    }\n    runExclusive(callback_1) {\n        return __awaiter$2(this, arguments, void 0, function* (callback, weight = 1, priority = 0) {\n            const [value, release] = yield this.acquire(weight, priority);\n            try {\n                return yield callback(value);\n            }\n            finally {\n                release();\n            }\n        });\n    }\n    waitForUnlock(weight = 1, priority = 0) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        if (this._couldLockImmediately(weight, priority)) {\n            return Promise.resolve();\n        }\n        else {\n            return new Promise((resolve) => {\n                if (!this._weightedWaiters[weight - 1])\n                    this._weightedWaiters[weight - 1] = [];\n                insertSorted(this._weightedWaiters[weight - 1], { resolve, priority });\n            });\n        }\n    }\n    isLocked() {\n        return this._value <= 0;\n    }\n    getValue() {\n        return this._value;\n    }\n    setValue(value) {\n        this._value = value;\n        this._dispatchQueue();\n    }\n    release(weight = 1) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        this._value += weight;\n        this._dispatchQueue();\n    }\n    cancel() {\n        this._queue.forEach((entry) => entry.reject(this._cancelError));\n        this._queue = [];\n    }\n    _dispatchQueue() {\n        this._drainUnlockWaiters();\n        while (this._queue.length > 0 && this._queue[0].weight <= this._value) {\n            this._dispatchItem(this._queue.shift());\n            this._drainUnlockWaiters();\n        }\n    }\n    _dispatchItem(item) {\n        const previousValue = this._value;\n        this._value -= item.weight;\n        item.resolve([previousValue, this._newReleaser(item.weight)]);\n    }\n    _newReleaser(weight) {\n        let called = false;\n        return () => {\n            if (called)\n                return;\n            called = true;\n            this.release(weight);\n        };\n    }\n    _drainUnlockWaiters() {\n        if (this._queue.length === 0) {\n            for (let weight = this._value; weight > 0; weight--) {\n                const waiters = this._weightedWaiters[weight - 1];\n                if (!waiters)\n                    continue;\n                waiters.forEach((waiter) => waiter.resolve());\n                this._weightedWaiters[weight - 1] = [];\n            }\n        }\n        else {\n            const queuedPriority = this._queue[0].priority;\n            for (let weight = this._value; weight > 0; weight--) {\n                const waiters = this._weightedWaiters[weight - 1];\n                if (!waiters)\n                    continue;\n                const i = waiters.findIndex((waiter) => waiter.priority <= queuedPriority);\n                (i === -1 ? waiters : waiters.splice(0, i))\n                    .forEach((waiter => waiter.resolve()));\n            }\n        }\n    }\n    _couldLockImmediately(weight, priority) {\n        return (this._queue.length === 0 || this._queue[0].priority < priority) &&\n            weight <= this._value;\n    }\n}\nfunction insertSorted(a, v) {\n    const i = findIndexFromEnd(a, (other) => v.priority <= other.priority);\n    a.splice(i + 1, 0, v);\n}\nfunction findIndexFromEnd(a, predicate) {\n    for (let i = a.length - 1; i >= 0; i--) {\n        if (predicate(a[i])) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvar __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Mutex {\n    constructor(cancelError) {\n        this._semaphore = new Semaphore(1, cancelError);\n    }\n    acquire() {\n        return __awaiter$1(this, arguments, void 0, function* (priority = 0) {\n            const [, releaser] = yield this._semaphore.acquire(1, priority);\n            return releaser;\n        });\n    }\n    runExclusive(callback, priority = 0) {\n        return this._semaphore.runExclusive(() => callback(), 1, priority);\n    }\n    isLocked() {\n        return this._semaphore.isLocked();\n    }\n    waitForUnlock(priority = 0) {\n        return this._semaphore.waitForUnlock(1, priority);\n    }\n    release() {\n        if (this._semaphore.isLocked())\n            this._semaphore.release();\n    }\n    cancel() {\n        return this._semaphore.cancel();\n    }\n}\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction withTimeout(sync, timeout, timeoutError = E_TIMEOUT) {\n    return {\n        acquire: (weightOrPriority, priority) => {\n            let weight;\n            if (isSemaphore(sync)) {\n                weight = weightOrPriority;\n            }\n            else {\n                weight = undefined;\n                priority = weightOrPriority;\n            }\n            if (weight !== undefined && weight <= 0) {\n                throw new Error(`invalid weight ${weight}: must be positive`);\n            }\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                let isTimeout = false;\n                const handle = setTimeout(() => {\n                    isTimeout = true;\n                    reject(timeoutError);\n                }, timeout);\n                try {\n                    const ticket = yield (isSemaphore(sync)\n                        ? sync.acquire(weight, priority)\n                        : sync.acquire(priority));\n                    if (isTimeout) {\n                        const release = Array.isArray(ticket) ? ticket[1] : ticket;\n                        release();\n                    }\n                    else {\n                        clearTimeout(handle);\n                        resolve(ticket);\n                    }\n                }\n                catch (e) {\n                    if (!isTimeout) {\n                        clearTimeout(handle);\n                        reject(e);\n                    }\n                }\n            }));\n        },\n        runExclusive(callback, weight, priority) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let release = () => undefined;\n                try {\n                    const ticket = yield this.acquire(weight, priority);\n                    if (Array.isArray(ticket)) {\n                        release = ticket[1];\n                        return yield callback(ticket[0]);\n                    }\n                    else {\n                        release = ticket;\n                        return yield callback();\n                    }\n                }\n                finally {\n                    release();\n                }\n            });\n        },\n        release(weight) {\n            sync.release(weight);\n        },\n        cancel() {\n            return sync.cancel();\n        },\n        waitForUnlock: (weightOrPriority, priority) => {\n            let weight;\n            if (isSemaphore(sync)) {\n                weight = weightOrPriority;\n            }\n            else {\n                weight = undefined;\n                priority = weightOrPriority;\n            }\n            if (weight !== undefined && weight <= 0) {\n                throw new Error(`invalid weight ${weight}: must be positive`);\n            }\n            return new Promise((resolve, reject) => {\n                const handle = setTimeout(() => reject(timeoutError), timeout);\n                (isSemaphore(sync)\n                    ? sync.waitForUnlock(weight, priority)\n                    : sync.waitForUnlock(priority)).then(() => {\n                    clearTimeout(handle);\n                    resolve();\n                });\n            });\n        },\n        isLocked: () => sync.isLocked(),\n        getValue: () => sync.getValue(),\n        setValue: (value) => sync.setValue(value),\n    };\n}\nfunction isSemaphore(sync) {\n    return sync.getValue !== undefined;\n}\n\n// eslint-disable-next-lisne @typescript-eslint/explicit-module-boundary-types\nfunction tryAcquire(sync, alreadyAcquiredError = E_ALREADY_LOCKED) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return withTimeout(sync, 0, alreadyAcquiredError);\n}\n\nexport { E_ALREADY_LOCKED, E_CANCELED, E_TIMEOUT, Mutex, Semaphore, tryAcquire, withTimeout };\n","import * as Ably from 'ably';\n\nimport { Logger } from './logger.js';\nimport { StatusSubscription } from './subscription.js';\nimport EventEmitter, { wrap } from './utils/event-emitter.js';\n\n/**\n * The different states that a room can be in throughout its lifecycle.\n */\nexport enum RoomStatus {\n  /**\n   * The library is currently initializing the room. This state is a temporary state used in React prior\n   * to the room being resolved.\n   */\n  Initializing = 'initializing',\n\n  /**\n   * A temporary state for when the room object is first initialized.\n   */\n  Initialized = 'initialized',\n\n  /**\n   * The library is currently attempting to attach the room.\n   */\n  Attaching = 'attaching',\n\n  /**\n   * The room is currently attached and receiving events.\n   */\n  Attached = 'attached',\n\n  /**\n   * The room is currently detaching and will not receive events.\n   */\n  Detaching = 'detaching',\n\n  /**\n   * The room is currently detached and will not receive events.\n   */\n  Detached = 'detached',\n\n  /**\n   * The room is in an extended state of detachment, but will attempt to re-attach when able.\n   */\n  Suspended = 'suspended',\n\n  /**\n   * The room is currently detached and will not attempt to re-attach. User intervention is required.\n   */\n  Failed = 'failed',\n\n  /**\n   * The room is in the process of releasing. Attempting to use a room in this state may result in undefined behavior.\n   */\n  Releasing = 'releasing',\n\n  /**\n   * The room has been released and is no longer usable.\n   */\n  Released = 'released',\n}\n\n/**\n * Represents a change in the status of the room.\n */\nexport interface RoomStatusChange {\n  /**\n   * The new status of the room.\n   */\n  current: RoomStatus;\n\n  /**\n   * The previous status of the room.\n   */\n  previous: RoomStatus;\n\n  /**\n   * An error that provides a reason why the room has\n   * entered the new status, if applicable.\n   */\n  error?: Ably.ErrorInfo;\n}\n\n/**\n * A function that can be called when the room status changes.\n * @param change The change in status.\n */\nexport type RoomStatusListener = (change: RoomStatusChange) => void;\n\n/**\n * Represents the status of a Room.\n */\nexport interface RoomLifecycle {\n  /**\n   * The current status of the room.\n   */\n  get status(): RoomStatus;\n\n  /**\n   * The current error, if any, that caused the room to enter the current status.\n   */\n  get error(): Ably.ErrorInfo | undefined;\n\n  /**\n   * Registers a listener that will be called whenever the room status changes.\n   * @param listener The function to call when the status changes.\n   * @returns An object that can be used to unregister the listener.\n   */\n  onChange(listener: RoomStatusListener): StatusSubscription;\n}\n\n/**\n * An internal interface for the status of a room, which can be used to separate critical\n * internal functionality from user listeners.\n * @internal\n */\nexport interface InternalRoomLifecycle extends RoomLifecycle {\n  /**\n   * Sets the status of the room.\n   *\n   * @param params The new status of the room.\n   */\n  setStatus(params: NewRoomStatus): void;\n}\n\n/**\n * A new room status that can be set.\n */\nexport interface NewRoomStatus {\n  /**\n   * The new status of the room.\n   */\n  status: RoomStatus;\n\n  /**\n   * An error that provides a reason why the room has\n   * entered the new status, if applicable.\n   */\n  error?: Ably.ErrorInfo;\n}\n\ntype RoomStatusEventsMap = Record<RoomStatus, RoomStatusChange>;\n\n/**\n * An implementation of the `Status` interface.\n * @internal\n */\nexport class DefaultRoomLifecycle implements InternalRoomLifecycle {\n  private _status: RoomStatus = RoomStatus.Initialized;\n  private _error?: Ably.ErrorInfo;\n  private readonly _logger: Logger;\n  private readonly _internalEmitter = new EventEmitter<RoomStatusEventsMap>();\n  private readonly _emitter = new EventEmitter<RoomStatusEventsMap>();\n\n  /**\n   * Constructs a new DefaultRoomLifecycle instance.\n   * @param logger An instance of the Logger.\n   */\n  constructor(logger: Logger) {\n    this._logger = logger;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get status(): RoomStatus {\n    return this._status;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get error(): Ably.ErrorInfo | undefined {\n    return this._error;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  onChange(listener: RoomStatusListener): StatusSubscription {\n    const wrapped = wrap(listener);\n    this._emitter.on(wrapped);\n\n    return {\n      off: () => {\n        this._emitter.off(wrapped);\n      },\n    };\n  }\n\n  setStatus(params: NewRoomStatus): void {\n    const change: RoomStatusChange = {\n      current: params.status,\n      error: params.error,\n      previous: this._status,\n    };\n\n    this._status = change.current;\n    this._error = change.error;\n    this._logger.info(`room status changed`, { ...change });\n    this._internalEmitter.emit(change.current, change);\n    this._emitter.emit(change.current, change);\n  }\n}\n","import * as Ably from 'ably';\nimport { Mutex } from 'async-mutex';\n\nimport { ChannelManager } from './channel-manager.js';\nimport { DiscontinuityListener } from './discontinuity.js';\nimport { ErrorCode } from './errors.js';\nimport { RoomEventType } from './events.js';\nimport { Logger } from './logger.js';\nimport { InternalRoomLifecycle, RoomStatus } from './room-status.js';\nimport { StatusSubscription } from './subscription.js';\nimport EventEmitter, { wrap } from './utils/event-emitter.js';\n\n/**\n * Events that can be emitted by the RoomLifecycleManager\n */\nexport interface RoomLifeCycleEvents {\n  [RoomEventType.Discontinuity]: Ably.ErrorInfo;\n}\n\n/**\n * Priority levels for operations, lower numbers are higher priority\n */\nenum OperationPriority {\n  Release = 0,\n  AttachDetach = 1,\n}\n\n/**\n * Manages the lifecycle of a room's underlying channel, handling attach, detach and release operations\n * while maintaining the room's status.\n */\nexport class RoomLifecycleManager {\n  private readonly _channelManager: ChannelManager;\n  private readonly _roomLifecycle: InternalRoomLifecycle;\n  private readonly _logger: Logger;\n  private readonly _eventEmitter: EventEmitter<RoomLifeCycleEvents>;\n  private _hasAttachedOnce: boolean; // CHA-RL13\n  private _isExplicitlyDetached: boolean; // CHA-RL14\n  private readonly _mutex: Mutex; // CHA-RL7\n\n  constructor(channelManager: ChannelManager, roomLifecycle: InternalRoomLifecycle, logger: Logger) {\n    this._channelManager = channelManager;\n    this._roomLifecycle = roomLifecycle;\n    this._logger = logger;\n    this._eventEmitter = new EventEmitter();\n    this._hasAttachedOnce = false; // CHA-RL13\n    this._isExplicitlyDetached = false; // CHA-RL14\n    this._mutex = new Mutex(); // CHA-RL7\n\n    // Start monitoring channel state changes\n    this._startMonitoringChannelState();\n    this._startMonitoringDiscontinuity();\n  }\n\n  /**\n   * Sets up monitoring of channel state changes to keep room status in sync.\n   * If an operation is in progress (attach/detach/release), state changes are ignored.\n   * @private\n   */\n  private _startMonitoringChannelState(): void {\n    const channel = this._channelManager.get();\n\n    // CHA-RL11a\n    channel.on((stateChange: Ably.ChannelStateChange) => {\n      this._logger.debug('RoomLifecycleManager.channel state changed', {\n        oldState: stateChange.previous,\n        newState: stateChange.current,\n        reason: stateChange.reason,\n        resumed: stateChange.resumed,\n      });\n\n      // CHA-RL11b\n      if (this._operationInProgress()) {\n        this._logger.debug(\n          'RoomLifecycleManager._startMonitoringChannelState(); ignoring channel state change - operation in progress',\n          {\n            status: this._roomLifecycle.status,\n          },\n        );\n        return;\n      }\n\n      // CHA-RL11c\n      const newStatus = this._mapChannelStateToRoomStatus(stateChange.current);\n      this._setStatus(newStatus, stateChange.reason);\n    });\n  }\n\n  /**\n   * Sets up monitoring for channel discontinuities.\n   * A discontinuity exists when an attached or update event comes from the channel with resume=false.\n   * The first time we attach, or if we attach after an explicit detach call are not considered discontinuities.\n   * @private\n   */\n  private _startMonitoringDiscontinuity(): void {\n    const channel = this._channelManager.get();\n\n    // CHA-RL12a, CHA-RL12b\n    channel.on('attached', (stateChange: Ably.ChannelStateChange) => {\n      if (!stateChange.resumed && this._hasAttachedOnce && !this._isExplicitlyDetached) {\n        const error = new Ably.ErrorInfo(\n          'discontinuity detected',\n          ErrorCode.RoomDiscontinuity,\n          stateChange.reason?.statusCode ?? 0,\n          stateChange.reason,\n        );\n\n        this._logger.warn('RoomLifecycleManager._startMonitoringDiscontinuity(); discontinuity detected', {\n          error,\n        });\n        this._eventEmitter.emit(RoomEventType.Discontinuity, error);\n      }\n    });\n\n    // CHA-RL12a, CHA-RL12b\n    channel.on('update', (stateChange: Ably.ChannelStateChange) => {\n      if (\n        !stateChange.resumed &&\n        this._hasAttachedOnce &&\n        !this._isExplicitlyDetached &&\n        stateChange.current === 'attached' &&\n        stateChange.previous === 'attached'\n      ) {\n        const error = new Ably.ErrorInfo(\n          'discontinuity detected',\n          ErrorCode.RoomDiscontinuity,\n          stateChange.reason?.statusCode ?? 0,\n          stateChange.reason,\n        );\n\n        this._logger.warn('RoomLifecycleManager._startMonitoringDiscontinuity(); discontinuity detected', {\n          error,\n        });\n        this._eventEmitter.emit(RoomEventType.Discontinuity, error);\n      }\n    });\n  }\n\n  /**\n   * Registers a handler for discontinuity events.\n   * @param handler The function to be called when a discontinuity is detected\n   * @returns An object with an off() method to deregister the handler\n   */\n  onDiscontinuity(handler: DiscontinuityListener): StatusSubscription {\n    this._logger.trace('RoomLifecycleManager.onDiscontinuity()');\n    const wrapped = wrap(handler);\n    this._eventEmitter.on(RoomEventType.Discontinuity, wrapped);\n    return {\n      off: () => {\n        this._eventEmitter.off(RoomEventType.Discontinuity, wrapped);\n      },\n    };\n  }\n\n  /**\n   * Attaches to the channel and updates room status accordingly.\n   * If the room is released/releasing, this operation fails.\n   * If already attached, this is a no-op.\n   */\n  async attach(): Promise<void> {\n    // CHA-RL1d, CHA-RL7a\n    await this._mutex.runExclusive(async () => {\n      this._logger.trace('RoomLifecycleManager.attach();');\n\n      // CHA-RL1b, CHA-RL1c\n      this._checkRoomNotReleasing('attach');\n\n      // CHA-RL1a\n      if (this._roomStatusIs(RoomStatus.Attached)) {\n        this._logger.debug('RoomLifecycleManager.attach(); room already attached, no-op');\n        return;\n      }\n\n      const channel = this._channelManager.get();\n      this._logger.debug('RoomLifecycleManager.attach(); attaching room', {\n        channelState: channel.state,\n      });\n\n      try {\n        // CHA-RL1e\n        this._setStatus(RoomStatus.Attaching);\n        // CHA-RL1k\n        await channel.attach();\n        this._setStatus(RoomStatus.Attached);\n        this._isExplicitlyDetached = false;\n        this._hasAttachedOnce = true;\n        this._logger.debug('RoomLifecycleManager.attach(); room attached successfully');\n      } catch (error) {\n        const errInfo = error as Ably.ErrorInfo;\n        const attachError = new Ably.ErrorInfo(\n          `failed to attach room: ${errInfo.message}`,\n          errInfo.code,\n          errInfo.statusCode,\n          errInfo,\n        );\n\n        const newStatus = this._mapChannelStateToRoomStatus(channel.state);\n        this._setStatus(newStatus, attachError);\n        throw attachError;\n      }\n    }, OperationPriority.AttachDetach);\n  }\n\n  /**\n   * Detaches from the channel and updates room status accordingly.\n   * If the room is released/releasing, this operation fails.\n   * If already detached, this is a no-op.\n   */\n  async detach(): Promise<void> {\n    // CHA-RL2i, CHA-RL7a\n    await this._mutex.runExclusive(async () => {\n      this._logger.trace('RoomLifecycleManager.detach();');\n\n      // CHA-RL2d\n      if (this._roomStatusIs(RoomStatus.Failed)) {\n        throw new Ably.ErrorInfo('cannot detach room, room is in failed state', ErrorCode.RoomInFailedState, 400);\n      }\n\n      // CHA-RL2b, CHA-RL2c\n      this._checkRoomNotReleasing('detach');\n\n      // CHA-RL2a\n      if (this._roomStatusIs(RoomStatus.Detached)) {\n        this._logger.debug('RoomLifecycleManager.detach(); room already detached, no-op');\n        return;\n      }\n\n      const channel = this._channelManager.get();\n      this._logger.debug('RoomLifecycleManager.detach(); detaching room', {\n        channelState: channel.state,\n      });\n\n      try {\n        // CHA-RL2j\n        this._setStatus(RoomStatus.Detaching);\n        // CHA-RL2k\n        await channel.detach();\n        this._isExplicitlyDetached = true;\n        this._setStatus(RoomStatus.Detached);\n        this._logger.debug('RoomLifecycleManager.detach(); room detached successfully');\n      } catch (error) {\n        const errInfo = error as Ably.ErrorInfo;\n        const detachError = new Ably.ErrorInfo(\n          `failed to detach room: ${errInfo.message}`,\n          errInfo.code,\n          errInfo.statusCode,\n          errInfo,\n        );\n\n        const newStatus = this._mapChannelStateToRoomStatus(channel.state);\n        this._setStatus(newStatus, detachError);\n        throw detachError;\n      }\n    }, OperationPriority.AttachDetach);\n  }\n\n  /**\n   * Releases the room by detaching the channel and releasing it from the channel manager.\n   * If the channel is in a failed state, skips the detach operation.\n   * Will retry detach until successful unless in failed state.\n   */\n  async release(): Promise<void> {\n    // CHA-RL3k, CHA-RL7a\n    await this._mutex.runExclusive(async () => {\n      this._logger.trace('RoomLifecycleManager.release();');\n\n      // CHA-RL3a\n      if (this._roomStatusIs(RoomStatus.Released)) {\n        this._logger.debug('RoomLifecycleManager.release(); room already released, no-op');\n        return;\n      }\n\n      // CHA-RL3b, CHA-RL3j\n      if (this._roomStatusIs(RoomStatus.Initialized) || this._roomStatusIs(RoomStatus.Detached)) {\n        this._logger.debug('RoomLifecycleManager.release(); room is initialized or detached, releasing immediately', {\n          status: this._roomLifecycle.status,\n        });\n        this._releaseChannel();\n        return;\n      }\n\n      // CHA-RL3m\n      this._setStatus(RoomStatus.Releasing);\n      const channel = this._channelManager.get();\n\n      // CHA-RL3n\n      this._logger.debug('RoomLifecycleManager.release(); attempting channel detach before release', {\n        channelState: channel.state,\n      });\n      await this._channelDetachLoop(channel);\n\n      // CHA-RL3o, CHA-RL3h\n      this._releaseChannel();\n    }, OperationPriority.Release);\n  }\n\n  /**\n   * Maps an Ably channel state to a room status\n   */\n  private _mapChannelStateToRoomStatus(channelState: Ably.ChannelState): RoomStatus {\n    switch (channelState) {\n      case 'initialized': {\n        return RoomStatus.Initialized;\n      }\n      case 'attaching': {\n        return RoomStatus.Attaching;\n      }\n      case 'attached': {\n        return RoomStatus.Attached;\n      }\n      case 'detaching': {\n        return RoomStatus.Detaching;\n      }\n      case 'detached': {\n        return RoomStatus.Detached;\n      }\n      case 'suspended': {\n        return RoomStatus.Suspended;\n      }\n      case 'failed': {\n        return RoomStatus.Failed;\n      }\n      default: {\n        this._logger.error('RoomLifecycleManager._mapChannelStateToRoomStatus(); unknown channel state', {\n          channelState,\n        });\n        return RoomStatus.Failed;\n      }\n    }\n  }\n\n  private _checkRoomNotReleasing(op: string) {\n    switch (this._roomLifecycle.status) {\n      case RoomStatus.Released: {\n        throw new Ably.ErrorInfo(`cannot ${op} room, room is released`, ErrorCode.RoomIsReleased, 400);\n      }\n      case RoomStatus.Releasing: {\n        throw new Ably.ErrorInfo(`cannot ${op} room, room is currently releasing`, ErrorCode.RoomIsReleasing, 400);\n      }\n    }\n  }\n\n  private _roomStatusIs(status: RoomStatus) {\n    return this._roomLifecycle.status === status;\n  }\n\n  private async _channelDetachLoop(channel: Ably.RealtimeChannel) {\n    for (;;) {\n      // If channel is now failed, we can stop trying to detach\n      const currentState: Ably.ChannelState = channel.state;\n      if (currentState === 'failed') {\n        this._logger.debug('RoomLifecycleManager._channelDetachLoop(); channel is failed, skipping detach');\n        break;\n      }\n\n      try {\n        await channel.detach();\n        break;\n      } catch (error) {\n        // keep trying\n        this._logger.error('RoomLifecycleManager._channelDetachLoop(); failed to detach channel during release', {\n          error,\n        });\n        await new Promise((resolve) => setTimeout(resolve, 250)); // Wait 250ms before retry\n      }\n    }\n  }\n\n  private _setStatus(status: RoomStatus, error?: Ably.ErrorInfo) {\n    this._logger.debug('RoomLifecycleManager._setStatus(); updating room status', {\n      oldStatus: this._roomLifecycle.status,\n      newStatus: status,\n      hasError: !!error,\n    });\n    this._roomLifecycle.setStatus({ status, error });\n  }\n\n  private _releaseChannel() {\n    this._channelManager.release();\n    this._setStatus(RoomStatus.Released);\n    this._logger.debug('RoomLifecycleManager._releaseChannel(); room released successfully');\n  }\n\n  /**\n   * Returns whether there is currently an operation (attach/detach/release) in progress\n   * @private\n   */\n  private _operationInProgress(): boolean {\n    return this._mutex.isLocked();\n  }\n\n  testForceHasAttachedOnce(firstAttach: boolean) {\n    this._hasAttachedOnce = firstAttach;\n  }\n}\n","import * as Ably from 'ably';\n\nimport { MessageReactionType } from './events.js';\n\n/**\n * The default values for RoomOptions.\n */\nconst DefaultRoomOptions: Omit<InternalRoomOptions, 'isReactClient'> = {\n  /**\n   * The default typing options for a chat room.\n   */\n  typing: {\n    /**\n     * The default time that a client will wait between sending one typing heartbeat and the next.\n     *\n     * Spec: CHA-T10.\n     */\n    heartbeatThrottleMs: 10000,\n  },\n\n  /**\n   * The default occupancy options for a chat room.\n   */\n  occupancy: {\n    /**\n     * Whether to enable occupancy events.\n     */\n    enableEvents: false,\n  },\n\n  /**\n   * The default presence options for the room.\n   */\n  presence: {\n    enableEvents: true,\n  },\n\n  /**\n   * The default options for messages.\n   */\n  messages: {\n    rawMessageReactions: false,\n    defaultMessageReactionType: MessageReactionType.Distinct,\n  },\n};\n\n/**\n * Represents the message options for a chat room.\n */\nexport interface MessageOptions {\n  /**\n   * Whether to enable receiving raw individual message reactions from the\n   * realtime channel. Set to true if subscribing to raw message reactions.\n   *\n   * Note reaction summaries (aggregates) are always available regardless of\n   * this setting.\n   *\n   * @defaultValue false\n   */\n  rawMessageReactions?: boolean;\n\n  /**\n   * The default message reaction type to use for sending message reactions.\n   *\n   * Any message reaction type can be sent regardless of this setting by specifying the `type` parameter\n   * in the {@link MessagesReactions.send} method.\n   *\n   * @defaultValue {@link MessageReactionType.Distinct}\n   */\n  defaultMessageReactionType?: MessageReactionType;\n}\n\n/**\n * Represents the typing options for a chat room.\n */\nexport interface TypingOptions {\n  /**\n   * A throttle, in milliseconds, that enforces the minimum time interval between consecutive `typing.started`\n   * events sent by the client to the server.\n   * If typing.start() is called, the first call will emit an event immediately.\n   * Later calls will no-op until the time has elapsed.\n   * Calling typing.stop() will immediately send a `typing.stopped` event to the server and reset the interval,\n   * allowing the client to send another `typing.started` event immediately.\n   * @defaultValue 10000\n   */\n  heartbeatThrottleMs?: number;\n}\n\n/**\n * Represents the occupancy options for a chat room.\n */\nexport interface OccupancyOptions {\n  /**\n   * Whether to enable occupancy events.\n   *\n   * Note that enabling this feature will increase the number of messages received by the client as additional\n   * messages will be sent by the server to indicate occupancy changes.\n   *\n   * @defaultValue false\n   */\n  enableEvents?: boolean;\n}\n\n/**\n * Represents the presence options for a chat room.\n */\nexport interface PresenceOptions {\n  /**\n   * Whether or not the client should receive presence events from the server. This setting\n   * can be disabled if you are using presence in your Chat Room, but this particular client does not\n   * need to receive the messages.\n   *\n   * @defaultValue true\n   */\n  enableEvents?: boolean;\n}\n\n/**\n * Represents the options for a given chat room.\n */\nexport interface RoomOptions {\n  /**\n   * The typing options for the room.\n   */\n  typing?: TypingOptions;\n\n  /**\n   * The occupancy options for the room.\n   */\n  occupancy?: OccupancyOptions;\n\n  /**\n   * The presence options for the room.\n   */\n  presence?: PresenceOptions;\n\n  /**\n   * The message options for the room.\n   */\n  messages?: MessageOptions;\n}\n\n/**\n * Represents the normalized typing options for a chat room, which makes every property required.\n */\nexport type InternalTypingOptions = Required<TypingOptions>;\n\n/**\n * Represents the normalized occupancy options for a chat room. Everything becomes required.\n */\nexport type InternalOccupancyOptions = Required<OccupancyOptions>;\n\n/**\n * Represents the normalized presence options for a chat room. Everything becomes required.\n */\nexport type InternalPresenceOptions = Required<PresenceOptions>;\n\n/**\n * Represents the normalized message options for a chat room. Everything becomes required.\n */\nexport type InternalMessageOptions = Required<MessageOptions>;\n\n/**\n * Represents the normalized options for a chat room.\n */\nexport interface InternalRoomOptions {\n  /**\n   * Are we running the client in a React environment?\n   */\n  isReactClient: boolean;\n\n  /**\n   * Typing options with everything made mandatory.\n   */\n  typing: InternalTypingOptions;\n\n  /**\n   * Occupancy options with everything made mandatory.\n   */\n  occupancy: InternalOccupancyOptions;\n\n  /**\n   * Presence options with everything made mandatory.\n   */\n  presence: InternalPresenceOptions;\n\n  /**\n   * Message options with everything made mandatory.\n   */\n  messages: InternalMessageOptions;\n}\n\n/**\n * Creates an {@link ErrorInfo} for invalid room configuration.\n *\n * @param reason The reason for the invalid room configuration.\n * @returns An ErrorInfo.\n */\nconst invalidRoomConfiguration = (reason: string): Error =>\n  new Ably.ErrorInfo(`invalid room configuration: ${reason}`, 40001, 400);\n\nexport const validateRoomOptions = (options: InternalRoomOptions): void => {\n  validateTypingOptions(options.typing);\n};\n\nconst validateTypingOptions = (options: InternalTypingOptions): void => {\n  if (options.heartbeatThrottleMs <= 0) {\n    throw invalidRoomConfiguration('typing heartbeat interval must be greater than 0');\n  }\n};\n\nconst normalizeTypingOptions = (options: RoomOptions | undefined): InternalTypingOptions => {\n  return {\n    ...DefaultRoomOptions.typing,\n    ...options?.typing,\n  };\n};\n\nconst normalizeOccupancyOptions = (options: RoomOptions | undefined): InternalOccupancyOptions => {\n  return {\n    ...DefaultRoomOptions.occupancy,\n    ...options?.occupancy,\n  };\n};\n\nconst normalizePresenceOptions = (options: RoomOptions | undefined): InternalPresenceOptions => {\n  return {\n    ...DefaultRoomOptions.presence,\n    ...options?.presence,\n  };\n};\n\nconst normalizeMessageOptions = (options: RoomOptions | undefined): InternalMessageOptions => {\n  return {\n    ...DefaultRoomOptions.messages,\n    ...options?.messages,\n  };\n};\n\nexport const normalizeRoomOptions = (options: RoomOptions | undefined, react: boolean): InternalRoomOptions => {\n  return {\n    typing: normalizeTypingOptions(options),\n    occupancy: normalizeOccupancyOptions(options),\n    presence: normalizePresenceOptions(options),\n    messages: normalizeMessageOptions(options),\n    isReactClient: react,\n  };\n};\n","import * as Ably from 'ably';\n\n/**\n * Convenience function that takes an event name and optional data and turns it into a\n * message that the server will recognize as ephemeral.\n *\n * @param name The name of the event.\n * @param data Optional data to send with the event.\n * @returns An Ably message.\n */\nexport const ephemeralMessage = (name: string, data?: unknown): Ably.Message => {\n  return {\n    name: name,\n    data: data,\n    extras: {\n      ephemeral: true,\n    },\n  };\n};\n\n/**\n * Takes an existing Ably message and converts it to an ephemeral message by adding\n * the ephemeral flag in the extras field.\n *\n * @param message The Ably message to convert.\n * @returns A new Ably message with the ephemeral flag set.\n */\nexport const messageToEphemeral = (message: Ably.Message): Ably.Message => {\n  const extras = message.extras ? (message.extras as object) : {};\n\n  return {\n    ...message,\n    extras: {\n      ...extras,\n      ephemeral: true,\n    },\n  };\n};\n","import { Headers } from './headers.js';\nimport { Metadata } from './metadata.js';\n\n/**\n * {@link Headers} type for chat messages.\n */\nexport type RoomReactionHeaders = Headers;\n\n/**\n * {@link Metadata} type for chat messages.\n */\nexport type RoomReactionMetadata = Metadata;\n\n/**\n * Represents a room-level reaction.\n */\nexport interface RoomReaction {\n  /**\n   * The name of the reaction, for example \"like\" or \"love\".\n   */\n  readonly name: string;\n\n  /**\n   * Metadata of the reaction. If no metadata was set this is an empty object.\n   */\n  readonly metadata: RoomReactionMetadata;\n\n  /**\n   * Headers of the reaction. If no headers were set this is an empty object.\n   */\n  readonly headers: RoomReactionHeaders;\n\n  /**\n   * The timestamp at which the reaction was sent.\n   */\n  readonly createdAt: Date;\n\n  /**\n   * The clientId of the user who sent the reaction.\n   */\n  readonly clientId: string;\n\n  /**\n   * Whether the reaction was sent by the current user.\n   */\n  readonly isSelf: boolean;\n}\n\n/**\n * An implementation of the RoomReaction interface for room-level reactions.\n */\nexport class DefaultRoomReaction implements RoomReaction {\n  constructor(\n    public readonly name: string,\n    public readonly clientId: string,\n    public readonly createdAt: Date,\n    public readonly isSelf: boolean,\n    public readonly metadata: RoomReactionMetadata,\n    public readonly headers: RoomReactionHeaders,\n  ) {\n    // The object is frozen after constructing to enforce readonly at runtime too\n    Object.freeze(this);\n  }\n}\n","import * as Ably from 'ably';\n\nimport { DefaultRoomReaction, RoomReaction, RoomReactionHeaders, RoomReactionMetadata } from './room-reaction.js';\n\ninterface ReactionPayload {\n  data?: {\n    name?: string;\n    metadata?: RoomReactionMetadata;\n  };\n  clientId?: string;\n  timestamp: number;\n  extras?: {\n    headers?: RoomReactionHeaders;\n  };\n}\n\nexport function parseRoomReaction(message: Ably.InboundMessage, clientId?: string): RoomReaction {\n  const reactionCreatedMessage = message as ReactionPayload;\n  if (!reactionCreatedMessage.data) {\n    throw new Ably.ErrorInfo(`received incoming room reaction message without data`, 50000, 500);\n  }\n\n  if (!reactionCreatedMessage.data.name || typeof reactionCreatedMessage.data.name !== 'string') {\n    throw new Ably.ErrorInfo('invalid room reaction message with no name', 50000, 500);\n  }\n\n  if (!reactionCreatedMessage.clientId) {\n    throw new Ably.ErrorInfo(`received incoming room reaction message without clientId`, 50000, 500);\n  }\n\n  if (!reactionCreatedMessage.timestamp) {\n    throw new Ably.ErrorInfo(`received incoming room reaction message without timestamp`, 50000, 500);\n  }\n\n  return new DefaultRoomReaction(\n    reactionCreatedMessage.data.name,\n    reactionCreatedMessage.clientId,\n    new Date(reactionCreatedMessage.timestamp),\n    clientId ? clientId === reactionCreatedMessage.clientId : false,\n    reactionCreatedMessage.data.metadata ?? {},\n    reactionCreatedMessage.extras?.headers ?? {},\n  );\n}\n","import * as Ably from 'ably';\n\nimport { RoomReactionEvent, RoomReactionEventType, RoomReactionRealtimeEventType } from './events.js';\nimport { Logger } from './logger.js';\nimport { messageToEphemeral } from './realtime.js';\nimport { RoomReaction, RoomReactionHeaders, RoomReactionMetadata } from './room-reaction.js';\nimport { parseRoomReaction } from './room-reaction-parser.js';\nimport { Subscription } from './subscription.js';\nimport EventEmitter, { wrap } from './utils/event-emitter.js';\n\n/**\n * Params for sending a room-level reactions. Only `name` is mandatory.\n */\nexport interface SendReactionParams {\n  /**\n   * The name of the reaction, for example an emoji or a short string such as\n   * \"like\".\n   *\n   * It is the only mandatory parameter to send a room-level reaction.\n   */\n  name: string;\n\n  /**\n   * Optional metadata of the reaction.\n   *\n   * The metadata is a map of extra information that can be attached to the\n   * room reaction. It is not used by Ably and is sent as part of the realtime\n   * message payload. Example use cases are custom animations or other effects.\n   *\n   * Do not use metadata for authoritative information. There is no server-side\n   * validation. When reading the metadata treat it like user input.\n   *\n   */\n  metadata?: RoomReactionMetadata;\n\n  /**\n   * Optional headers of the room reaction.\n   *\n   * The headers are a flat key-value map and are sent as part of the realtime\n   * message's `extras` inside the `headers` property. They can serve similar\n   * purposes as the metadata but they are read by Ably and can be used for\n   * features such as\n   * [subscription filters](https://faqs.ably.com/subscription-filters).\n   *\n   * Do not use the headers for authoritative information. There is no\n   * server-side validation. When reading the headers treat them like user\n   * input.\n   *\n   */\n  headers?: RoomReactionHeaders;\n}\n\n/**\n * The listener function type for room-level reactions.\n *\n * @param event The reaction event that was received.\n */\nexport type RoomReactionListener = (event: RoomReactionEvent) => void;\n\n/**\n * This interface is used to interact with room-level reactions in a chat room: subscribing to reactions and sending them.\n *\n * Get an instance via {@link Room.reactions}.\n */\nexport interface RoomReactions {\n  /**\n   * Send a reaction to the room including some metadata.\n   *\n   * This method accepts parameters for a room-level reaction. It accepts an object\n   *\n   * @param params an object containing {name, headers, metadata} for the room\n   * reaction to be sent. Name is required, metadata and headers are optional.\n   * @throws If the `Connection` is not in the `Connected` state.\n   * @returns The returned promise resolves when the reaction was sent. Note\n   * that it is possible to receive your own reaction via the reactions\n   * listener before this promise resolves.\n   */\n  send(params: SendReactionParams): Promise<void>;\n\n  /**\n   * Subscribe to receive room-level reactions.\n   *\n   * @param listener The listener function to be called when a reaction is received.\n   * @returns A response object that allows you to control the subscription.\n   */\n  subscribe(listener: RoomReactionListener): Subscription;\n}\n\ninterface RoomReactionEventsMap {\n  [RoomReactionEventType.Reaction]: RoomReactionEvent;\n}\n\ninterface ReactionPayload {\n  name: string;\n  metadata?: RoomReactionMetadata;\n}\n\n/**\n * @inheritDoc\n */\nexport class DefaultRoomReactions implements RoomReactions {\n  private readonly _channel: Ably.RealtimeChannel;\n  private readonly _connection: Ably.Connection;\n  private readonly _clientId: string;\n  private readonly _logger: Logger;\n  private readonly _emitter = new EventEmitter<RoomReactionEventsMap>();\n\n  /**\n   * Constructs a new `DefaultRoomReactions` instance.\n   * @param channel The Realtime channel instance.\n   * @param connection The connection instance.\n   * @param clientId The client ID of the user.\n   * @param logger An instance of the Logger.\n   */\n  constructor(channel: Ably.RealtimeChannel, connection: Ably.Connection, clientId: string, logger: Logger) {\n    this._channel = channel;\n    this._connection = connection;\n    this._clientId = clientId;\n    this._logger = logger;\n\n    this._applyChannelSubscriptions();\n  }\n\n  /**\n   * Sets up channel subscriptions for room reactions.\n   */\n  private _applyChannelSubscriptions(): void {\n    // attachOnSubscribe is set to false in the default channel options, so this call cannot fail\n    void this._channel.subscribe([RoomReactionRealtimeEventType.Reaction], this._forwarder.bind(this));\n  }\n\n  /**\n   * @inheritDoc Reactions\n   */\n  send(params: SendReactionParams): Promise<void> {\n    this._logger.trace('RoomReactions.send();', params);\n\n    const { name, metadata, headers } = params;\n\n    if (!name) {\n      return Promise.reject(new Ably.ErrorInfo('unable to send reaction; name not set and it is required', 40001, 400));\n    }\n\n    // CHA-ER3f\n    if (this._connection.state !== 'connected') {\n      return Promise.reject(new Ably.ErrorInfo('unable to send reaction; not connected to Ably', 40000, 400));\n    }\n\n    const payload: ReactionPayload = {\n      name: name,\n      metadata: metadata ?? {},\n    };\n\n    const realtimeMessage: Ably.Message = {\n      name: RoomReactionRealtimeEventType.Reaction,\n      data: payload,\n      extras: {\n        headers: headers ?? {},\n      },\n    };\n\n    return this._channel.publish(messageToEphemeral(realtimeMessage));\n  }\n\n  /**\n   * @inheritDoc Reactions\n   */\n  subscribe(listener: RoomReactionListener): Subscription {\n    this._logger.trace(`RoomReactions.subscribe();`);\n    const wrapped = wrap(listener);\n    this._emitter.on(wrapped);\n\n    return {\n      unsubscribe: () => {\n        this._logger.trace('RoomReactions.unsubscribe();');\n        this._emitter.off(wrapped);\n      },\n    };\n  }\n\n  // parses reactions from realtime channel into Reaction objects and forwards them to the EventEmitter\n  private _forwarder = (inbound: Ably.InboundMessage) => {\n    const reaction = this._parseNewReaction(inbound, this._clientId);\n    if (!reaction) {\n      // ignore non-reactions\n      return;\n    }\n    this._emitter.emit(RoomReactionEventType.Reaction, {\n      type: RoomReactionEventType.Reaction,\n      reaction,\n    });\n  };\n\n  private _parseNewReaction(inbound: Ably.InboundMessage, clientId: string): RoomReaction | undefined {\n    try {\n      return parseRoomReaction(inbound, clientId);\n    } catch (error: unknown) {\n      this._logger.error(`failed to parse incoming reaction;`, {\n        inbound,\n        error: error as Ably.ErrorInfo,\n      });\n    }\n  }\n}\n","import * as Ably from 'ably';\nimport { E_CANCELED, Mutex } from 'async-mutex';\n\nimport { TypingEventType, TypingSetEvent, TypingSetEventType } from './events.js';\nimport { Logger } from './logger.js';\nimport { ephemeralMessage } from './realtime.js';\nimport { InternalTypingOptions } from './room-options.js';\nimport { Subscription } from './subscription.js';\nimport EventEmitter, { wrap } from './utils/event-emitter.js';\n\n/**\n * This interface is used to interact with typing in a chat room including subscribing to typing events and\n * fetching the current set of typing clients.\n *\n * Get an instance via {@link Room.typing}.\n */\nexport interface Typing {\n  /**\n   * Subscribe a given listener to all typing events from users in the chat room.\n   *\n   * @param listener A listener to be called when the typing state of a user in the room changes.\n   * @returns A response object that allows you to control the subscription to typing events.\n   */\n  subscribe(listener: TypingListener): Subscription;\n\n  /**\n   * Get the current typers, a set of clientIds.\n   * @returns The set of clientIds that are currently typing.\n   */\n  current(): Set<string>;\n\n  /**\n   * This will send a `typing.started` event to the server.\n   * Events are throttled according to the `heartbeatThrottleMs` room option.\n   * If an event has been sent within the interval, this operation is no-op.\n   *\n   *\n   * Calls to `keystroke()` and `stop()` are serialized and will always resolve in the correct order.\n   * - For example, if multiple `keystroke()` calls are made in quick succession before the first `keystroke()` call has\n   *   sent a `typing.started` event to the server, followed by one `stop()` call, the `stop()` call will execute\n   *   as soon as the first `keystroke()` call completes.\n   *   All intermediate `keystroke()` calls will be treated as no-ops.\n   * - The most recent operation (`keystroke()` or `stop()`) will always determine the final state, ensuring operations\n   *   resolve to a consistent and correct state.\n   *\n   * @returns A promise which resolves upon success of the operation and rejects with an {@link Ably.ErrorInfo} object upon its failure.\n   * @throws If the `Connection` is not in the `Connected` state.\n   * @throws If the operation fails to send the event to the server.\n   * @throws If there is a problem acquiring the mutex that controls serialization.\n   */\n  keystroke(): Promise<void>;\n\n  /**\n   * This will send a `typing.stopped` event to the server.\n   * If the user was not currently typing, this operation is no-op.\n   *\n   * Calls to `keystroke()` and `stop()` are serialized and will always resolve in the correct order.\n   * - For example, if multiple `keystroke()` calls are made in quick succession before the first `keystroke()` call has\n   *   sent a `typing.started` event to the server, followed by one `stop()` call, the `stop()` call will execute\n   *   as soon as the first `keystroke()` call completes.\n   *   All intermediate `keystroke()` calls will be treated as no-ops.\n   * - The most recent operation (`keystroke()` or `stop()`) will always determine the final state, ensuring operations\n   *   resolve to a consistent and correct state.\n   *\n   * @returns A promise which resolves upon success of the operation and rejects with an {@link Ably.ErrorInfo} object upon its failure.\n   * @throws If the `Connection` is not in the `Connected` state.\n   * @throws If the operation fails to send the event to the server.\n   * @throws If there is a problem acquiring the mutex that controls serialization.\n   */\n  stop(): Promise<void>;\n}\n\n/**\n * A listener which listens for typing events.\n * @param event The typing event.\n */\nexport type TypingListener = (event: TypingSetEvent) => void;\n\n/**\n * Represents the typing events mapped to their respective event payloads.\n */\ninterface TypingEventsMap {\n  [TypingSetEventType.SetChanged]: TypingSetEvent;\n}\n\n/**\n * Represents a timer handle that can be undefined.\n */\ntype TypingTimerHandle = ReturnType<typeof setTimeout> | undefined;\n\n/**\n * @inheritDoc\n */\nexport class DefaultTyping extends EventEmitter<TypingEventsMap> implements Typing {\n  private readonly _clientId: string;\n  private readonly _channel: Ably.RealtimeChannel;\n  private readonly _connection: Ably.Connection;\n  private readonly _logger: Logger;\n\n  // Throttle for the heartbeat, how often we should emit a typing event with repeated calls to keystroke()\n  // CHA-T10\n  private readonly _heartbeatThrottleMs: number;\n\n  // Grace period for inactivity before another user is considered to have stopped typing\n  // CHA-T10a\n  private readonly _timeoutMs = 2000;\n  private _heartbeatTimerId: TypingTimerHandle;\n  private readonly _currentlyTyping: Map<string, TypingTimerHandle>;\n\n  // Mutex for controlling `keystroke` and `stop` operations\n  private readonly _mutex = new Mutex();\n\n  /**\n   * Constructs a new `DefaultTyping` instance.\n   * @param options The options for typing in the room.\n   * @param connection The connection instance.\n   * @param channel The channel for the room.\n   * @param clientId The client ID of the user.\n   * @param logger An instance of the Logger.\n   */\n  constructor(\n    options: InternalTypingOptions,\n    connection: Ably.Connection,\n    channel: Ably.RealtimeChannel,\n    clientId: string,\n    logger: Logger,\n  ) {\n    super();\n    this._clientId = clientId;\n    this._channel = channel;\n    this._connection = connection;\n\n    // Interval for the heartbeat, how often we should emit a typing event with repeated calls to start()\n    this._heartbeatThrottleMs = options.heartbeatThrottleMs;\n\n    // Map of clientIds to their typing timers, used to track typing state\n    this._currentlyTyping = new Map<string, TypingTimerHandle>();\n    this._logger = logger;\n\n    this._applyChannelSubscriptions();\n  }\n\n  /**\n   * Sets up channel subscriptions for typing indicators.\n   */\n  private _applyChannelSubscriptions(): void {\n    // CHA-T8\n    // attachOnSubscribe is set to false in the default channel options, so this call cannot fail\n    void this._channel.subscribe(\n      [TypingEventType.Start, TypingEventType.Stop],\n      this._internalSubscribeToEvents.bind(this),\n    );\n  }\n\n  /**\n   * Clears all typing states.\n   * This includes clearing all timeouts and the currently typing map.\n   * @private\n   */\n  private _clearAllTypingStates(): void {\n    this._logger.debug(`DefaultTyping._clearAllTypingStates(); clearing all typing states`);\n    this._clearHeartbeatTimer();\n    this._clearCurrentlyTyping();\n  }\n\n  /**\n   * Clears the heartbeat timer.\n   * @private\n   */\n  private _clearHeartbeatTimer(): void {\n    this._logger.trace(`DefaultTyping._clearHeartbeatTimer(); clearing heartbeat timer`);\n    if (this._heartbeatTimerId) {\n      clearTimeout(this._heartbeatTimerId);\n      this._heartbeatTimerId = undefined;\n    }\n  }\n\n  /**\n   * Clears the currently typing store and removes all timeouts for associated clients.\n   * @private\n   */\n  private _clearCurrentlyTyping(): void {\n    this._logger.trace('DefaultTyping._clearCurrentlyTyping(); clearing current store and timeouts');\n    // Clear all client typing timeouts\n    for (const [, timeoutId] of this._currentlyTyping.entries()) {\n      clearTimeout(timeoutId);\n    }\n    // Clear the currently typing map\n    this._currentlyTyping.clear();\n  }\n\n  /**\n   * CHA-T16\n   *\n   * @inheritDoc\n   */\n  current(): Set<string> {\n    this._logger.trace(`DefaultTyping.current();`);\n    return new Set<string>(this._currentlyTyping.keys());\n  }\n\n  /**\n   * @inheritDoc\n   */\n  get channel(): Ably.RealtimeChannel {\n    return this._channel;\n  }\n\n  /**\n   * Start the heartbeat timer. This will expire after the configured interval.\n   */\n  private _startHeartbeatTimer(): void {\n    if (!this._heartbeatTimerId) {\n      this._logger.trace(`DefaultTyping.startHeartbeatTimer();`);\n      const timer = (this._heartbeatTimerId = setTimeout(() => {\n        this._logger.debug(`DefaultTyping.startHeartbeatTimer(); heartbeat timer expired`);\n        // CHA-T2a\n        if (timer === this._heartbeatTimerId) {\n          this._heartbeatTimerId = undefined;\n        }\n      }, this._heartbeatThrottleMs));\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  async keystroke(): Promise<void> {\n    this._logger.trace(`DefaultTyping.keystroke();`);\n    this._mutex.cancel();\n\n    // Acquire a mutex\n    try {\n      await this._mutex.acquire();\n    } catch (error: unknown) {\n      if (error === E_CANCELED) {\n        this._logger.debug(`DefaultTyping.keystroke(); mutex was canceled by a later operation`);\n        return;\n      }\n      throw new Ably.ErrorInfo('mutex acquisition failed', 50000, 500);\n    }\n    try {\n      // Check if connection is connected\n      // CHA-T4e\n      if (this._connection.state !== 'connected') {\n        this._logger.error(`DefaultTyping.keystroke(); connection is not connected`, {\n          status: this._connection.state,\n        });\n        throw new Ably.ErrorInfo('cannot type, connection is not connected', 40000, 400);\n      }\n\n      // Check whether user is already typing before publishing again\n      // CHA-T4c1, CHA-T4c2\n      if (this._heartbeatTimerId) {\n        this._logger.debug(`DefaultTyping.keystroke(); no-op, already typing and heartbeat timer has not expired`);\n        return;\n      }\n\n      // Perform the publish\n      // CHA-T4a3\n      await this._channel.publish(ephemeralMessage(TypingEventType.Start));\n\n      // Start the timer after publishing\n      // CHA-T4a5\n      this._startHeartbeatTimer();\n      this._logger.trace(`DefaultTyping.keystroke(); starting timers`);\n    } finally {\n      this._logger.trace(`DefaultTyping.keystroke(); releasing mutex`);\n      this._mutex.release();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  async stop(): Promise<void> {\n    this._logger.trace(`DefaultTyping.stop();`);\n\n    this._mutex.cancel();\n    // Acquire a mutex\n    try {\n      await this._mutex.acquire();\n    } catch (error: unknown) {\n      if (error === E_CANCELED) {\n        this._logger.debug(`DefaultTyping.stop(); mutex was canceled by a later operation`);\n        return;\n      }\n      throw new Ably.ErrorInfo('mutex acquisition failed', 50000, 500);\n    }\n    try {\n      // Check if connection is connected\n      if (this._connection.state !== 'connected') {\n        this._logger.error(`DefaultTyping.stop(); connection is not connected`, {\n          status: this._connection.state,\n        });\n        throw new Ably.ErrorInfo('cannot stop typing, connection is not connected', 40000, 400);\n      }\n\n      // If the user is not typing, do nothing.\n      // CHA-T5f\n      if (!this._heartbeatTimerId) {\n        this._logger.debug(`DefaultTyping.stop(); no-op, not currently typing`);\n        return;\n      }\n\n      // CHA-T5d\n      await this._channel.publish(ephemeralMessage(TypingEventType.Stop));\n      this._logger.trace(`DefaultTyping.stop(); clearing timers`);\n\n      // CHA-T5e\n      // Clear the heartbeat timer\n      clearTimeout(this._heartbeatTimerId);\n      this._heartbeatTimerId = undefined;\n    } finally {\n      this._logger.trace(`DefaultTyping.stop(); releasing mutex`);\n      this._mutex.release();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  subscribe(listener: TypingListener): Subscription {\n    this._logger.trace(`DefaultTyping.subscribe();`);\n    const wrapped = wrap(listener);\n    this.on(wrapped);\n\n    return {\n      unsubscribe: () => {\n        this._logger.trace('DefaultTyping.unsubscribe();');\n        this.off(wrapped);\n      },\n    };\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // CHA-RL3h\n  async dispose(): Promise<void> {\n    this._logger.trace(`DefaultTyping.dispose();`);\n\n    // Keep trying to acquire the mutex; wait 200 ms between attempts.\n    for (;;) {\n      try {\n        this._mutex.cancel();\n        await this._mutex.acquire();\n        break; // success  exit the loop\n      } catch (error: unknown) {\n        if (error === E_CANCELED) {\n          // In this case, the mutex was canceled by a later operation,\n          // but we are trying to release, so we should always take precedence here.\n          // Let's continue trying to acquire it until we win the acquisition lock.\n          this._logger.debug(`DefaultTyping.dispose(); mutex was canceled`);\n          await new Promise((resolve) => setTimeout(resolve, 200));\n          this._logger.debug(`DefaultTyping.dispose(); retrying mutex acquisition`);\n        } else {\n          // If we encounter any other error, we log it and exit the loop.\n          // This is to ensure that we don't get stuck in an infinite loop\n          // if the mutex acquisition fails for some other non-retryable reason.\n          this._logger.error(`DefaultTyping.dispose(); failed to acquire mutex; could not complete resource disposal`, {\n            error,\n          });\n          return;\n        }\n      }\n    }\n    this._clearAllTypingStates();\n    this._mutex.release();\n  }\n\n  /**\n   * Update the currently typing users. This method is called when a typing event is received.\n   * It will also acquire a mutex to ensure that the currentlyTyping state is updated safely.\n   * @param clientId The client ID of the user.\n   * @param event The typing event.\n   */\n  private _updateCurrentlyTyping(clientId: string, event: TypingEventType): void {\n    this._logger.trace(`DefaultTyping._updateCurrentlyTyping();`, { clientId, event });\n\n    if (event === TypingEventType.Start) {\n      this._handleTypingStart(clientId);\n    } else {\n      this._handleTypingStop(clientId);\n    }\n  }\n\n  /**\n   * Starts a new inactivity timer for the client.\n   * This timer will expire after the configured timeout,\n   * which is the sum of the heartbeat interval and the inactivity timeout.\n   * @param clientId\n   */\n  private _startNewClientInactivityTimer(clientId: string): ReturnType<typeof setTimeout> {\n    this._logger.trace(`DefaultTyping._startNewClientInactivityTimer(); starting new inactivity timer`, {\n      clientId,\n    });\n    // Set or reset the typing timeout for this client\n    const timeoutId = setTimeout(() => {\n      this._logger.trace(`DefaultTyping._startNewClientInactivityTimer(); client typing timeout expired`, {\n        clientId,\n      });\n      // Verify the timer is still valid (it might have been reset)\n      if (this._currentlyTyping.get(clientId) !== timeoutId) {\n        this._logger.debug(`DefaultTyping._startNewClientInactivityTimer(); timeout already cleared; ignoring`, {\n          clientId,\n        });\n        return;\n      }\n\n      // Remove client whose timeout has expired\n      this._currentlyTyping.delete(clientId);\n      this.emit(TypingSetEventType.SetChanged, {\n        type: TypingSetEventType.SetChanged,\n        currentlyTyping: new Set<string>(this._currentlyTyping.keys()),\n        change: {\n          clientId,\n          type: TypingEventType.Stop,\n        },\n      });\n    }, this._heartbeatThrottleMs + this._timeoutMs);\n    return timeoutId;\n  }\n\n  /**\n   * Handles logic for TypingEventType.Start, including starting a new timeout or resetting an existing one.\n   * @param clientId\n   */\n  private _handleTypingStart(clientId: string): void {\n    this._logger.debug(`DefaultTyping._handleTypingStart();`, { clientId });\n    // Start a new timeout for the client\n    const timeoutId = this._startNewClientInactivityTimer(clientId);\n\n    const existingTimeout = this._currentlyTyping.get(clientId);\n\n    // Set the new timeout for the client\n    this._currentlyTyping.set(clientId, timeoutId);\n\n    if (existingTimeout) {\n      // Heartbeat - User is already typing, we just need to clear the existing timeout\n      this._logger.debug(`DefaultTyping._handleTypingStart(); received heartbeat for currently typing client`, {\n        clientId,\n      });\n      clearTimeout(existingTimeout);\n    } else {\n      // Otherwise, we need to emit a new typing event\n      this._logger.debug(`DefaultTyping._handleTypingStart(); new client started typing`, {\n        clientId,\n      });\n      this.emit(TypingSetEventType.SetChanged, {\n        type: TypingSetEventType.SetChanged,\n        currentlyTyping: new Set<string>(this._currentlyTyping.keys()),\n        change: {\n          clientId,\n          type: TypingEventType.Start,\n        },\n      });\n    }\n  }\n\n  /**\n   * Handles logic for TypingEventType.Stop, including clearing the timeout for the client.\n   * @param clientId\n   * @private\n   */\n  private _handleTypingStop(clientId: string): void {\n    const existingTimeout = this._currentlyTyping.get(clientId);\n    if (!existingTimeout) {\n      // Stop requested for a client that isn't currently typing\n      this._logger.trace(\n        `DefaultTyping._handleTypingStop(); received \"Stop\" event for client not in currentlyTyping list`,\n        { clientId },\n      );\n      return;\n    }\n\n    // Stop typing: clear their timeout and remove from the currently typing set\n    this._logger.debug(`DefaultTyping._handleTypingStop(); client stopped typing`, { clientId });\n    clearTimeout(existingTimeout);\n    this._currentlyTyping.delete(clientId);\n    // Emit stop event only when the client is removed\n    this.emit(TypingSetEventType.SetChanged, {\n      type: TypingSetEventType.SetChanged,\n      currentlyTyping: new Set<string>(this._currentlyTyping.keys()),\n      change: {\n        clientId,\n        type: TypingEventType.Stop,\n      },\n    });\n  }\n\n  /**\n   * Subscribe to internal events. This listens to events and converts them into typing updates, with validation.\n   */\n  private _internalSubscribeToEvents = (inbound: Ably.InboundMessage): void => {\n    const { name, clientId } = inbound;\n    this._logger.trace(`DefaultTyping._internalSubscribeToEvents(); received event`, {\n      name,\n      clientId,\n    });\n\n    if (!clientId) {\n      this._logger.error(`DefaultTyping._internalSubscribeToEvents(); invalid clientId in received event`, {\n        inbound,\n      });\n      return;\n    }\n\n    // Safety check to ensure we are handling only typing events\n    if (name === TypingEventType.Start || name === TypingEventType.Stop) {\n      this._updateCurrentlyTyping(clientId, name);\n    } else {\n      this._logger.warn(`DefaultTyping._internalSubscribeToEvents(); unrecognized event`, {\n        name,\n      });\n    }\n  };\n\n  get heartbeatThrottleMs(): number {\n    return this._heartbeatThrottleMs;\n  }\n\n  get hasHeartbeatTimer(): boolean {\n    return !!this._heartbeatTimerId;\n  }\n}\n","import * as Ably from 'ably';\nimport cloneDeep from 'lodash.clonedeep';\n\nimport { ChannelManager } from './channel-manager.js';\nimport { ChatApi } from './chat-api.js';\nimport { DiscontinuityListener } from './discontinuity.js';\nimport { Logger } from './logger.js';\nimport { DefaultMessages, Messages } from './messages.js';\nimport { DefaultMessageReactions } from './messages-reactions.js';\nimport { DefaultOccupancy, Occupancy } from './occupancy.js';\nimport { DefaultPresence, Presence } from './presence.js';\nimport { RoomLifecycleManager } from './room-lifecycle-manager.js';\nimport { InternalRoomOptions, RoomOptions, validateRoomOptions } from './room-options.js';\nimport { DefaultRoomReactions, RoomReactions } from './room-reactions.js';\nimport { DefaultRoomLifecycle, InternalRoomLifecycle, RoomStatus, RoomStatusListener } from './room-status.js';\nimport { StatusSubscription } from './subscription.js';\nimport { DefaultTyping, Typing } from './typing.js';\n\n/**\n * Represents a chat room.\n */\nexport interface Room {\n  /**\n   * The unique identifier of the room.\n   *\n   * @returns The room name.\n   */\n  get name(): string;\n\n  /**\n   * Allows you to send, subscribe-to and query messages in the room.\n   *\n   * @returns The messages instance for the room.\n   */\n  get messages(): Messages;\n\n  /**\n   * Allows you to subscribe to presence events in the room.\n   *\n   * @returns The presence instance for the room.\n   */\n  get presence(): Presence;\n\n  /**\n   * Allows you to interact with room-level reactions.\n   *\n   * @returns The room reactions instance for the room.\n   */\n  get reactions(): RoomReactions;\n\n  /**\n   * Allows you to interact with typing events in the room.\n   *\n   * @returns The typing instance for the room.\n   */\n  get typing(): Typing;\n\n  /**\n   * Allows you to interact with occupancy metrics for the room.\n   *\n   * @returns The occupancy instance for the room.\n   */\n  get occupancy(): Occupancy;\n\n  /**\n   * The current status of the room.\n   *\n   * @returns The current status.\n   */\n  get status(): RoomStatus;\n\n  /**\n   * The current error, if any, that caused the room to enter the current status.\n   */\n  get error(): Ably.ErrorInfo | undefined;\n\n  /**\n   * Registers a listener that will be called whenever the room status changes.\n   * @param listener The function to call when the status changes.\n   * @returns An object that can be used to unregister the listener.\n   */\n  onStatusChange(listener: RoomStatusListener): StatusSubscription;\n\n  /**\n   * Attaches to the room to receive events in realtime.\n   *\n   * If a room fails to attach, it will enter either the {@link RoomStatus.Suspended} or {@link RoomStatus.Failed} state.\n   *\n   * If the room enters the failed state, then it will not automatically retry attaching and intervention is required.\n   *\n   * If the room enters the suspended state, then the call to attach will reject with the {@link ErrorInfo} that caused the suspension. However,\n   * the room will automatically retry attaching after a delay.\n   *\n   * @returns A promise that resolves when the room is attached.\n   */\n  attach(): Promise<void>;\n\n  /**\n   * Detaches from the room to stop receiving events in realtime.\n   *\n   * @returns A promise that resolves when the room is detached.\n   */\n  detach(): Promise<void>;\n\n  /**\n   * Returns the room options.\n   *\n   * @returns A copy of the options used to create the room.\n   */\n  options(): RoomOptions;\n\n  /**\n   * Registers a handler that will be called whenever a discontinuity is detected in the room's connection.\n   * A discontinuity occurs when the room's connection is interrupted and cannot be resumed from its previous state.\n   *\n   * @param handler The function to call when a discontinuity is detected.\n   * @returns An object that can be used to unregister the handler.\n   */\n  onDiscontinuity(handler: DiscontinuityListener): StatusSubscription;\n\n  /**\n   * Get the underlying Ably realtime channel used for the room.\n   * @returns The realtime channel.\n   */\n  get channel(): Ably.RealtimeChannel;\n}\n\nexport class DefaultRoom implements Room {\n  private readonly _name: string;\n  private readonly _options: RoomOptions;\n  private readonly _chatApi: ChatApi;\n  private readonly _messages: DefaultMessages;\n  private readonly _typing: DefaultTyping;\n  private readonly _presence: DefaultPresence;\n  private readonly _reactions: DefaultRoomReactions;\n  private readonly _occupancy: DefaultOccupancy;\n  private readonly _logger: Logger;\n  private readonly _lifecycle: DefaultRoomLifecycle;\n  private readonly _lifecycleManager: RoomLifecycleManager;\n  private readonly _finalizer: () => Promise<void>;\n  private readonly _channelManager: ChannelManager;\n\n  /**\n   * A random identifier for the room instance, useful in debugging and logging.\n   */\n  private readonly _nonce: string;\n\n  /**\n   * Constructs a new Room instance.\n   *\n   * @param name The unique identifier of the room.\n   * @param nonce A random identifier for the room instance, useful in debugging and logging.\n   * @param options The options for the room.\n   * @param realtime An instance of the Ably Realtime client.\n   * @param chatApi An instance of the ChatApi.\n   * @param logger An instance of the Logger.\n   * @param connection An instance of the Connection.\n   */\n  constructor(\n    name: string,\n    nonce: string,\n    options: InternalRoomOptions,\n    realtime: Ably.Realtime,\n    chatApi: ChatApi,\n    logger: Logger,\n  ) {\n    validateRoomOptions(options);\n    this._nonce = nonce;\n\n    // Create a logger with room context\n    this._logger = logger.withContext({ roomName: name, roomNonce: nonce });\n    this._logger.debug('Room();', { options });\n\n    this._name = name;\n    this._options = options;\n    this._chatApi = chatApi;\n    this._lifecycle = new DefaultRoomLifecycle(this._logger);\n\n    const channelManager = (this._channelManager = this._getChannelManager(options, realtime, this._logger));\n    const channel = channelManager.get();\n\n    // Setup features\n    this._messages = new DefaultMessages(\n      name,\n      options.messages,\n      channel,\n      this._chatApi,\n      realtime.auth.clientId,\n      this._logger,\n    );\n    this._presence = new DefaultPresence(channel, realtime.auth.clientId, this._logger, options);\n    this._typing = new DefaultTyping(\n      options.typing,\n      realtime.connection,\n      channel,\n      realtime.auth.clientId,\n      this._logger,\n    );\n    this._reactions = new DefaultRoomReactions(channel, realtime.connection, realtime.auth.clientId, this._logger);\n    this._occupancy = new DefaultOccupancy(name, channel, this._chatApi, this._logger, options);\n\n    // Set the lifecycle manager last, so it becomes the last thing to find out about channel state changes\n    // This is to allow Messages to reset subscription points before users get told of a discontinuity\n    this._lifecycleManager = new RoomLifecycleManager(channelManager, this._lifecycle, this._logger);\n\n    // Setup a finalization function to clean up resources\n    let finalized = false;\n    this._finalizer = async () => {\n      // Cycle the channels in the feature and release them from the realtime client\n      if (finalized) {\n        this._logger.debug('Room.finalizer(); already finalized');\n        return;\n      }\n\n      // Release via the lifecycle manager\n      await this._lifecycleManager.release();\n\n      // Dispose of all remaining resources only once we have fully released the room\n      await this._typing.dispose();\n\n      finalized = true;\n    };\n  }\n\n  /**\n   * Gets the channel manager for the room, which handles merging channel options together and creating channels.\n   *\n   * @param options The room options.\n   * @param realtime  An instance of the Ably Realtime client.\n   * @param logger An instance of the Logger.\n   */\n  private _getChannelManager(options: InternalRoomOptions, realtime: Ably.Realtime, logger: Logger): ChannelManager {\n    const manager = new ChannelManager(this._name, realtime, logger, options.isReactClient);\n\n    manager.mergeOptions(DefaultOccupancy.channelOptionMerger(options));\n    manager.mergeOptions(DefaultPresence.channelOptionMerger(options));\n    manager.mergeOptions(DefaultMessageReactions.channelOptionMerger(options));\n    return manager;\n  }\n\n  /**\n   * @inheritdoc Room\n   */\n  get name(): string {\n    return this._name;\n  }\n\n  /**\n   * @inheritDoc Room\n   */\n  options(): RoomOptions {\n    return cloneDeep(this._options);\n  }\n\n  /**\n   * @inheritdoc Room\n   */\n  get messages(): Messages {\n    return this._messages;\n  }\n\n  /**\n   * @inheritdoc Room\n   */\n  get presence(): Presence {\n    return this._presence;\n  }\n\n  /**\n   * @inheritdoc Room\n   */\n  get reactions(): RoomReactions {\n    return this._reactions;\n  }\n\n  /**\n   * @inheritdoc Room\n   */\n  get typing(): Typing {\n    return this._typing;\n  }\n\n  /**\n   * @inheritdoc Room\n   */\n  get occupancy(): Occupancy {\n    return this._occupancy;\n  }\n\n  /**\n   * @inheritdoc Room\n   */\n  get status(): RoomStatus {\n    return this._lifecycle.status;\n  }\n\n  /**\n   * @inheritdoc Room\n   */\n  get error(): Ably.ErrorInfo | undefined {\n    return this._lifecycle.error;\n  }\n\n  /**\n   * @inheritdoc Room\n   */\n  onStatusChange(listener: RoomStatusListener): StatusSubscription {\n    return this._lifecycle.onChange(listener);\n  }\n\n  /**\n   * @inheritdoc Room\n   */\n  async attach() {\n    this._logger.trace('Room.attach();');\n    return this._lifecycleManager.attach();\n  }\n\n  /**\n   * @inheritdoc Room\n   */\n  async detach(): Promise<void> {\n    this._logger.trace('Room.detach();');\n    return this._lifecycleManager.detach();\n  }\n\n  /**\n   * Releases resources associated with the room.\n   * We guarantee that this does not throw an error.\n   */\n  release(): Promise<void> {\n    this._logger.trace('Room.release();');\n    return this._finalizer();\n  }\n\n  /**\n   * A random identifier for the room instance, useful in debugging and logging.\n   *\n   * @returns The nonce.\n   */\n  get nonce(): string {\n    return this._nonce;\n  }\n\n  /**\n   * @internal\n   *\n   * Returns the rooms lifecycle.\n   */\n  get lifecycle(): InternalRoomLifecycle {\n    return this._lifecycle;\n  }\n\n  /**\n   * @internal\n   */\n  get lifecycleManager(): RoomLifecycleManager {\n    return this._lifecycleManager;\n  }\n\n  /**\n   * @inheritdoc Room\n   */\n  onDiscontinuity(handler: DiscontinuityListener): StatusSubscription {\n    this._logger.trace('Room.onDiscontinuity();');\n    return this._lifecycleManager.onDiscontinuity(handler);\n  }\n\n  /**\n   * @inheritdoc Room\n   */\n  get channel(): Ably.RealtimeChannel {\n    return this._channelManager.get();\n  }\n}\n","import * as Ably from 'ably';\nimport { dequal } from 'dequal';\n\nimport { ChatApi } from './chat-api.js';\nimport { ChatClientOptions, NormalizedChatClientOptions } from './config.js';\nimport { ErrorCode } from './errors.js';\nimport { randomId } from './id.js';\nimport { Logger } from './logger.js';\nimport { DefaultRoom, Room } from './room.js';\nimport { normalizeRoomOptions, RoomOptions } from './room-options.js';\n\n/**\n * Manages the lifecycle of chat rooms.\n */\nexport interface Rooms {\n  /**\n   * Gets a room reference by its unique identifier. The Rooms class ensures that only one reference\n   * exists for each room. A new reference object is created if it doesn't already\n   * exist, or if the one used previously was released using release(name).\n   *\n   * Always call `release(name)` after the Room object is no longer needed.\n   *\n   * If a call to `get` is made for a room that is currently being released, then the promise will resolve only when\n   * the release operation is complete.\n   *\n   * If a call to `get` is made, followed by a subsequent call to `release` before the promise resolves, then the\n   * promise will reject with an error.\n   *\n   * @param name The unique identifier of the room.\n   * @param options The options for the room.\n   * @throws {@link ErrorInfo} if a room with the same name but different options already exists.\n   * @returns Room A promise to a new or existing Room object.\n   */\n  get(name: string, options?: RoomOptions): Promise<Room>;\n\n  /**\n   * Release the Room object if it exists. This method only releases the reference\n   * to the Room object from the Rooms instance and detaches the room from Ably. It does not unsubscribe to any\n   * events.\n   *\n   * After calling this function, the room object is no-longer usable. If you wish to get the room object again,\n   * you must call {@link Rooms.get}.\n   *\n   * Calling this function will abort any in-progress `get` calls for the same room.\n   *\n   * @param name The unique identifier of the room.\n   */\n  release(name: string): Promise<void>;\n\n  /**\n   * Get the client options used to create the Chat instance.\n   * @returns ChatClientOptions\n   */\n  get clientOptions(): ChatClientOptions;\n}\n\n/**\n * Represents an entry in the chat room map.\n */\ninterface RoomMapEntry {\n  /**\n   * The promise that will eventually resolve to the room.\n   */\n  promise: Promise<DefaultRoom>;\n\n  /**\n   * A random, internal identifier useful for debugging and logging.\n   */\n  nonce: string;\n\n  /**\n   * The options for the room.\n   */\n  options: RoomOptions | undefined;\n\n  /**\n   * An abort controller to abort the get operation if the room is released before the get operation completes.\n   */\n  abort?: AbortController;\n}\n\n/**\n * Manages the chat rooms.\n */\nexport class DefaultRooms implements Rooms {\n  private readonly _realtime: Ably.Realtime;\n  private readonly _chatApi: ChatApi;\n  private readonly _clientOptions: NormalizedChatClientOptions;\n  private readonly _rooms: Map<string, RoomMapEntry> = new Map<string, RoomMapEntry>();\n  private readonly _releasing = new Map<string, Promise<void>>();\n  private readonly _logger: Logger;\n  private _isReact = false;\n\n  /**\n   * Constructs a new Rooms instance.\n   *\n   * @param realtime An instance of the Ably Realtime client.\n   * @param clientOptions The client options from the chat instance.\n   * @param logger An instance of the Logger.\n   */\n  constructor(realtime: Ably.Realtime, clientOptions: NormalizedChatClientOptions, logger: Logger) {\n    this._realtime = realtime;\n    this._chatApi = new ChatApi(realtime, logger);\n    this._clientOptions = clientOptions;\n    this._logger = logger;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  get(name: string, options?: RoomOptions): Promise<Room> {\n    this._logger.trace('Rooms.get();', { roomName: name });\n\n    const existing = this._rooms.get(name);\n    if (existing) {\n      if (!dequal(existing.options, options)) {\n        return Promise.reject(new Ably.ErrorInfo('room already exists with different options', 40000, 400));\n      }\n\n      this._logger.debug('Rooms.get(); returning existing room', { roomName: name, nonce: existing.nonce });\n      return existing.promise;\n    }\n\n    const releasing = this._releasing.get(name);\n    const nonce = randomId();\n\n    // We're not currently releasing the room, so we just make a new one\n    if (!releasing) {\n      const room = this._makeRoom(name, nonce, options);\n      const entry = {\n        promise: Promise.resolve(room),\n        nonce: nonce,\n        options: options,\n      };\n\n      this._rooms.set(name, entry);\n      this._logger.debug('Rooms.get(); returning new room', { roomName: name, nonce: room.nonce });\n      return entry.promise;\n    }\n\n    // The room is currently in the process of being released so, we wait for it to finish\n    // we add an abort controller so that if the room is released again whilst we're waiting, we abort the process\n    const abortController = new AbortController();\n    const roomPromise = new Promise<DefaultRoom>((resolve, reject) => {\n      const abortListener = () => {\n        this._logger.debug('Rooms.get(); aborted before init', { roomName: name });\n        reject(\n          new Ably.ErrorInfo(\n            'room released before get operation could complete',\n            ErrorCode.RoomReleasedBeforeOperationCompleted,\n            400,\n          ),\n        );\n      };\n\n      abortController.signal.addEventListener('abort', abortListener);\n\n      releasing\n        .then(() => {\n          // We aborted before resolution\n          if (abortController.signal.aborted) {\n            this._logger.debug('Rooms.get(); aborted before releasing promise resolved', { roomName: name });\n            return;\n          }\n\n          this._logger.debug('Rooms.get(); releasing finished', { roomName: name });\n          const room = this._makeRoom(name, nonce, options);\n          abortController.signal.removeEventListener('abort', abortListener);\n          resolve(room);\n        })\n        .catch((error: unknown) => {\n          reject(error as Error);\n        });\n    });\n\n    this._rooms.set(name, {\n      promise: roomPromise,\n      options: options,\n      nonce: nonce,\n      abort: abortController,\n    });\n\n    this._logger.debug('Rooms.get(); creating new promise dependent on previous release', { roomName: name });\n    return roomPromise;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  get clientOptions(): ChatClientOptions {\n    return this._clientOptions;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  release(name: string): Promise<void> {\n    this._logger.trace('Rooms.release();', { roomName: name });\n\n    const existing = this._rooms.get(name);\n    const releasing = this._releasing.get(name);\n\n    // If the room doesn't currently exist\n    if (!existing) {\n      // There's no existing room, but there is a release in progress, so forward that releasing promise\n      // to the caller so they can watch that.\n      if (releasing) {\n        this._logger.debug('Rooms.release(); waiting for previous release call', {\n          roomName: name,\n        });\n        return releasing;\n      }\n\n      // If the room is not releasing, there is nothing else to do\n      this._logger.debug('Rooms.release(); room does not exist', { roomName: name });\n      return Promise.resolve();\n    }\n\n    // A release is in progress, but its not for the currently requested room instance\n    // ie we called release, then get, then release again\n    // so instead of doing another release process, we just abort the current get\n    if (releasing) {\n      if (existing.abort) {\n        this._logger.debug('Rooms.release(); aborting get call', { roomName: name, existingNonce: existing.nonce });\n        existing.abort.abort();\n        this._rooms.delete(name);\n      }\n\n      return releasing;\n    }\n\n    // Room doesn't exist and we're not releasing, so its just a regular release operation\n    this._rooms.delete(name);\n    const releasePromise = existing.promise.then((room) => {\n      this._logger.debug('Rooms.release(); releasing room', { roomName: name, nonce: existing.nonce });\n      return room.release().then(() => {\n        this._logger.debug('Rooms.release(); room released', { roomName: name, nonce: existing.nonce });\n        this._releasing.delete(name);\n      });\n    });\n\n    this._logger.debug('Rooms.release(); creating new release promise', { roomName: name, nonce: existing.nonce });\n    this._releasing.set(name, releasePromise);\n\n    return releasePromise;\n  }\n\n  /**\n   * makes a new room object\n   *\n   * @param name The unique identifier of the room.\n   * @param nonce A random, internal identifier useful for debugging and logging.\n   * @param options The options for the room.\n   *\n   * @returns DefaultRoom A new room object.\n   */\n  private _makeRoom(name: string, nonce: string, options: RoomOptions | undefined): DefaultRoom {\n    return new DefaultRoom(\n      name,\n      nonce,\n      normalizeRoomOptions(options, this._isReact),\n      this._realtime,\n      this._chatApi,\n      this._logger,\n    );\n  }\n\n  /**\n   * Sets react JS mode.\n   */\n  useReact(): void {\n    this._logger.trace('Rooms.useReact();');\n    this._isReact = true;\n  }\n}\n","import * as Ably from 'ably';\n\nimport { ChatClientOptions, normalizeClientOptions, NormalizedChatClientOptions } from './config.js';\nimport { Connection, DefaultConnection } from './connection.js';\nimport { Logger, makeLogger } from './logger.js';\nimport { RealtimeWithOptions } from './realtime-extensions.js';\nimport { DefaultRooms, Rooms } from './rooms.js';\nimport { VERSION } from './version.js';\n\n/**\n * This is the core client for Ably chat. It provides access to chat rooms.\n */\nexport class ChatClient {\n  /**\n   * @internal\n   */\n  private readonly _realtime: Ably.Realtime;\n\n  /**\n   * @internal\n   */\n  private readonly _rooms: DefaultRooms;\n\n  /**\n   * @internal\n   */\n  private readonly _clientOptions: NormalizedChatClientOptions;\n\n  /**\n   * @internal\n   */\n  private readonly _connection: Connection;\n\n  /**\n   * @internal\n   */\n  private readonly _logger: Logger;\n\n  /**\n   * Constructor for Chat\n   * @param realtime - The Ably Realtime client.\n   * @param clientOptions - The client options.\n   */\n  constructor(realtime: Ably.Realtime, clientOptions?: ChatClientOptions) {\n    this._realtime = realtime;\n    this._clientOptions = normalizeClientOptions(clientOptions);\n    this._logger = makeLogger(this._clientOptions);\n    this._connection = new DefaultConnection(realtime, this._logger);\n    this._rooms = new DefaultRooms(realtime, this._clientOptions, this._logger);\n    this._addAgent('chat-js');\n    this._logger.trace(`ably chat client version ${VERSION}; initialized`);\n  }\n\n  /**\n   * Returns the rooms object, which provides access to chat rooms.\n   *\n   * @returns The rooms object.\n   */\n  get rooms(): Rooms {\n    return this._rooms;\n  }\n\n  /**\n   * Returns the underlying connection to Ably, which can be used to monitor the client's\n   * connection to Ably servers.\n   *\n   * @returns The connection object.\n   */\n  get connection(): Connection {\n    return this._connection;\n  }\n\n  /**\n   * Returns the clientId of the current client.\n   *\n   * @returns The clientId.\n   */\n  get clientId(): string {\n    return this._realtime.auth.clientId;\n  }\n\n  /**\n   * Returns the underlying Ably Realtime client.\n   * @returns The Ably Realtime client.\n   */\n  get realtime(): Ably.Realtime {\n    return this._realtime;\n  }\n\n  /**\n   * Returns the resolved client options for the client, including any defaults that have been set.\n   * @returns The client options.\n   */\n  get clientOptions(): ChatClientOptions {\n    return this._clientOptions;\n  }\n\n  /**\n   * Returns the logger instance for the client.\n   * @internal\n   * @returns The logger instance.\n   */\n  get logger(): Logger {\n    return this._logger;\n  }\n\n  /**\n   * Adds additional agent information to the client.\n   * Used internally to add React-specific agent information.\n   * @internal\n   */\n  public addReactAgent(): void {\n    this._addAgent('chat-react');\n    this._rooms.useReact();\n  }\n\n  /**\n   * Adds additional agent information to the client.\n   * This is used internally to add a specific agent with a version.\n   * @param agent - The agent to add.\n   * @param version - The version of the agent, defaults to the current client version.\n   * @internal\n   */\n  public addAgentWithVersion(agent: string, version: string): void {\n    this._addAgent(agent, version);\n    this._logger.trace(`Added agent ${agent} with version ${version}`);\n  }\n  /**\n   * Sets the agent string for the client.\n   * @param agent - The agent to add.\n   * @param version - The version of the agent, defaults to the current client version.\n   * @internal\n   */\n  private _addAgent(agent: string, version?: string): void {\n    const realtime = this._realtime as RealtimeWithOptions;\n    realtime.options.agents = { ...(realtime.options.agents ?? realtime.options.agents), [agent]: version ?? VERSION };\n  }\n}\n"],"names":["LogLevel","consoleLogger","message","level","context","contextString","formattedMessage","makeLogger","options","logHandler","DefaultLogger","logLevelNumberMap","handler","levelNumber","Ably","originalLevel","value","defaultClientOptions","normalizeClientOptions","InternalEventEmitter","EventEmitter","wrap","fn","args","ConnectionStatus","DefaultConnection","ably","logger","change","chatState","stateChange","listener","wrapped","status","has","find","iter","tar","key","dequal","foo","bar","ctor","len","tmp","ChatMessageEventType","RealtimeMessageName","RealtimeMetaEventType","ChatMessageAction","PresenceEventType","TypingEventType","TypingSetEventType","RoomReactionRealtimeEventType","RoomReactionEventType","MessageReactionType","ReactionAnnotationType","AnnotationTypeToReactionType","MessageReactionEventType","OccupancyEventType","RoomEventType","LARGE_ARRAY_SIZE","HASH_UNDEFINED","MAX_SAFE_INTEGER","argsTag","arrayTag","boolTag","dateTag","errorTag","funcTag","genTag","mapTag","numberTag","objectTag","promiseTag","regexpTag","setTag","stringTag","symbolTag","weakMapTag","arrayBufferTag","dataViewTag","float32Tag","float64Tag","int8Tag","int16Tag","int32Tag","uint8Tag","uint8ClampedTag","uint16Tag","uint32Tag","reRegExpChar","reFlags","reIsHostCtor","reIsUint","cloneableTags","freeGlobal","global","freeSelf","root","freeExports","exports","freeModule","module","moduleExports","addMapEntry","map","pair","addSetEntry","set","arrayEach","array","iteratee","index","length","arrayPush","values","offset","arrayReduce","accumulator","initAccum","baseTimes","n","result","getValue","object","isHostObject","mapToArray","overArg","func","transform","arg","setToArray","arrayProto","funcProto","objectProto","coreJsData","maskSrcKey","uid","funcToString","hasOwnProperty","objectToString","reIsNative","Buffer","Symbol","Uint8Array","getPrototype","objectCreate","propertyIsEnumerable","splice","nativeGetSymbols","nativeIsBuffer","nativeKeys","DataView","getNative","Map","Promise","Set","WeakMap","nativeCreate","dataViewCtorString","toSource","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","symbolProto","symbolValueOf","Hash","entries","entry","hashClear","hashDelete","hashGet","data","hashHas","hashSet","ListCache","listCacheClear","listCacheDelete","assocIndexOf","lastIndex","listCacheGet","listCacheHas","listCacheSet","MapCache","mapCacheClear","mapCacheDelete","getMapData","mapCacheGet","mapCacheHas","mapCacheSet","Stack","stackClear","stackDelete","stackGet","stackHas","stackSet","cache","pairs","arrayLikeKeys","inherited","isArray","isArguments","skipIndexes","isIndex","assignValue","objValue","eq","baseAssign","source","copyObject","keys","baseClone","isDeep","isFull","customizer","stack","isObject","isArr","initCloneArray","copyArray","tag","getTag","isFunc","isBuffer","cloneBuffer","initCloneObject","copySymbols","initCloneByTag","stacked","props","getAllKeys","subValue","baseCreate","proto","baseGetAllKeys","keysFunc","symbolsFunc","baseGetTag","baseIsNative","isMasked","pattern","isFunction","baseKeys","isPrototype","buffer","cloneArrayBuffer","arrayBuffer","cloneDataView","dataView","cloneMap","cloneFunc","cloneRegExp","regexp","cloneSet","cloneSymbol","symbol","cloneTypedArray","typedArray","newValue","getSymbols","isKeyable","stubArray","Ctor","ctorString","type","cloneDeep","other","isArrayLikeObject","isArrayLike","isLength","isObjectLike","stubFalse","DefaultMessage","serial","clientId","text","metadata","headers","action","version","createdAt","timestamp","reactions","operation","event","newReactions","replace","params","emptyMessageReactions","parseMessage","inboundMessage","extras","serialToString","serialString","eventTypeMap","DefaultMessageReactions","_logger","_options","_api","_roomName","_channel","reactionType","eventType","name","reactionEvent","unique","distinct","multiple","messageSerial","count","apiParams","roomOptions","messageFromRest","MessageActionsToEventsMap","OrderBy","DefaultMessages","roomName","channel","chatApi","subscriptionPoint","subscriptionPointParams","fromResume","newSubscriptionStartResolver","channelWithProperties","resolve","reject","response","updateParams","details","resolvedSubscriptionStart","channelEventMessage","error","ChatApi","realtime","paginatedResult","payload","nextData","firstData","currentData","body","encodedSerial","url","method","ErrorCode","errorInfoIs","errorInfo","randomId","roomChannelName","VERSION","CHANNEL_OPTIONS_AGENT_STRING","CHANNEL_OPTIONS_AGENT_STRING_REACT","DEFAULT_CHANNEL_MODES","DEFAULT_CHANNEL_OPTIONS","DEFAULT_CHANNEL_OPTIONS_REACT","ChannelManager","isReact","merger","baseOptions","DefaultOccupancy","metrics","connections","presenceMembers","DefaultPresence","member","presenceData","user","presenceEventToSend","listenerOrEvents","E_CANCELED","__awaiter$2","thisArg","_arguments","P","generator","adopt","fulfilled","step","e","rejected","Semaphore","_value","_cancelError","weight","priority","task","i","findIndexFromEnd","callback_1","callback","release","insertSorted","item","previousValue","called","waiters","waiter","queuedPriority","a","v","predicate","__awaiter$1","Mutex","cancelError","releaser","RoomStatus","DefaultRoomLifecycle","RoomLifecycleManager","channelManager","roomLifecycle","newStatus","errInfo","attachError","detachError","channelState","op","firstAttach","DefaultRoomOptions","invalidRoomConfiguration","reason","validateRoomOptions","validateTypingOptions","normalizeTypingOptions","normalizeOccupancyOptions","normalizePresenceOptions","normalizeMessageOptions","normalizeRoomOptions","react","ephemeralMessage","messageToEphemeral","DefaultRoomReaction","isSelf","parseRoomReaction","reactionCreatedMessage","DefaultRoomReactions","connection","inbound","reaction","realtimeMessage","DefaultTyping","timeoutId","timer","existingTimeout","DefaultRoom","nonce","finalized","manager","DefaultRooms","clientOptions","existing","releasing","room","abortController","roomPromise","abortListener","releasePromise","ChatClient","agent"],"mappings":"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","x_google_ignoreList":[4,6,21]}