import { TypingSetEvent, TypingSetEventType } from './events.js';
import { Logger } from './logger.js';
import { InternalTypingOptions } from './room-options.js';
import { Subscription } from './subscription.js';
import { default as EventEmitter } from './utils/event-emitter.js';
import * as Ably from 'ably';
/**
 * This interface is used to interact with typing in a chat room including subscribing to typing events and
 * fetching the current set of typing clients.
 *
 * Get an instance via {@link Room.typing}.
 */
export interface Typing {
    /**
     * Subscribe a given listener to all typing events from users in the chat room.
     *
     * @param listener A listener to be called when the typing state of a user in the room changes.
     * @returns A response object that allows you to control the subscription to typing events.
     */
    subscribe(listener: TypingListener): Subscription;
    /**
     * Get the current typers, a set of clientIds.
     * @returns The set of clientIds that are currently typing.
     */
    current(): Set<string>;
    /**
     * This will send a `typing.started` event to the server.
     * Events are throttled according to the `heartbeatThrottleMs` room option.
     * If an event has been sent within the interval, this operation is no-op.
     *
     *
     * Calls to `keystroke()` and `stop()` are serialized and will always resolve in the correct order.
     * - For example, if multiple `keystroke()` calls are made in quick succession before the first `keystroke()` call has
     *   sent a `typing.started` event to the server, followed by one `stop()` call, the `stop()` call will execute
     *   as soon as the first `keystroke()` call completes.
     *   All intermediate `keystroke()` calls will be treated as no-ops.
     * - The most recent operation (`keystroke()` or `stop()`) will always determine the final state, ensuring operations
     *   resolve to a consistent and correct state.
     *
     * @returns A promise which resolves upon success of the operation and rejects with an {@link Ably.ErrorInfo} object upon its failure.
     * @throws If the `Connection` is not in the `Connected` state.
     * @throws If the operation fails to send the event to the server.
     * @throws If there is a problem acquiring the mutex that controls serialization.
     */
    keystroke(): Promise<void>;
    /**
     * This will send a `typing.stopped` event to the server.
     * If the user was not currently typing, this operation is no-op.
     *
     * Calls to `keystroke()` and `stop()` are serialized and will always resolve in the correct order.
     * - For example, if multiple `keystroke()` calls are made in quick succession before the first `keystroke()` call has
     *   sent a `typing.started` event to the server, followed by one `stop()` call, the `stop()` call will execute
     *   as soon as the first `keystroke()` call completes.
     *   All intermediate `keystroke()` calls will be treated as no-ops.
     * - The most recent operation (`keystroke()` or `stop()`) will always determine the final state, ensuring operations
     *   resolve to a consistent and correct state.
     *
     * @returns A promise which resolves upon success of the operation and rejects with an {@link Ably.ErrorInfo} object upon its failure.
     * @throws If the `Connection` is not in the `Connected` state.
     * @throws If the operation fails to send the event to the server.
     * @throws If there is a problem acquiring the mutex that controls serialization.
     */
    stop(): Promise<void>;
}
/**
 * A listener which listens for typing events.
 * @param event The typing event.
 */
export type TypingListener = (event: TypingSetEvent) => void;
/**
 * Represents the typing events mapped to their respective event payloads.
 */
interface TypingEventsMap {
    [TypingSetEventType.SetChanged]: TypingSetEvent;
}
/**
 * @inheritDoc
 */
export declare class DefaultTyping extends EventEmitter<TypingEventsMap> implements Typing {
    private readonly _clientId;
    private readonly _channel;
    private readonly _connection;
    private readonly _logger;
    private readonly _heartbeatThrottleMs;
    private readonly _timeoutMs;
    private _heartbeatTimerId;
    private readonly _currentlyTyping;
    private readonly _mutex;
    /**
     * Constructs a new `DefaultTyping` instance.
     * @param options The options for typing in the room.
     * @param connection The connection instance.
     * @param channel The channel for the room.
     * @param clientId The client ID of the user.
     * @param logger An instance of the Logger.
     */
    constructor(options: InternalTypingOptions, connection: Ably.Connection, channel: Ably.RealtimeChannel, clientId: string, logger: Logger);
    /**
     * Sets up channel subscriptions for typing indicators.
     */
    private _applyChannelSubscriptions;
    /**
     * Clears all typing states.
     * This includes clearing all timeouts and the currently typing map.
     * @private
     */
    private _clearAllTypingStates;
    /**
     * Clears the heartbeat timer.
     * @private
     */
    private _clearHeartbeatTimer;
    /**
     * Clears the currently typing store and removes all timeouts for associated clients.
     * @private
     */
    private _clearCurrentlyTyping;
    /**
     * CHA-T16
     *
     * @inheritDoc
     */
    current(): Set<string>;
    /**
     * @inheritDoc
     */
    get channel(): Ably.RealtimeChannel;
    /**
     * Start the heartbeat timer. This will expire after the configured interval.
     */
    private _startHeartbeatTimer;
    /**
     * @inheritDoc
     */
    keystroke(): Promise<void>;
    /**
     * @inheritDoc
     */
    stop(): Promise<void>;
    /**
     * @inheritDoc
     */
    subscribe(listener: TypingListener): Subscription;
    /**
     * @inheritDoc
     */
    dispose(): Promise<void>;
    /**
     * Update the currently typing users. This method is called when a typing event is received.
     * It will also acquire a mutex to ensure that the currentlyTyping state is updated safely.
     * @param clientId The client ID of the user.
     * @param event The typing event.
     */
    private _updateCurrentlyTyping;
    /**
     * Starts a new inactivity timer for the client.
     * This timer will expire after the configured timeout,
     * which is the sum of the heartbeat interval and the inactivity timeout.
     * @param clientId
     */
    private _startNewClientInactivityTimer;
    /**
     * Handles logic for TypingEventType.Start, including starting a new timeout or resetting an existing one.
     * @param clientId
     */
    private _handleTypingStart;
    /**
     * Handles logic for TypingEventType.Stop, including clearing the timeout for the client.
     * @param clientId
     * @private
     */
    private _handleTypingStop;
    /**
     * Subscribe to internal events. This listens to events and converts them into typing updates, with validation.
     */
    private _internalSubscribeToEvents;
    get heartbeatThrottleMs(): number;
    get hasHeartbeatTimer(): boolean;
}
export {};
