import * as l from "ably";
var Tt = /* @__PURE__ */ ((n) => (n.Trace = "trace", n.Debug = "debug", n.Info = "info", n.Warn = "warn", n.Error = "error", n.Silent = "silent", n))(Tt || {});
const en = (n, e, t) => {
  const i = t ? `, context: ${JSON.stringify(t)}` : "", a = `[${(/* @__PURE__ */ new Date()).toISOString()}] ${e.valueOf().toUpperCase()} ably-chat: ${n}${i}`;
  switch (e) {
    case "trace":
    case "debug": {
      console.log(a);
      break;
    }
    case "info": {
      console.info(a);
      break;
    }
    case "warn": {
      console.warn(a);
      break;
    }
    case "error": {
      console.error(a);
      break;
    }
  }
}, tn = (n) => {
  const e = n.logHandler ?? en;
  return new Ae(e, n.logLevel);
}, ft = /* @__PURE__ */ new Map([
  [
    "trace",
    0
    /* Trace */
  ],
  [
    "debug",
    1
    /* Debug */
  ],
  [
    "info",
    2
    /* Info */
  ],
  [
    "warn",
    3
    /* Warn */
  ],
  [
    "error",
    4
    /* Error */
  ],
  [
    "silent",
    5
    /* Silent */
  ]
]);
class Ae {
  constructor(e, t, i) {
    this._handler = e, this._context = i;
    const a = ft.get(t);
    if (a === void 0)
      throw new l.ErrorInfo(`Invalid log level: ${t}`, 5e4, 500);
    this._levelNumber = a;
  }
  trace(e, t) {
    this._write(e, "trace", 0, t);
  }
  debug(e, t) {
    this._write(e, "debug", 1, t);
  }
  info(e, t) {
    this._write(e, "info", 2, t);
  }
  warn(e, t) {
    this._write(e, "warn", 3, t);
  }
  error(e, t) {
    this._write(e, "error", 4, t);
  }
  withContext(e) {
    const t = [...ft.entries()].find(([, i]) => i === this._levelNumber)?.[0] ?? "error";
    return new Ae(this._handler, t, this._mergeContext(e));
  }
  _write(e, t, i, a) {
    i >= this._levelNumber && this._handler(e, t, this._mergeContext(a));
  }
  _mergeContext(e) {
    return this._context ? e ? { ...this._context, ...e } : this._context : e ?? void 0;
  }
}
const rn = {
  logLevel: Tt.Error
}, nn = (n) => (n = n ?? {}, {
  ...n,
  logLevel: n.logLevel ?? rn.logLevel
}), sn = l.Realtime.EventEmitter;
class I extends sn {
}
const M = (n) => (...e) => n(...e);
var an = /* @__PURE__ */ ((n) => (n.Initialized = "initialized", n.Connecting = "connecting", n.Connected = "connected", n.Disconnected = "disconnected", n.Suspended = "suspended", n.Failed = "failed", n))(an || {});
class on {
  /**
   * Constructs a new `DefaultConnection` instance.
   * @param ably The Ably Realtime client.
   * @param logger The logger to use.
   */
  constructor(e, t) {
    this._status = "initialized", this._emitter = new I(), this._logger = t, this._status = this._mapAblyStatusToChat(e.connection.state), this._error = e.connection.errorReason, this._connection = e.connection, this._connection.on((i) => {
      const a = this._mapAblyStatusToChat(i.current);
      if (a === this._status)
        return;
      const c = {
        current: a,
        previous: this._status,
        error: i.reason,
        retryIn: i.retryIn
      };
      this._applyStatusChange(c);
    });
  }
  /**
   * @inheritdoc
   */
  get status() {
    return this._status;
  }
  /**
   * @inheritdoc
   */
  get error() {
    return this._error;
  }
  /**
   * @inheritdoc
   */
  onStatusChange(e) {
    const t = M(e);
    return this._emitter.on(t), {
      off: () => {
        this._emitter.off(t);
      }
    };
  }
  _applyStatusChange(e) {
    this._status = e.current, this._error = e.error, this._logger.info("Connection state changed", e), this._emitter.emit(e.current, e);
  }
  _mapAblyStatusToChat(e) {
    switch (e) {
      case "closing":
      case "closed":
        return "failed";
      default:
        return e;
    }
  }
}
var mt = Object.prototype.hasOwnProperty;
function yt(n, e, t) {
  for (t of n.keys())
    if (K(t, e)) return t;
}
function K(n, e) {
  var t, i, a;
  if (n === e) return !0;
  if (n && e && (t = n.constructor) === e.constructor) {
    if (t === Date) return n.getTime() === e.getTime();
    if (t === RegExp) return n.toString() === e.toString();
    if (t === Array) {
      if ((i = n.length) === e.length)
        for (; i-- && K(n[i], e[i]); ) ;
      return i === -1;
    }
    if (t === Set) {
      if (n.size !== e.size)
        return !1;
      for (i of n)
        if (a = i, a && typeof a == "object" && (a = yt(e, a), !a) || !e.has(a)) return !1;
      return !0;
    }
    if (t === Map) {
      if (n.size !== e.size)
        return !1;
      for (i of n)
        if (a = i[0], a && typeof a == "object" && (a = yt(e, a), !a) || !K(i[1], e.get(a)))
          return !1;
      return !0;
    }
    if (t === ArrayBuffer)
      n = new Uint8Array(n), e = new Uint8Array(e);
    else if (t === DataView) {
      if ((i = n.byteLength) === e.byteLength)
        for (; i-- && n.getInt8(i) === e.getInt8(i); ) ;
      return i === -1;
    }
    if (ArrayBuffer.isView(n)) {
      if ((i = n.byteLength) === e.byteLength)
        for (; i-- && n[i] === e[i]; ) ;
      return i === -1;
    }
    if (!t || typeof n == "object") {
      i = 0;
      for (t in n)
        if (mt.call(n, t) && ++i && !mt.call(e, t) || !(t in e) || !K(n[t], e[t])) return !1;
      return Object.keys(e).length === i;
    }
  }
  return n !== n && e !== e;
}
var N = /* @__PURE__ */ ((n) => (n.Created = "message.created", n.Updated = "message.updated", n.Deleted = "message.deleted", n))(N || {}), Rt = /* @__PURE__ */ ((n) => (n.ChatMessage = "chat.message", n))(Rt || {}), Mt = /* @__PURE__ */ ((n) => (n.Occupancy = "[meta]occupancy", n))(Mt || {}), y = /* @__PURE__ */ ((n) => (n.MessageCreate = "message.create", n.MessageUpdate = "message.update", n.MessageDelete = "message.delete", n.MessageAnnotationSummary = "message.summary", n.MessageMetaOccupancy = "meta.occupancy", n))(y || {}), cn = /* @__PURE__ */ ((n) => (n.Enter = "enter", n.Leave = "leave", n.Update = "update", n.Present = "present", n))(cn || {}), T = /* @__PURE__ */ ((n) => (n.Start = "typing.started", n.Stop = "typing.stopped", n))(T || {}), U = /* @__PURE__ */ ((n) => (n.SetChanged = "typing.set.changed", n))(U || {}), Te = /* @__PURE__ */ ((n) => (n.Reaction = "roomReaction", n))(Te || {}), Re = /* @__PURE__ */ ((n) => (n.Reaction = "reaction", n))(Re || {}), x = /* @__PURE__ */ ((n) => (n.Unique = "unique", n.Distinct = "distinct", n.Multiple = "multiple", n))(x || {}), se = /* @__PURE__ */ ((n) => (n.Unique = "reaction:unique.v1", n.Distinct = "reaction:distinct.v1", n.Multiple = "reaction:multiple.v1", n))(se || {});
const hn = {
  "reaction:unique.v1": "unique",
  "reaction:distinct.v1": "distinct",
  "reaction:multiple.v1": "multiple"
  /* Multiple */
};
var R = /* @__PURE__ */ ((n) => (n.Create = "reaction.create", n.Delete = "reaction.delete", n.Summary = "reaction.summary", n))(R || {}), Me = /* @__PURE__ */ ((n) => (n.Updated = "occupancy.updated", n))(Me || {}), G = /* @__PURE__ */ ((n) => (n.Discontinuity = "room.discontinuity", n))(G || {}), ie = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ln(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var W = { exports: {} };
W.exports;
var bt;
function un() {
  return bt || (bt = 1, function(n, e) {
    var t = 200, i = "__lodash_hash_undefined__", a = 9007199254740991, c = "[object Arguments]", u = "[object Array]", f = "[object Boolean]", _ = "[object Date]", m = "[object Error]", d = "[object Function]", w = "[object GeneratorFunction]", Q = "[object Map]", Oe = "[object Number]", le = "[object Object]", De = "[object Promise]", xe = "[object RegExp]", J = "[object Set]", Le = "[object String]", Ne = "[object Symbol]", ue = "[object WeakMap]", Pe = "[object ArrayBuffer]", X = "[object DataView]", qe = "[object Float32Array]", ke = "[object Float64Array]", Ue = "[object Int8Array]", je = "[object Int16Array]", Be = "[object Int32Array]", ze = "[object Uint8Array]", $e = "[object Uint8ClampedArray]", Fe = "[object Uint16Array]", He = "[object Uint32Array]", Ot = /[\\^$.*+?()[\]{}|]/g, Dt = /\w*$/, xt = /^\[object .+?Constructor\]$/, Lt = /^(?:0|[1-9]\d*)$/, g = {};
    g[c] = g[u] = g[Pe] = g[X] = g[f] = g[_] = g[qe] = g[ke] = g[Ue] = g[je] = g[Be] = g[Q] = g[Oe] = g[le] = g[xe] = g[J] = g[Le] = g[Ne] = g[ze] = g[$e] = g[Fe] = g[He] = !0, g[m] = g[d] = g[ue] = !1;
    var Nt = typeof ie == "object" && ie && ie.Object === Object && ie, Pt = typeof self == "object" && self && self.Object === Object && self, C = Nt || Pt || Function("return this")(), Ve = e && !e.nodeType && e, Ge = Ve && !0 && n && !n.nodeType && n, qt = Ge && Ge.exports === Ve;
    function kt(r, s) {
      return r.set(s[0], s[1]), r;
    }
    function Ut(r, s) {
      return r.add(s), r;
    }
    function jt(r, s) {
      for (var o = -1, h = r ? r.length : 0; ++o < h && s(r[o], o, r) !== !1; )
        ;
      return r;
    }
    function Bt(r, s) {
      for (var o = -1, h = s.length, b = r.length; ++o < h; )
        r[b + o] = s[o];
      return r;
    }
    function We(r, s, o, h) {
      for (var b = -1, v = r ? r.length : 0; ++b < v; )
        o = s(o, r[b], b, r);
      return o;
    }
    function zt(r, s) {
      for (var o = -1, h = Array(r); ++o < r; )
        h[o] = s(o);
      return h;
    }
    function $t(r, s) {
      return r?.[s];
    }
    function Ke(r) {
      var s = !1;
      if (r != null && typeof r.toString != "function")
        try {
          s = !!(r + "");
        } catch {
        }
      return s;
    }
    function Qe(r) {
      var s = -1, o = Array(r.size);
      return r.forEach(function(h, b) {
        o[++s] = [b, h];
      }), o;
    }
    function ge(r, s) {
      return function(o) {
        return r(s(o));
      };
    }
    function Je(r) {
      var s = -1, o = Array(r.size);
      return r.forEach(function(h) {
        o[++s] = h;
      }), o;
    }
    var Ft = Array.prototype, Ht = Function.prototype, Y = Object.prototype, de = C["__core-js_shared__"], Xe = function() {
      var r = /[^.]+$/.exec(de && de.keys && de.keys.IE_PROTO || "");
      return r ? "Symbol(src)_1." + r : "";
    }(), Ye = Ht.toString, O = Y.hasOwnProperty, Z = Y.toString, Vt = RegExp(
      "^" + Ye.call(O).replace(Ot, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    ), Ze = qt ? C.Buffer : void 0, et = C.Symbol, tt = C.Uint8Array, Gt = ge(Object.getPrototypeOf, Object), Wt = Object.create, Kt = Y.propertyIsEnumerable, Qt = Ft.splice, rt = Object.getOwnPropertySymbols, Jt = Ze ? Ze.isBuffer : void 0, Xt = ge(Object.keys, Object), _e = $(C, "DataView"), H = $(C, "Map"), pe = $(C, "Promise"), fe = $(C, "Set"), me = $(C, "WeakMap"), V = $(Object, "create"), Yt = k(_e), Zt = k(H), er = k(pe), tr = k(fe), rr = k(me), nt = et ? et.prototype : void 0, it = nt ? nt.valueOf : void 0;
    function P(r) {
      var s = -1, o = r ? r.length : 0;
      for (this.clear(); ++s < o; ) {
        var h = r[s];
        this.set(h[0], h[1]);
      }
    }
    function nr() {
      this.__data__ = V ? V(null) : {};
    }
    function ir(r) {
      return this.has(r) && delete this.__data__[r];
    }
    function sr(r) {
      var s = this.__data__;
      if (V) {
        var o = s[r];
        return o === i ? void 0 : o;
      }
      return O.call(s, r) ? s[r] : void 0;
    }
    function ar(r) {
      var s = this.__data__;
      return V ? s[r] !== void 0 : O.call(s, r);
    }
    function or(r, s) {
      var o = this.__data__;
      return o[r] = V && s === void 0 ? i : s, this;
    }
    P.prototype.clear = nr, P.prototype.delete = ir, P.prototype.get = sr, P.prototype.has = ar, P.prototype.set = or;
    function A(r) {
      var s = -1, o = r ? r.length : 0;
      for (this.clear(); ++s < o; ) {
        var h = r[s];
        this.set(h[0], h[1]);
      }
    }
    function cr() {
      this.__data__ = [];
    }
    function hr(r) {
      var s = this.__data__, o = ee(s, r);
      if (o < 0)
        return !1;
      var h = s.length - 1;
      return o == h ? s.pop() : Qt.call(s, o, 1), !0;
    }
    function lr(r) {
      var s = this.__data__, o = ee(s, r);
      return o < 0 ? void 0 : s[o][1];
    }
    function ur(r) {
      return ee(this.__data__, r) > -1;
    }
    function gr(r, s) {
      var o = this.__data__, h = ee(o, r);
      return h < 0 ? o.push([r, s]) : o[h][1] = s, this;
    }
    A.prototype.clear = cr, A.prototype.delete = hr, A.prototype.get = lr, A.prototype.has = ur, A.prototype.set = gr;
    function B(r) {
      var s = -1, o = r ? r.length : 0;
      for (this.clear(); ++s < o; ) {
        var h = r[s];
        this.set(h[0], h[1]);
      }
    }
    function dr() {
      this.__data__ = {
        hash: new P(),
        map: new (H || A)(),
        string: new P()
      };
    }
    function _r(r) {
      return te(this, r).delete(r);
    }
    function pr(r) {
      return te(this, r).get(r);
    }
    function fr(r) {
      return te(this, r).has(r);
    }
    function mr(r, s) {
      return te(this, r).set(r, s), this;
    }
    B.prototype.clear = dr, B.prototype.delete = _r, B.prototype.get = pr, B.prototype.has = fr, B.prototype.set = mr;
    function z(r) {
      this.__data__ = new A(r);
    }
    function yr() {
      this.__data__ = new A();
    }
    function br(r) {
      return this.__data__.delete(r);
    }
    function wr(r) {
      return this.__data__.get(r);
    }
    function vr(r) {
      return this.__data__.has(r);
    }
    function Sr(r, s) {
      var o = this.__data__;
      if (o instanceof A) {
        var h = o.__data__;
        if (!H || h.length < t - 1)
          return h.push([r, s]), this;
        o = this.__data__ = new B(h);
      }
      return o.set(r, s), this;
    }
    z.prototype.clear = yr, z.prototype.delete = br, z.prototype.get = wr, z.prototype.has = vr, z.prototype.set = Sr;
    function Tr(r, s) {
      var o = we(r) || Wr(r) ? zt(r.length, String) : [], h = o.length, b = !!h;
      for (var v in r)
        O.call(r, v) && !(b && (v == "length" || Fr(v, h))) && o.push(v);
      return o;
    }
    function st(r, s, o) {
      var h = r[s];
      (!(O.call(r, s) && ht(h, o)) || o === void 0 && !(s in r)) && (r[s] = o);
    }
    function ee(r, s) {
      for (var o = r.length; o--; )
        if (ht(r[o][0], s))
          return o;
      return -1;
    }
    function Rr(r, s) {
      return r && at(s, ve(s), r);
    }
    function ye(r, s, o, h, b, v, E) {
      var S;
      if (h && (S = v ? h(r, b, v, E) : h(r)), S !== void 0)
        return S;
      if (!re(r))
        return r;
      var gt = we(r);
      if (gt) {
        if (S = Br(r), !s)
          return kr(r, S);
      } else {
        var F = q(r), dt = F == d || F == w;
        if (Qr(r))
          return Or(r, s);
        if (F == le || F == c || dt && !v) {
          if (Ke(r))
            return v ? r : {};
          if (S = zr(dt ? {} : r), !s)
            return Ur(r, Rr(S, r));
        } else {
          if (!g[F])
            return v ? r : {};
          S = $r(r, F, ye, s);
        }
      }
      E || (E = new z());
      var _t = E.get(r);
      if (_t)
        return _t;
      if (E.set(r, S), !gt)
        var pt = o ? jr(r) : ve(r);
      return jt(pt || r, function(Se, ne) {
        pt && (ne = Se, Se = r[ne]), st(S, ne, ye(Se, s, o, h, ne, r, E));
      }), S;
    }
    function Mr(r) {
      return re(r) ? Wt(r) : {};
    }
    function Ir(r, s, o) {
      var h = s(r);
      return we(r) ? h : Bt(h, o(r));
    }
    function Cr(r) {
      return Z.call(r);
    }
    function Ar(r) {
      if (!re(r) || Vr(r))
        return !1;
      var s = ut(r) || Ke(r) ? Vt : xt;
      return s.test(k(r));
    }
    function Er(r) {
      if (!ct(r))
        return Xt(r);
      var s = [];
      for (var o in Object(r))
        O.call(r, o) && o != "constructor" && s.push(o);
      return s;
    }
    function Or(r, s) {
      if (s)
        return r.slice();
      var o = new r.constructor(r.length);
      return r.copy(o), o;
    }
    function be(r) {
      var s = new r.constructor(r.byteLength);
      return new tt(s).set(new tt(r)), s;
    }
    function Dr(r, s) {
      var o = s ? be(r.buffer) : r.buffer;
      return new r.constructor(o, r.byteOffset, r.byteLength);
    }
    function xr(r, s, o) {
      var h = s ? o(Qe(r), !0) : Qe(r);
      return We(h, kt, new r.constructor());
    }
    function Lr(r) {
      var s = new r.constructor(r.source, Dt.exec(r));
      return s.lastIndex = r.lastIndex, s;
    }
    function Nr(r, s, o) {
      var h = s ? o(Je(r), !0) : Je(r);
      return We(h, Ut, new r.constructor());
    }
    function Pr(r) {
      return it ? Object(it.call(r)) : {};
    }
    function qr(r, s) {
      var o = s ? be(r.buffer) : r.buffer;
      return new r.constructor(o, r.byteOffset, r.length);
    }
    function kr(r, s) {
      var o = -1, h = r.length;
      for (s || (s = Array(h)); ++o < h; )
        s[o] = r[o];
      return s;
    }
    function at(r, s, o, h) {
      o || (o = {});
      for (var b = -1, v = s.length; ++b < v; ) {
        var E = s[b], S = void 0;
        st(o, E, S === void 0 ? r[E] : S);
      }
      return o;
    }
    function Ur(r, s) {
      return at(r, ot(r), s);
    }
    function jr(r) {
      return Ir(r, ve, ot);
    }
    function te(r, s) {
      var o = r.__data__;
      return Hr(s) ? o[typeof s == "string" ? "string" : "hash"] : o.map;
    }
    function $(r, s) {
      var o = $t(r, s);
      return Ar(o) ? o : void 0;
    }
    var ot = rt ? ge(rt, Object) : Yr, q = Cr;
    (_e && q(new _e(new ArrayBuffer(1))) != X || H && q(new H()) != Q || pe && q(pe.resolve()) != De || fe && q(new fe()) != J || me && q(new me()) != ue) && (q = function(r) {
      var s = Z.call(r), o = s == le ? r.constructor : void 0, h = o ? k(o) : void 0;
      if (h)
        switch (h) {
          case Yt:
            return X;
          case Zt:
            return Q;
          case er:
            return De;
          case tr:
            return J;
          case rr:
            return ue;
        }
      return s;
    });
    function Br(r) {
      var s = r.length, o = r.constructor(s);
      return s && typeof r[0] == "string" && O.call(r, "index") && (o.index = r.index, o.input = r.input), o;
    }
    function zr(r) {
      return typeof r.constructor == "function" && !ct(r) ? Mr(Gt(r)) : {};
    }
    function $r(r, s, o, h) {
      var b = r.constructor;
      switch (s) {
        case Pe:
          return be(r);
        case f:
        case _:
          return new b(+r);
        case X:
          return Dr(r, h);
        case qe:
        case ke:
        case Ue:
        case je:
        case Be:
        case ze:
        case $e:
        case Fe:
        case He:
          return qr(r, h);
        case Q:
          return xr(r, h, o);
        case Oe:
        case Le:
          return new b(r);
        case xe:
          return Lr(r);
        case J:
          return Nr(r, h, o);
        case Ne:
          return Pr(r);
      }
    }
    function Fr(r, s) {
      return s = s ?? a, !!s && (typeof r == "number" || Lt.test(r)) && r > -1 && r % 1 == 0 && r < s;
    }
    function Hr(r) {
      var s = typeof r;
      return s == "string" || s == "number" || s == "symbol" || s == "boolean" ? r !== "__proto__" : r === null;
    }
    function Vr(r) {
      return !!Xe && Xe in r;
    }
    function ct(r) {
      var s = r && r.constructor, o = typeof s == "function" && s.prototype || Y;
      return r === o;
    }
    function k(r) {
      if (r != null) {
        try {
          return Ye.call(r);
        } catch {
        }
        try {
          return r + "";
        } catch {
        }
      }
      return "";
    }
    function Gr(r) {
      return ye(r, !0, !0);
    }
    function ht(r, s) {
      return r === s || r !== r && s !== s;
    }
    function Wr(r) {
      return Kr(r) && O.call(r, "callee") && (!Kt.call(r, "callee") || Z.call(r) == c);
    }
    var we = Array.isArray;
    function lt(r) {
      return r != null && Jr(r.length) && !ut(r);
    }
    function Kr(r) {
      return Xr(r) && lt(r);
    }
    var Qr = Jt || Zr;
    function ut(r) {
      var s = re(r) ? Z.call(r) : "";
      return s == d || s == w;
    }
    function Jr(r) {
      return typeof r == "number" && r > -1 && r % 1 == 0 && r <= a;
    }
    function re(r) {
      var s = typeof r;
      return !!r && (s == "object" || s == "function");
    }
    function Xr(r) {
      return !!r && typeof r == "object";
    }
    function ve(r) {
      return lt(r) ? Tr(r) : Er(r);
    }
    function Yr() {
      return [];
    }
    function Zr() {
      return !1;
    }
    n.exports = Gr;
  }(W, W.exports)), W.exports;
}
var gn = un();
const D = /* @__PURE__ */ ln(gn);
class L {
  constructor({
    serial: e,
    clientId: t,
    text: i,
    metadata: a,
    headers: c,
    action: u,
    version: f,
    createdAt: _,
    timestamp: m,
    reactions: d,
    operation: w
  }) {
    this.serial = e, this.clientId = t, this.text = i, this.metadata = a, this.headers = c, this.action = u, this.version = f, this.createdAt = _, this.timestamp = m, this.reactions = d, this.operation = w, Object.freeze(this.reactions), Object.freeze(this.reactions.multiple), Object.freeze(this.reactions.distinct), Object.freeze(this.reactions.unique), Object.freeze(this);
  }
  get isUpdated() {
    return this.action === y.MessageUpdate;
  }
  get isDeleted() {
    return this.action === y.MessageDelete;
  }
  get updatedBy() {
    return this.isUpdated ? this.operation?.clientId : void 0;
  }
  get deletedBy() {
    return this.isDeleted ? this.operation?.clientId : void 0;
  }
  get updatedAt() {
    return this.isUpdated ? this.timestamp : void 0;
  }
  get deletedAt() {
    return this.isDeleted ? this.timestamp : void 0;
  }
  isOlderVersionOf(e) {
    return this.equal(e) ? this.version < e.version : !1;
  }
  isNewerVersionOf(e) {
    return this.equal(e) ? this.version > e.version : !1;
  }
  isSameVersionAs(e) {
    return this.equal(e) ? this.version === e.version : !1;
  }
  before(e) {
    return this.serial < e.serial;
  }
  after(e) {
    return this.serial > e.serial;
  }
  equal(e) {
    return this.serial === e.serial;
  }
  isSameAs(e) {
    return this.equal(e);
  }
  with(e) {
    if ("serial" in e)
      return this._getLatestMessageVersion(e);
    if (e.type === N.Created)
      throw new l.ErrorInfo("cannot apply a created event to a message", 4e4, 400);
    if (e.type === R.Summary) {
      if (e.summary.messageSerial !== this.serial)
        throw new l.ErrorInfo("cannot apply event for a different message", 4e4, 400);
      const t = {
        unique: D(e.summary.unique),
        distinct: D(e.summary.distinct),
        multiple: D(e.summary.multiple)
      };
      return L._clone(this, { reactions: t });
    }
    return this._getLatestMessageVersion(e.message);
  }
  /**
   * Get the latest message version, based on the event.
   * If "this" is the latest version, return "this", otherwise clone the message and apply the reactions.
   *
   * @param message The message to get the latest version of
   * @returns The latest message version
   */
  _getLatestMessageVersion(e) {
    if (e.serial !== this.serial)
      throw new l.ErrorInfo("cannot apply event for a different message", 4e4, 400);
    return this.version >= e.version ? this : L._clone(e, { reactions: this.reactions });
  }
  // Clone a message, optionally replace the given fields
  static _clone(e, t) {
    return new L({
      serial: t?.serial ?? e.serial,
      clientId: t?.clientId ?? e.clientId,
      text: t?.text ?? e.text,
      metadata: t?.metadata ?? D(e.metadata),
      headers: t?.headers ?? D(e.headers),
      action: t?.action ?? e.action,
      version: t?.version ?? e.version,
      createdAt: t?.createdAt ?? e.createdAt,
      timestamp: t?.timestamp ?? e.timestamp,
      reactions: t?.reactions ?? D(e.reactions),
      operation: t?.operation ?? D(e.operation)
    });
  }
  copy(e = {}) {
    return L._clone(this, e);
  }
}
function Ee() {
  return {
    unique: {},
    distinct: {},
    multiple: {}
  };
}
const dn = (n) => {
  const e = n;
  if (!e.data)
    throw new l.ErrorInfo("received incoming message without data", 5e4, 500);
  if (!e.clientId)
    throw new l.ErrorInfo("received incoming message without clientId", 5e4, 500);
  if (!e.extras)
    throw new l.ErrorInfo("received incoming message without extras", 5e4, 500);
  if (e.action !== y.MessageDelete && e.data.text === void 0)
    throw new l.ErrorInfo("received incoming message without text", 5e4, 500);
  if (e.action !== y.MessageDelete && !e.extras.headers)
    throw new l.ErrorInfo("received incoming message without headers", 5e4, 500);
  if (e.action !== y.MessageDelete && !e.data.metadata)
    throw new l.ErrorInfo("received incoming message without metadata", 5e4, 500);
  if (!e.serial)
    throw new l.ErrorInfo("received incoming message without serial", 5e4, 500);
  if (!e.version)
    throw new l.ErrorInfo("received incoming message without version", 5e4, 500);
  if (!e.createdAt)
    throw new l.ErrorInfo("received incoming message without createdAt", 5e4, 500);
  if (!e.timestamp)
    throw new l.ErrorInfo("received incoming message without timestamp", 5e4, 500);
  switch (e.action) {
    case y.MessageCreate:
    case y.MessageUpdate:
    case y.MessageDelete:
      break;
    default:
      throw new l.ErrorInfo(`received incoming message with unhandled action; ${e.action}`, 5e4, 500);
  }
  const t = e.action === y.MessageDelete ? {} : e.data, i = e.action === y.MessageDelete ? {} : e.extras;
  return new L({
    serial: e.serial,
    clientId: e.clientId,
    text: t.text ?? "",
    metadata: t.metadata ?? {},
    headers: i.headers ?? {},
    action: e.action,
    version: e.version,
    createdAt: new Date(e.createdAt),
    timestamp: new Date(e.timestamp),
    reactions: Ee(),
    operation: e.operation
  });
}, oe = (n) => {
  let e = "";
  if (typeof n == "string")
    e = n;
  else
    try {
      "serial" in n && (e = n.serial);
    } catch {
    }
  if (e === "")
    throw new l.ErrorInfo("invalid serial; must be string or object with serial property", 4e4, 400);
  return e;
}, _n = {
  "annotation.create": R.Create,
  "annotation.delete": R.Delete
};
class It {
  constructor(e, t, i, a, c) {
    this._logger = e, this._options = t, this._api = i, this._roomName = a, this._channel = c, this._emitter = new I(), c.subscribe(this._processMessageEvent.bind(this)), this._options?.rawMessageReactions && c.annotations.subscribe(this._processAnnotationEvent.bind(this)), this._defaultType = this._options?.defaultMessageReactionType ?? x.Distinct;
  }
  _processAnnotationEvent(e) {
    if (this._logger.trace("MessagesReactions._processAnnotationEvent();", { event: e }), !e.messageSerial) {
      this._logger.warn(
        "DefaultMessageReactions._processAnnotationEvent(); received event with missing messageSerial",
        {
          event: e
        }
      );
      return;
    }
    const t = hn[e.type];
    if (!t) {
      this._logger.debug("DefaultMessageReactions._processAnnotationEvent(); received event with unknown type", {
        event: e
      });
      return;
    }
    const i = _n[e.action];
    if (!i) {
      this._logger.warn("DefaultMessageReactions._processAnnotationEvent(); received event with unknown action", {
        event: e
      });
      return;
    }
    let a = e.name;
    if (!a)
      if (i === R.Delete && t === x.Unique)
        a = "";
      else
        return;
    const c = {
      type: i,
      timestamp: new Date(e.timestamp),
      reaction: {
        messageSerial: e.messageSerial,
        type: t,
        name: a,
        clientId: e.clientId ?? ""
      }
    };
    e.count ? c.reaction.count = e.count : i === R.Create && t === x.Multiple && (c.reaction.count = 1), this._emitter.emit(i, c);
  }
  _processMessageEvent(e) {
    if (this._logger.trace("MessagesReactions._processMessageEvent();", { event: e }), e.action !== y.MessageAnnotationSummary)
      return;
    if (e.summary || (e.summary = {}), !e.serial) {
      this._logger.warn("DefaultMessageReactions._processMessageEvent(); received summary without serial", {
        event: e
      });
      return;
    }
    const t = e.summary[se.Unique] ?? {}, i = e.summary[se.Distinct] ?? {}, a = e.summary[se.Multiple] ?? {};
    this._emitter.emit(R.Summary, {
      type: R.Summary,
      summary: {
        messageSerial: e.serial,
        unique: t,
        distinct: i,
        multiple: a
      }
    });
  }
  /**
   * @inheritDoc
   */
  send(e, t) {
    this._logger.trace("MessagesReactions.add();", { messageSerial: e, params: t });
    const i = oe(e);
    let { type: a, count: c } = t;
    a || (a = this._defaultType), a === x.Multiple && !c && (c = 1);
    const u = { type: a, name: t.name };
    return c && (u.count = c), this._api.addMessageReaction(this._roomName, i, u);
  }
  /**
   * @inheritDoc
   */
  delete(e, t) {
    this._logger.trace("MessagesReactions.delete();", { messageSerial: e, params: t });
    const i = oe(e);
    let a = t?.type;
    if (a || (a = this._defaultType), a !== x.Unique && !t?.name)
      throw new l.ErrorInfo(`cannot delete reaction of type ${a} without a name`, 40001, 400);
    const c = { type: a };
    return a !== x.Unique && (c.name = t?.name), this._api.deleteMessageReaction(this._roomName, i, c);
  }
  /**
   * @inheritDoc
   */
  subscribe(e) {
    this._logger.trace("MessagesReactions.subscribe();");
    const t = M(e);
    return this._emitter.on(R.Summary, t), {
      unsubscribe: () => {
        this._emitter.off(t);
      }
    };
  }
  /**
   * @inheritDoc
   */
  subscribeRaw(e) {
    if (this._logger.trace("MessagesReactions.subscribeRaw();"), !this._options?.rawMessageReactions)
      throw new l.ErrorInfo("Raw message reactions are not enabled", 40001, 400);
    const t = M(e);
    return this._emitter.on([R.Create, R.Delete], t), {
      unsubscribe: () => {
        this._emitter.off(t);
      }
    };
  }
  /**
   * Merges the channel options to add support for message reactions.
   *
   * @param roomOptions The room options to merge for.
   * @returns A function that merges the channel options for the room with the ones required for presence.
   */
  static channelOptionMerger(e) {
    return (t) => (t.modes.includes("ANNOTATION_PUBLISH") || t.modes.push("ANNOTATION_PUBLISH"), e.messages.rawMessageReactions && !t.modes.includes("ANNOTATION_SUBSCRIBE") && t.modes.push("ANNOTATION_SUBSCRIBE"), t);
  }
}
const Ie = (n) => {
  const e = {
    ...Ee(),
    ...n.reactions
  }, t = Object.values(y).includes(n.action) ? n.action : y.MessageCreate;
  return new L({
    ...n,
    action: t,
    createdAt: new Date(n.createdAt),
    timestamp: new Date(n.timestamp),
    reactions: e
  });
}, pn = /* @__PURE__ */ new Map([
  [y.MessageCreate, N.Created],
  [y.MessageUpdate, N.Updated],
  [y.MessageDelete, N.Deleted]
]);
var Ce = /* @__PURE__ */ ((n) => (n.OldestFirst = "oldestFirst", n.NewestFirst = "newestFirst", n))(Ce || {});
class fn {
  /**
   * Constructs a new `DefaultMessages` instance.
   * @param roomName The unique identifier of the room.
   * @param channel An instance of the Realtime channel for the room.
   * @param chatApi An instance of the ChatApi.
   * @param clientId The client ID of the user.
   * @param logger An instance of the Logger.
   */
  constructor(e, t, i, a, c, u) {
    this._emitter = new I(), this._roomName = e, this._options = t, this._channel = i, this._chatApi = a, this._clientId = c, this._logger = u, this._listenerSubscriptionPoints = /* @__PURE__ */ new Map(), this.reactions = new It(this._logger, t, this._chatApi, this._roomName, this._channel), this._applyChannelSubscriptions();
  }
  /**
   * Sets up channel subscriptions for messages.
   */
  _applyChannelSubscriptions() {
    this._channel.subscribe([Rt.ChatMessage], this._processEvent.bind(this)), this._channel.on("attached", (e) => {
      this._handleAttach(e.resumed);
    }), this._channel.on("update", (e) => {
      e.current === "attached" && e.previous === "attached" && this._handleAttach(e.resumed);
    });
  }
  /**
   * @inheritdoc Messages
   */
  async _getBeforeSubscriptionStart(e, t) {
    this._logger.trace("DefaultSubscriptionManager.getBeforeSubscriptionStart();");
    const i = this._listenerSubscriptionPoints.get(e);
    if (i === void 0)
      throw this._logger.error(
        "DefaultSubscriptionManager.getBeforeSubscriptionStart(); listener has not been subscribed yet"
      ), new l.ErrorInfo(
        "cannot query history; listener has not been subscribed yet",
        4e4,
        400
      );
    const a = await i;
    return this._chatApi.getMessages(this._roomName, {
      ...t,
      orderBy: "newestFirst",
      ...a
    });
  }
  /**
   * Handle the case where the channel experiences a detach and reattaches.
   */
  _handleAttach(e) {
    if (this._logger.trace("DefaultSubscriptionManager.handleAttach();"), e) return;
    const t = this._subscribeAtChannelAttach();
    for (const [i] of this._listenerSubscriptionPoints.entries())
      this._listenerSubscriptionPoints.set(i, t);
  }
  /**
   * Create a promise that resolves with the attachSerial of the channel or the serial of the latest message.
   */
  async _resolveSubscriptionStart() {
    const e = this._getChannelProperties();
    if (e.state === "attached") {
      if (e.properties.channelSerial)
        return { fromSerial: e.properties.channelSerial };
      throw this._logger.error("DefaultSubscriptionManager.handleAttach(); channelSerial is undefined"), new l.ErrorInfo("channel is attached, but channelSerial is not defined", 4e4, 400);
    }
    return this._subscribeAtChannelAttach();
  }
  _getChannelProperties() {
    return this._channel;
  }
  async _subscribeAtChannelAttach() {
    const e = this._getChannelProperties();
    return new Promise((t, i) => {
      e.state === "attached" && (this._logger.debug("Messages._subscribeAtChannelAttach(); channel is attached already, using attachSerial", {
        attachSerial: e.properties.attachSerial
      }), e.properties.attachSerial ? t({ fromSerial: e.properties.attachSerial }) : (this._logger.error("DefaultSubscriptionManager.handleAttach(); attachSerial is undefined"), i(
        new l.ErrorInfo("channel is attached, but attachSerial is not defined", 4e4, 400)
      ))), e.once("attached", () => {
        this._logger.debug("Messages._subscribeAtChannelAttach(); channel is now attached, using attachSerial", {
          attachSerial: e.properties.attachSerial
        }), e.properties.attachSerial ? t({ fromSerial: e.properties.attachSerial }) : (this._logger.error("DefaultSubscriptionManager.handleAttach(); attachSerial is undefined"), i(
          new l.ErrorInfo("channel is attached, but attachSerial is not defined", 4e4, 400)
        ));
      });
    });
  }
  /**
   * @inheritdoc Messages
   */
  async history(e) {
    return this._logger.trace("Messages.query();"), this._chatApi.getMessages(this._roomName, e);
  }
  /**
   * @inheritdoc Messages
   */
  async send(e) {
    this._logger.trace("Messages.send();", { params: e });
    const { text: t, metadata: i, headers: a } = e, c = await this._chatApi.sendMessage(this._roomName, { text: t, headers: a, metadata: i });
    return new L({
      serial: c.serial,
      clientId: this._clientId,
      text: t,
      metadata: i ?? {},
      headers: a ?? {},
      action: y.MessageCreate,
      version: c.serial,
      createdAt: new Date(c.createdAt),
      timestamp: new Date(c.createdAt),
      // timestamp is the same as createdAt for new messages
      reactions: Ee()
    });
  }
  /**
   * @inheritdoc Messages
   */
  async delete(e, t) {
    this._logger.trace("Messages.delete();", { params: t }), e = oe(e), this._logger.debug("Messages.delete(); serial", { serial: e });
    const i = await this._chatApi.deleteMessage(this._roomName, e, t);
    return Ie(i.message);
  }
  /**
   * @inheritdoc Messages
   */
  async update(e, t, i) {
    this._logger.trace("Messages.update();", { updateParams: t, details: i }), e = oe(e), this._logger.debug("Messages.update(); serial", { serial: e });
    const a = await this._chatApi.updateMessage(this._roomName, e, {
      message: {
        text: t.text,
        metadata: t.metadata,
        headers: t.headers
      },
      ...i
    });
    return this._logger.debug("Messages.update(); message update successfully", { updateParams: t }), Ie(a.message);
  }
  /**
   * @inheritdoc Messages
   */
  subscribe(e) {
    this._logger.trace("Messages.subscribe();");
    const t = M(e);
    this._emitter.on(
      [N.Created, N.Updated, N.Deleted],
      t
    );
    const i = this._resolveSubscriptionStart();
    return i.catch(() => {
      this._logger.debug("Messages.subscribe(); subscription point was not resolved before the room was released");
    }), this._listenerSubscriptionPoints.set(t, i), {
      unsubscribe: () => {
        this._listenerSubscriptionPoints.delete(t), this._logger.trace("Messages.unsubscribe();"), this._emitter.off(t);
      },
      historyBeforeSubscribe: (a) => this._getBeforeSubscriptionStart(t, a)
    };
  }
  _processEvent(e) {
    this._logger.trace("Messages._processEvent();", {
      channelEventMessage: e
    });
    const { action: t } = e, i = pn.get(t);
    if (!i) {
      this._logger.debug("Messages._processEvent(); received unknown message action", { action: t });
      return;
    }
    const a = this._parseNewMessage(e);
    a && this._emitter.emit(i, { type: i, message: a });
  }
  /**
   * Validate the realtime message and convert it to a chat message.
   */
  _parseNewMessage(e) {
    try {
      return dn(e);
    } catch (t) {
      this._logger.error("failed to parse incoming message;", { channelEventMessage: e, error: t });
    }
  }
}
class mn {
  constructor(e, t) {
    this._apiProtocolVersion = 3, this._realtime = e, this._logger = t;
  }
  async getMessages(e, t) {
    e = encodeURIComponent(e);
    const i = { ...t };
    if (t.orderBy)
      switch (t.orderBy) {
        case Ce.NewestFirst: {
          i.direction = "backwards";
          break;
        }
        case Ce.OldestFirst: {
          i.direction = "forwards";
          break;
        }
        default:
          throw new l.ErrorInfo(`invalid orderBy value: ${t.orderBy}`, 4e4, 400);
      }
    const a = await this._makeAuthorizedPaginatedRequest(
      `/chat/v3/rooms/${e}/messages`,
      i
    );
    return this._recursivePaginateMessages(a);
  }
  _recursivePaginateMessages(e) {
    const t = {};
    return t.items = e.items.map((i) => Ie(i)), t.next = () => e.next().then((i) => i ? this._recursivePaginateMessages(i) : null), t.first = () => e.first().then((i) => this._recursivePaginateMessages(i)), t.current = () => e.current().then((i) => this._recursivePaginateMessages(i)), t.hasNext = () => e.hasNext(), t.isLast = () => e.isLast(), { ...e, ...t };
  }
  deleteMessage(e, t, i) {
    const a = {
      description: i?.description,
      metadata: i?.metadata
    };
    return t = encodeURIComponent(t), e = encodeURIComponent(e), this._makeAuthorizedRequest(
      `/chat/v3/rooms/${e}/messages/${t}/delete`,
      "POST",
      a,
      {}
    );
  }
  sendMessage(e, t) {
    const i = { text: t.text };
    return t.metadata && (i.metadata = t.metadata), t.headers && (i.headers = t.headers), e = encodeURIComponent(e), this._makeAuthorizedRequest(`/chat/v3/rooms/${e}/messages`, "POST", i);
  }
  updateMessage(e, t, i) {
    const a = encodeURIComponent(t);
    return e = encodeURIComponent(e), this._makeAuthorizedRequest(
      `/chat/v3/rooms/${e}/messages/${a}`,
      "PUT",
      i
    );
  }
  addMessageReaction(e, t, i) {
    const a = encodeURIComponent(t);
    return e = encodeURIComponent(e), this._makeAuthorizedRequest(`/chat/v3/rooms/${e}/messages/${a}/reactions`, "POST", i);
  }
  deleteMessageReaction(e, t, i) {
    const a = encodeURIComponent(t);
    return e = encodeURIComponent(e), this._makeAuthorizedRequest(
      `/chat/v3/rooms/${e}/messages/${a}/reactions`,
      "DELETE",
      void 0,
      i
    );
  }
  getOccupancy(e) {
    return e = encodeURIComponent(e), this._makeAuthorizedRequest(`/chat/v3/rooms/${e}/occupancy`, "GET");
  }
  async _makeAuthorizedRequest(e, t, i, a) {
    const c = await this._realtime.request(t, e, this._apiProtocolVersion, a, i);
    if (!c.success)
      throw this._logger.error("ChatApi._makeAuthorizedRequest(); failed to make request", {
        url: e,
        statusCode: c.statusCode,
        errorCode: c.errorCode,
        errorMessage: c.errorMessage
      }), new l.ErrorInfo(c.errorMessage, c.errorCode, c.statusCode);
    return c.items[0];
  }
  async _makeAuthorizedPaginatedRequest(e, t, i) {
    const a = await this._realtime.request("GET", e, this._apiProtocolVersion, t, i);
    if (!a.success)
      throw this._logger.error("ChatApi._makeAuthorizedPaginatedRequest(); failed to make request", {
        url: e,
        statusCode: a.statusCode,
        errorCode: a.errorCode,
        errorMessage: a.errorMessage
      }), new l.ErrorInfo(a.errorMessage, a.errorCode, a.statusCode);
    return a;
  }
}
var j = /* @__PURE__ */ ((n) => (n[n.BadRequest = 4e4] = "BadRequest", n[n.MessageRejectedByBeforePublishRule = 42211] = "MessageRejectedByBeforePublishRule", n[n.MessageRejectedByModeration = 42213] = "MessageRejectedByModeration", n[n.RoomDiscontinuity = 102100] = "RoomDiscontinuity", n[n.RoomInFailedState = 102101] = "RoomInFailedState", n[n.RoomIsReleasing = 102102] = "RoomIsReleasing", n[n.RoomIsReleased = 102103] = "RoomIsReleased", n[n.RoomReleasedBeforeOperationCompleted = 102106] = "RoomReleasedBeforeOperationCompleted", n))(j || {});
const Gn = (n, e) => n.code === e, yn = () => Math.random().toString(36).slice(2), bn = (n) => `${n}::$chat`, ce = "0.10.0", wn = `chat-js/${ce}`, vn = `chat-react/${ce}`, Ct = ["PUBLISH", "SUBSCRIBE"], Sn = {
  params: { agent: wn },
  attachOnSubscribe: !1,
  modes: Ct
}, Tn = {
  params: { agent: vn },
  attachOnSubscribe: !1,
  modes: Ct
};
class Rn {
  constructor(e, t, i, a) {
    i.trace("ChannelManager();", { isReact: a }), this._realtime = t, this._logger = i, this._isReact = a, this._registeredOptions = this._defaultChannelOptions(), this._channelId = bn(e);
  }
  mergeOptions(e) {
    if (this._logger.trace("ChannelManager.mergeOptions();"), this._resolvedChannel)
      throw this._logger.error("channel options cannot be modified after the channel has been requested"), new l.ErrorInfo("channel options cannot be modified after the channel has been requested", 4e4, 400);
    this._registeredOptions = e(this._registeredOptions);
  }
  get() {
    return this._logger.trace("ChannelManager.get();"), this._resolvedChannel ??= this._realtime.channels.get(this._channelId, this._registeredOptions), this._resolvedChannel;
  }
  release() {
    this._logger.trace("ChannelManager.release();", { channelId: this._channelId }), this._resolvedChannel && this._realtime.channels.release(this._channelId);
  }
  _defaultChannelOptions() {
    this._logger.trace("ChannelManager._defaultChannelOptions();");
    const e = this._isReact ? Tn : Sn;
    return this._logger.trace(this._isReact ? "using react channel options" : "using default channel options"), { ...e, modes: [...e.modes ?? []] };
  }
}
class wt {
  /**
   * Constructs a new `DefaultOccupancy` instance.
   * @param roomName The unique identifier of the room.
   * @param channel An instance of the Realtime channel.
   * @param chatApi An instance of the ChatApi.
   * @param logger An instance of the Logger.
   * @param roomOptions The room options.
   */
  constructor(e, t, i, a, c) {
    this._emitter = new I(), this._roomName = e, this._channel = t, this._chatApi = i, this._logger = a, this._roomOptions = c, this._applyChannelSubscriptions();
  }
  /**
   * Sets up channel subscriptions for occupancy.
   */
  _applyChannelSubscriptions() {
    this._channel.subscribe([Mt.Occupancy], this._internalOccupancyListener.bind(this));
  }
  /**
   * @inheritdoc Occupancy
   */
  subscribe(e) {
    if (this._logger.trace("Occupancy.subscribe();"), !this._roomOptions.occupancy.enableEvents)
      throw new l.ErrorInfo(
        "cannot subscribe to occupancy; occupancy events are not enabled in room options",
        4e4,
        400
      );
    const t = M(e);
    return this._emitter.on(t), {
      unsubscribe: () => {
        this._logger.trace("Occupancy.unsubscribe();"), this._emitter.off(t);
      }
    };
  }
  /**
   * @inheritdoc Occupancy
   */
  async get() {
    return this._logger.trace("Occupancy.get();"), this._chatApi.getOccupancy(this._roomName);
  }
  /**
   * @inheritdoc Occupancy
   */
  current() {
    if (this._logger.trace("Occupancy.current();"), !this._roomOptions.occupancy.enableEvents)
      throw new l.ErrorInfo(
        "cannot get current occupancy; occupancy events are not enabled in room options",
        4e4,
        400
      );
    return this._latestOccupancyData;
  }
  /**
   * An internal listener that listens for occupancy events from the underlying channel and translates them into
   * occupancy events for the public API.
   */
  _internalOccupancyListener(e) {
    if (this._logger.trace("Occupancy._internalOccupancyListener();", e), typeof e.data != "object") {
      this._logger.error(
        "Occupancy._internalOccupancyListener(); invalid occupancy event received; data is not an object",
        e
      );
      return;
    }
    const { metrics: t } = e.data;
    if (t === void 0) {
      this._logger.error(
        "Occupancy._internalOccupancyListener(); invalid occupancy event received; metrics is missing",
        e
      );
      return;
    }
    const { connections: i, presenceMembers: a } = t;
    if (i === void 0) {
      this._logger.error(
        "Occupancy._internalOccupancyListener(); invalid occupancy event received; connections is missing",
        e
      );
      return;
    }
    if (!Number.isInteger(i)) {
      this._logger.error(
        "Occupancy._internalOccupancyListener(); invalid occupancy event received; connections is not a number",
        e
      );
      return;
    }
    if (a === void 0) {
      this._logger.error(
        "Occupancy._internalOccupancyListener(); invalid occupancy event received; presenceMembers is missing",
        e
      );
      return;
    }
    if (!Number.isInteger(a)) {
      this._logger.error(
        "Occupancy._internalOccupancyListener(); invalid occupancy event received; presenceMembers is not a number",
        e
      );
      return;
    }
    this._latestOccupancyData = {
      connections: i,
      presenceMembers: a
    }, this._emitter.emit(Me.Updated, {
      type: Me.Updated,
      occupancy: this._latestOccupancyData
    });
  }
  /**
   * Merges the channel options for the room with the ones required for occupancy.
   *
   * @returns A function that merges the channel options for the room with the ones required for occupancy.
   */
  static channelOptionMerger(e) {
    return (t) => e.occupancy.enableEvents ? { ...t, params: { ...t.params, occupancy: "metrics" } } : t;
  }
}
class vt {
  /**
   * Constructs a new `DefaultPresence` instance.
   * @param channel The Realtime channel instance.
   * @param clientId The client ID, attached to presences messages as an identifier of the sender.
   * A channel can have multiple connections using the same clientId.
   * @param logger An instance of the Logger.
   * @param options The room options.
   */
  constructor(e, t, i, a) {
    this._emitter = new I(), this.subscribeToEvents = (c) => {
      try {
        const u = c.data;
        this._emitter.emit(c.action, {
          type: c.action,
          member: {
            clientId: c.clientId,
            data: u.userCustomData,
            extras: c.extras,
            updatedAt: c.timestamp
          }
        });
      } catch (u) {
        throw this._logger.error("unable to handle presence event: not a valid presence event", { action: c.action }), new l.ErrorInfo(
          `unable to handle ${c.action} presence event: not a valid presence event`,
          5e4,
          500,
          u.message
        );
      }
    }, this._channel = e, this._clientId = t, this._logger = i, this._options = a, this._applyChannelSubscriptions();
  }
  /**
   * Sets up channel subscriptions for presence.
   */
  _applyChannelSubscriptions() {
    this._channel.presence.subscribe(this.subscribeToEvents.bind(this));
  }
  /**
   * @inheritDoc
   */
  async get(e) {
    return this._logger.trace("Presence.get()", { params: e }), this._assertChannelState(), (await this._channel.presence.get(e)).map((i) => ({
      clientId: i.clientId,
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      data: i.data?.userCustomData,
      updatedAt: i.timestamp,
      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
      extras: i.extras
    }));
  }
  /**
   * @inheritDoc
   */
  async isUserPresent(e) {
    return this._logger.trace("Presence.isUserPresent()", { clientId: e }), this._assertChannelState(), (await this._channel.presence.get({ clientId: e })).length > 0;
  }
  /**
   * @inheritDoc
   */
  async enter(e) {
    this._logger.trace("Presence.enter()", { data: e }), this._assertChannelState();
    const t = {
      userCustomData: e
    };
    return this._channel.presence.enterClient(this._clientId, t);
  }
  /**
   * @inheritDoc
   */
  async update(e) {
    this._logger.trace("Presence.update()", { data: e }), this._assertChannelState();
    const t = {
      userCustomData: e
    };
    return this._channel.presence.updateClient(this._clientId, t);
  }
  /**
   * @inheritDoc
   */
  async leave(e) {
    this._logger.trace("Presence.leave()", { data: e }), this._assertChannelState();
    const t = {
      userCustomData: e
    };
    return this._channel.presence.leaveClient(this._clientId, t);
  }
  subscribe(e, t) {
    if (this._logger.trace("Presence.subscribe(); listenerOrEvents", { listenerOrEvents: e }), !this._options.presence.enableEvents)
      throw this._logger.error("could not subscribe to presence; presence events are not enabled"), new l.ErrorInfo("could not subscribe to presence; presence events are not enabled", 4e4, 400);
    if (!e && !t)
      throw this._logger.error("could not subscribe to presence; invalid arguments"), new l.ErrorInfo("could not subscribe listener: invalid arguments", 4e4, 400);
    if (t) {
      const i = M(t);
      return this._emitter.on(e, i), {
        unsubscribe: () => {
          this._logger.trace("Presence.unsubscribe();", { events: e }), this._emitter.off(i);
        }
      };
    } else {
      const i = M(e);
      return this._emitter.on(i), {
        unsubscribe: () => {
          this._logger.trace("Presence.unsubscribe();"), this._emitter.off(i);
        }
      };
    }
  }
  /**
   * Merges the channel options for the room with the ones required for presence.
   *
   * @param roomOptions The room options to merge for.
   * @returns A function that merges the channel options for the room with the ones required for presence.
   */
  static channelOptionMerger(e) {
    return (t) => (t.modes.includes("PRESENCE") || t.modes.push("PRESENCE"), e.presence.enableEvents && !t.modes.includes("PRESENCE_SUBSCRIBE") && t.modes.push("PRESENCE_SUBSCRIBE"), t);
  }
  _assertChannelState() {
    if (this._channel.state !== "attaching" && this._channel.state !== "attached")
      throw this._logger.error("could not perform presence operation; room is not attached"), new l.ErrorInfo("could not perform presence operation; room is not attached", 4e4, 400);
  }
}
const ae = new Error("request for lock canceled");
var Mn = function(n, e, t, i) {
  function a(c) {
    return c instanceof t ? c : new t(function(u) {
      u(c);
    });
  }
  return new (t || (t = Promise))(function(c, u) {
    function f(d) {
      try {
        m(i.next(d));
      } catch (w) {
        u(w);
      }
    }
    function _(d) {
      try {
        m(i.throw(d));
      } catch (w) {
        u(w);
      }
    }
    function m(d) {
      d.done ? c(d.value) : a(d.value).then(f, _);
    }
    m((i = i.apply(n, e || [])).next());
  });
};
class In {
  constructor(e, t = ae) {
    this._value = e, this._cancelError = t, this._queue = [], this._weightedWaiters = [];
  }
  acquire(e = 1, t = 0) {
    if (e <= 0)
      throw new Error(`invalid weight ${e}: must be positive`);
    return new Promise((i, a) => {
      const c = { resolve: i, reject: a, weight: e, priority: t }, u = At(this._queue, (f) => t <= f.priority);
      u === -1 && e <= this._value ? this._dispatchItem(c) : this._queue.splice(u + 1, 0, c);
    });
  }
  runExclusive(e) {
    return Mn(this, arguments, void 0, function* (t, i = 1, a = 0) {
      const [c, u] = yield this.acquire(i, a);
      try {
        return yield t(c);
      } finally {
        u();
      }
    });
  }
  waitForUnlock(e = 1, t = 0) {
    if (e <= 0)
      throw new Error(`invalid weight ${e}: must be positive`);
    return this._couldLockImmediately(e, t) ? Promise.resolve() : new Promise((i) => {
      this._weightedWaiters[e - 1] || (this._weightedWaiters[e - 1] = []), Cn(this._weightedWaiters[e - 1], { resolve: i, priority: t });
    });
  }
  isLocked() {
    return this._value <= 0;
  }
  getValue() {
    return this._value;
  }
  setValue(e) {
    this._value = e, this._dispatchQueue();
  }
  release(e = 1) {
    if (e <= 0)
      throw new Error(`invalid weight ${e}: must be positive`);
    this._value += e, this._dispatchQueue();
  }
  cancel() {
    this._queue.forEach((e) => e.reject(this._cancelError)), this._queue = [];
  }
  _dispatchQueue() {
    for (this._drainUnlockWaiters(); this._queue.length > 0 && this._queue[0].weight <= this._value; )
      this._dispatchItem(this._queue.shift()), this._drainUnlockWaiters();
  }
  _dispatchItem(e) {
    const t = this._value;
    this._value -= e.weight, e.resolve([t, this._newReleaser(e.weight)]);
  }
  _newReleaser(e) {
    let t = !1;
    return () => {
      t || (t = !0, this.release(e));
    };
  }
  _drainUnlockWaiters() {
    if (this._queue.length === 0)
      for (let e = this._value; e > 0; e--) {
        const t = this._weightedWaiters[e - 1];
        t && (t.forEach((i) => i.resolve()), this._weightedWaiters[e - 1] = []);
      }
    else {
      const e = this._queue[0].priority;
      for (let t = this._value; t > 0; t--) {
        const i = this._weightedWaiters[t - 1];
        if (!i)
          continue;
        const a = i.findIndex((c) => c.priority <= e);
        (a === -1 ? i : i.splice(0, a)).forEach((c) => c.resolve());
      }
    }
  }
  _couldLockImmediately(e, t) {
    return (this._queue.length === 0 || this._queue[0].priority < t) && e <= this._value;
  }
}
function Cn(n, e) {
  const t = At(n, (i) => e.priority <= i.priority);
  n.splice(t + 1, 0, e);
}
function At(n, e) {
  for (let t = n.length - 1; t >= 0; t--)
    if (e(n[t]))
      return t;
  return -1;
}
var An = function(n, e, t, i) {
  function a(c) {
    return c instanceof t ? c : new t(function(u) {
      u(c);
    });
  }
  return new (t || (t = Promise))(function(c, u) {
    function f(d) {
      try {
        m(i.next(d));
      } catch (w) {
        u(w);
      }
    }
    function _(d) {
      try {
        m(i.throw(d));
      } catch (w) {
        u(w);
      }
    }
    function m(d) {
      d.done ? c(d.value) : a(d.value).then(f, _);
    }
    m((i = i.apply(n, e || [])).next());
  });
};
class Et {
  constructor(e) {
    this._semaphore = new In(1, e);
  }
  acquire() {
    return An(this, arguments, void 0, function* (e = 0) {
      const [, t] = yield this._semaphore.acquire(1, e);
      return t;
    });
  }
  runExclusive(e, t = 0) {
    return this._semaphore.runExclusive(() => e(), 1, t);
  }
  isLocked() {
    return this._semaphore.isLocked();
  }
  waitForUnlock(e = 0) {
    return this._semaphore.waitForUnlock(1, e);
  }
  release() {
    this._semaphore.isLocked() && this._semaphore.release();
  }
  cancel() {
    return this._semaphore.cancel();
  }
}
var p = /* @__PURE__ */ ((n) => (n.Initializing = "initializing", n.Initialized = "initialized", n.Attaching = "attaching", n.Attached = "attached", n.Detaching = "detaching", n.Detached = "detached", n.Suspended = "suspended", n.Failed = "failed", n.Releasing = "releasing", n.Released = "released", n))(p || {});
class En {
  /**
   * Constructs a new DefaultRoomLifecycle instance.
   * @param logger An instance of the Logger.
   */
  constructor(e) {
    this._status = "initialized", this._internalEmitter = new I(), this._emitter = new I(), this._logger = e;
  }
  /**
   * @inheritdoc
   */
  get status() {
    return this._status;
  }
  /**
   * @inheritdoc
   */
  get error() {
    return this._error;
  }
  /**
   * @inheritdoc
   */
  onChange(e) {
    const t = M(e);
    return this._emitter.on(t), {
      off: () => {
        this._emitter.off(t);
      }
    };
  }
  setStatus(e) {
    const t = {
      current: e.status,
      error: e.error,
      previous: this._status
    };
    this._status = t.current, this._error = t.error, this._logger.info("room status changed", { ...t }), this._internalEmitter.emit(t.current, t), this._emitter.emit(t.current, t);
  }
}
class On {
  // CHA-RL7
  constructor(e, t, i) {
    this._channelManager = e, this._roomLifecycle = t, this._logger = i, this._eventEmitter = new I(), this._hasAttachedOnce = !1, this._isExplicitlyDetached = !1, this._mutex = new Et(), this._startMonitoringChannelState(), this._startMonitoringDiscontinuity();
  }
  /**
   * Sets up monitoring of channel state changes to keep room status in sync.
   * If an operation is in progress (attach/detach/release), state changes are ignored.
   * @private
   */
  _startMonitoringChannelState() {
    this._channelManager.get().on((t) => {
      if (this._logger.debug("RoomLifecycleManager.channel state changed", {
        oldState: t.previous,
        newState: t.current,
        reason: t.reason,
        resumed: t.resumed
      }), this._operationInProgress()) {
        this._logger.debug(
          "RoomLifecycleManager._startMonitoringChannelState(); ignoring channel state change - operation in progress",
          {
            status: this._roomLifecycle.status
          }
        );
        return;
      }
      const i = this._mapChannelStateToRoomStatus(t.current);
      this._setStatus(i, t.reason);
    });
  }
  /**
   * Sets up monitoring for channel discontinuities.
   * A discontinuity exists when an attached or update event comes from the channel with resume=false.
   * The first time we attach, or if we attach after an explicit detach call are not considered discontinuities.
   * @private
   */
  _startMonitoringDiscontinuity() {
    const e = this._channelManager.get();
    e.on("attached", (t) => {
      if (!t.resumed && this._hasAttachedOnce && !this._isExplicitlyDetached) {
        const i = new l.ErrorInfo(
          "discontinuity detected",
          j.RoomDiscontinuity,
          t.reason?.statusCode ?? 0,
          t.reason
        );
        this._logger.warn("RoomLifecycleManager._startMonitoringDiscontinuity(); discontinuity detected", {
          error: i
        }), this._eventEmitter.emit(G.Discontinuity, i);
      }
    }), e.on("update", (t) => {
      if (!t.resumed && this._hasAttachedOnce && !this._isExplicitlyDetached && t.current === "attached" && t.previous === "attached") {
        const i = new l.ErrorInfo(
          "discontinuity detected",
          j.RoomDiscontinuity,
          t.reason?.statusCode ?? 0,
          t.reason
        );
        this._logger.warn("RoomLifecycleManager._startMonitoringDiscontinuity(); discontinuity detected", {
          error: i
        }), this._eventEmitter.emit(G.Discontinuity, i);
      }
    });
  }
  /**
   * Registers a handler for discontinuity events.
   * @param handler The function to be called when a discontinuity is detected
   * @returns An object with an off() method to deregister the handler
   */
  onDiscontinuity(e) {
    this._logger.trace("RoomLifecycleManager.onDiscontinuity()");
    const t = M(e);
    return this._eventEmitter.on(G.Discontinuity, t), {
      off: () => {
        this._eventEmitter.off(G.Discontinuity, t);
      }
    };
  }
  /**
   * Attaches to the channel and updates room status accordingly.
   * If the room is released/releasing, this operation fails.
   * If already attached, this is a no-op.
   */
  async attach() {
    await this._mutex.runExclusive(
      async () => {
        if (this._logger.trace("RoomLifecycleManager.attach();"), this._checkRoomNotReleasing("attach"), this._roomStatusIs(p.Attached)) {
          this._logger.debug("RoomLifecycleManager.attach(); room already attached, no-op");
          return;
        }
        const e = this._channelManager.get();
        this._logger.debug("RoomLifecycleManager.attach(); attaching room", {
          channelState: e.state
        });
        try {
          this._setStatus(p.Attaching), await e.attach(), this._setStatus(p.Attached), this._isExplicitlyDetached = !1, this._hasAttachedOnce = !0, this._logger.debug("RoomLifecycleManager.attach(); room attached successfully");
        } catch (t) {
          const i = t, a = new l.ErrorInfo(
            `failed to attach room: ${i.message}`,
            i.code,
            i.statusCode,
            i
          ), c = this._mapChannelStateToRoomStatus(e.state);
          throw this._setStatus(c, a), a;
        }
      },
      1
      /* AttachDetach */
    );
  }
  /**
   * Detaches from the channel and updates room status accordingly.
   * If the room is released/releasing, this operation fails.
   * If already detached, this is a no-op.
   */
  async detach() {
    await this._mutex.runExclusive(
      async () => {
        if (this._logger.trace("RoomLifecycleManager.detach();"), this._roomStatusIs(p.Failed))
          throw new l.ErrorInfo("cannot detach room, room is in failed state", j.RoomInFailedState, 400);
        if (this._checkRoomNotReleasing("detach"), this._roomStatusIs(p.Detached)) {
          this._logger.debug("RoomLifecycleManager.detach(); room already detached, no-op");
          return;
        }
        const e = this._channelManager.get();
        this._logger.debug("RoomLifecycleManager.detach(); detaching room", {
          channelState: e.state
        });
        try {
          this._setStatus(p.Detaching), await e.detach(), this._isExplicitlyDetached = !0, this._setStatus(p.Detached), this._logger.debug("RoomLifecycleManager.detach(); room detached successfully");
        } catch (t) {
          const i = t, a = new l.ErrorInfo(
            `failed to detach room: ${i.message}`,
            i.code,
            i.statusCode,
            i
          ), c = this._mapChannelStateToRoomStatus(e.state);
          throw this._setStatus(c, a), a;
        }
      },
      1
      /* AttachDetach */
    );
  }
  /**
   * Releases the room by detaching the channel and releasing it from the channel manager.
   * If the channel is in a failed state, skips the detach operation.
   * Will retry detach until successful unless in failed state.
   */
  async release() {
    await this._mutex.runExclusive(
      async () => {
        if (this._logger.trace("RoomLifecycleManager.release();"), this._roomStatusIs(p.Released)) {
          this._logger.debug("RoomLifecycleManager.release(); room already released, no-op");
          return;
        }
        if (this._roomStatusIs(p.Initialized) || this._roomStatusIs(p.Detached)) {
          this._logger.debug("RoomLifecycleManager.release(); room is initialized or detached, releasing immediately", {
            status: this._roomLifecycle.status
          }), this._releaseChannel();
          return;
        }
        this._setStatus(p.Releasing);
        const e = this._channelManager.get();
        this._logger.debug("RoomLifecycleManager.release(); attempting channel detach before release", {
          channelState: e.state
        }), await this._channelDetachLoop(e), this._releaseChannel();
      },
      0
      /* Release */
    );
  }
  /**
   * Maps an Ably channel state to a room status
   */
  _mapChannelStateToRoomStatus(e) {
    switch (e) {
      case "initialized":
        return p.Initialized;
      case "attaching":
        return p.Attaching;
      case "attached":
        return p.Attached;
      case "detaching":
        return p.Detaching;
      case "detached":
        return p.Detached;
      case "suspended":
        return p.Suspended;
      case "failed":
        return p.Failed;
      default:
        return this._logger.error("RoomLifecycleManager._mapChannelStateToRoomStatus(); unknown channel state", {
          channelState: e
        }), p.Failed;
    }
  }
  _checkRoomNotReleasing(e) {
    switch (this._roomLifecycle.status) {
      case p.Released:
        throw new l.ErrorInfo(`cannot ${e} room, room is released`, j.RoomIsReleased, 400);
      case p.Releasing:
        throw new l.ErrorInfo(`cannot ${e} room, room is currently releasing`, j.RoomIsReleasing, 400);
    }
  }
  _roomStatusIs(e) {
    return this._roomLifecycle.status === e;
  }
  async _channelDetachLoop(e) {
    for (; ; ) {
      if (e.state === "failed") {
        this._logger.debug("RoomLifecycleManager._channelDetachLoop(); channel is failed, skipping detach");
        break;
      }
      try {
        await e.detach();
        break;
      } catch (i) {
        this._logger.error("RoomLifecycleManager._channelDetachLoop(); failed to detach channel during release", {
          error: i
        }), await new Promise((a) => setTimeout(a, 250));
      }
    }
  }
  _setStatus(e, t) {
    this._logger.debug("RoomLifecycleManager._setStatus(); updating room status", {
      oldStatus: this._roomLifecycle.status,
      newStatus: e,
      hasError: !!t
    }), this._roomLifecycle.setStatus({ status: e, error: t });
  }
  _releaseChannel() {
    this._channelManager.release(), this._setStatus(p.Released), this._logger.debug("RoomLifecycleManager._releaseChannel(); room released successfully");
  }
  /**
   * Returns whether there is currently an operation (attach/detach/release) in progress
   * @private
   */
  _operationInProgress() {
    return this._mutex.isLocked();
  }
  testForceHasAttachedOnce(e) {
    this._hasAttachedOnce = e;
  }
}
const he = {
  /**
   * The default typing options for a chat room.
   */
  typing: {
    /**
     * The default time that a client will wait between sending one typing heartbeat and the next.
     *
     * Spec: CHA-T10.
     */
    heartbeatThrottleMs: 1e4
  },
  /**
   * The default occupancy options for a chat room.
   */
  occupancy: {
    /**
     * Whether to enable occupancy events.
     */
    enableEvents: !1
  },
  /**
   * The default presence options for the room.
   */
  presence: {
    enableEvents: !0
  },
  /**
   * The default options for messages.
   */
  messages: {
    rawMessageReactions: !1,
    defaultMessageReactionType: x.Distinct
  }
}, Dn = (n) => new l.ErrorInfo(`invalid room configuration: ${n}`, 40001, 400), xn = (n) => {
  Ln(n.typing);
}, Ln = (n) => {
  if (n.heartbeatThrottleMs <= 0)
    throw Dn("typing heartbeat interval must be greater than 0");
}, Nn = (n) => ({
  ...he.typing,
  ...n?.typing
}), Pn = (n) => ({
  ...he.occupancy,
  ...n?.occupancy
}), qn = (n) => ({
  ...he.presence,
  ...n?.presence
}), kn = (n) => ({
  ...he.messages,
  ...n?.messages
}), Un = (n, e) => ({
  typing: Nn(n),
  occupancy: Pn(n),
  presence: qn(n),
  messages: kn(n),
  isReactClient: e
}), St = (n, e) => ({
  name: n,
  data: e,
  extras: {
    ephemeral: !0
  }
}), jn = (n) => {
  const e = n.extras ? n.extras : {};
  return {
    ...n,
    extras: {
      ...e,
      ephemeral: !0
    }
  };
};
class Bn {
  constructor(e, t, i, a, c, u) {
    this.name = e, this.clientId = t, this.createdAt = i, this.isSelf = a, this.metadata = c, this.headers = u, Object.freeze(this);
  }
}
function zn(n, e) {
  const t = n;
  if (!t.data)
    throw new l.ErrorInfo("received incoming room reaction message without data", 5e4, 500);
  if (!t.data.name || typeof t.data.name != "string")
    throw new l.ErrorInfo("invalid room reaction message with no name", 5e4, 500);
  if (!t.clientId)
    throw new l.ErrorInfo("received incoming room reaction message without clientId", 5e4, 500);
  if (!t.timestamp)
    throw new l.ErrorInfo("received incoming room reaction message without timestamp", 5e4, 500);
  return new Bn(
    t.data.name,
    t.clientId,
    new Date(t.timestamp),
    e ? e === t.clientId : !1,
    t.data.metadata ?? {},
    t.extras?.headers ?? {}
  );
}
class $n {
  /**
   * Constructs a new `DefaultRoomReactions` instance.
   * @param channel The Realtime channel instance.
   * @param connection The connection instance.
   * @param clientId The client ID of the user.
   * @param logger An instance of the Logger.
   */
  constructor(e, t, i, a) {
    this._emitter = new I(), this._forwarder = (c) => {
      const u = this._parseNewReaction(c, this._clientId);
      u && this._emitter.emit(Re.Reaction, {
        type: Re.Reaction,
        reaction: u
      });
    }, this._channel = e, this._connection = t, this._clientId = i, this._logger = a, this._applyChannelSubscriptions();
  }
  /**
   * Sets up channel subscriptions for room reactions.
   */
  _applyChannelSubscriptions() {
    this._channel.subscribe([Te.Reaction], this._forwarder.bind(this));
  }
  /**
   * @inheritDoc Reactions
   */
  send(e) {
    this._logger.trace("RoomReactions.send();", e);
    const { name: t, metadata: i, headers: a } = e;
    if (!t)
      return Promise.reject(new l.ErrorInfo("unable to send reaction; name not set and it is required", 40001, 400));
    if (this._connection.state !== "connected")
      return Promise.reject(new l.ErrorInfo("unable to send reaction; not connected to Ably", 4e4, 400));
    const c = {
      name: t,
      metadata: i ?? {}
    }, u = {
      name: Te.Reaction,
      data: c,
      extras: {
        headers: a ?? {}
      }
    };
    return this._channel.publish(jn(u));
  }
  /**
   * @inheritDoc Reactions
   */
  subscribe(e) {
    this._logger.trace("RoomReactions.subscribe();");
    const t = M(e);
    return this._emitter.on(t), {
      unsubscribe: () => {
        this._logger.trace("RoomReactions.unsubscribe();"), this._emitter.off(t);
      }
    };
  }
  _parseNewReaction(e, t) {
    try {
      return zn(e, t);
    } catch (i) {
      this._logger.error("failed to parse incoming reaction;", {
        inbound: e,
        error: i
      });
    }
  }
}
class Fn extends I {
  /**
   * Constructs a new `DefaultTyping` instance.
   * @param options The options for typing in the room.
   * @param connection The connection instance.
   * @param channel The channel for the room.
   * @param clientId The client ID of the user.
   * @param logger An instance of the Logger.
   */
  constructor(e, t, i, a, c) {
    super(), this._timeoutMs = 2e3, this._mutex = new Et(), this._internalSubscribeToEvents = (u) => {
      const { name: f, clientId: _ } = u;
      if (this._logger.trace("DefaultTyping._internalSubscribeToEvents(); received event", {
        name: f,
        clientId: _
      }), !_) {
        this._logger.error("DefaultTyping._internalSubscribeToEvents(); invalid clientId in received event", {
          inbound: u
        });
        return;
      }
      f === T.Start || f === T.Stop ? this._updateCurrentlyTyping(_, f) : this._logger.warn("DefaultTyping._internalSubscribeToEvents(); unrecognized event", {
        name: f
      });
    }, this._clientId = a, this._channel = i, this._connection = t, this._heartbeatThrottleMs = e.heartbeatThrottleMs, this._currentlyTyping = /* @__PURE__ */ new Map(), this._logger = c, this._applyChannelSubscriptions();
  }
  /**
   * Sets up channel subscriptions for typing indicators.
   */
  _applyChannelSubscriptions() {
    this._channel.subscribe(
      [T.Start, T.Stop],
      this._internalSubscribeToEvents.bind(this)
    );
  }
  /**
   * Clears all typing states.
   * This includes clearing all timeouts and the currently typing map.
   * @private
   */
  _clearAllTypingStates() {
    this._logger.debug("DefaultTyping._clearAllTypingStates(); clearing all typing states"), this._clearHeartbeatTimer(), this._clearCurrentlyTyping();
  }
  /**
   * Clears the heartbeat timer.
   * @private
   */
  _clearHeartbeatTimer() {
    this._logger.trace("DefaultTyping._clearHeartbeatTimer(); clearing heartbeat timer"), this._heartbeatTimerId && (clearTimeout(this._heartbeatTimerId), this._heartbeatTimerId = void 0);
  }
  /**
   * Clears the currently typing store and removes all timeouts for associated clients.
   * @private
   */
  _clearCurrentlyTyping() {
    this._logger.trace("DefaultTyping._clearCurrentlyTyping(); clearing current store and timeouts");
    for (const [, e] of this._currentlyTyping.entries())
      clearTimeout(e);
    this._currentlyTyping.clear();
  }
  /**
   * CHA-T16
   *
   * @inheritDoc
   */
  current() {
    return this._logger.trace("DefaultTyping.current();"), new Set(this._currentlyTyping.keys());
  }
  /**
   * @inheritDoc
   */
  get channel() {
    return this._channel;
  }
  /**
   * Start the heartbeat timer. This will expire after the configured interval.
   */
  _startHeartbeatTimer() {
    if (!this._heartbeatTimerId) {
      this._logger.trace("DefaultTyping.startHeartbeatTimer();");
      const e = this._heartbeatTimerId = setTimeout(() => {
        this._logger.debug("DefaultTyping.startHeartbeatTimer(); heartbeat timer expired"), e === this._heartbeatTimerId && (this._heartbeatTimerId = void 0);
      }, this._heartbeatThrottleMs);
    }
  }
  /**
   * @inheritDoc
   */
  async keystroke() {
    this._logger.trace("DefaultTyping.keystroke();"), this._mutex.cancel();
    try {
      await this._mutex.acquire();
    } catch (e) {
      if (e === ae) {
        this._logger.debug("DefaultTyping.keystroke(); mutex was canceled by a later operation");
        return;
      }
      throw new l.ErrorInfo("mutex acquisition failed", 5e4, 500);
    }
    try {
      if (this._connection.state !== "connected")
        throw this._logger.error("DefaultTyping.keystroke(); connection is not connected", {
          status: this._connection.state
        }), new l.ErrorInfo("cannot type, connection is not connected", 4e4, 400);
      if (this._heartbeatTimerId) {
        this._logger.debug("DefaultTyping.keystroke(); no-op, already typing and heartbeat timer has not expired");
        return;
      }
      await this._channel.publish(St(T.Start)), this._startHeartbeatTimer(), this._logger.trace("DefaultTyping.keystroke(); starting timers");
    } finally {
      this._logger.trace("DefaultTyping.keystroke(); releasing mutex"), this._mutex.release();
    }
  }
  /**
   * @inheritDoc
   */
  async stop() {
    this._logger.trace("DefaultTyping.stop();"), this._mutex.cancel();
    try {
      await this._mutex.acquire();
    } catch (e) {
      if (e === ae) {
        this._logger.debug("DefaultTyping.stop(); mutex was canceled by a later operation");
        return;
      }
      throw new l.ErrorInfo("mutex acquisition failed", 5e4, 500);
    }
    try {
      if (this._connection.state !== "connected")
        throw this._logger.error("DefaultTyping.stop(); connection is not connected", {
          status: this._connection.state
        }), new l.ErrorInfo("cannot stop typing, connection is not connected", 4e4, 400);
      if (!this._heartbeatTimerId) {
        this._logger.debug("DefaultTyping.stop(); no-op, not currently typing");
        return;
      }
      await this._channel.publish(St(T.Stop)), this._logger.trace("DefaultTyping.stop(); clearing timers"), clearTimeout(this._heartbeatTimerId), this._heartbeatTimerId = void 0;
    } finally {
      this._logger.trace("DefaultTyping.stop(); releasing mutex"), this._mutex.release();
    }
  }
  /**
   * @inheritDoc
   */
  subscribe(e) {
    this._logger.trace("DefaultTyping.subscribe();");
    const t = M(e);
    return this.on(t), {
      unsubscribe: () => {
        this._logger.trace("DefaultTyping.unsubscribe();"), this.off(t);
      }
    };
  }
  /**
   * @inheritDoc
   */
  // CHA-RL3h
  async dispose() {
    for (this._logger.trace("DefaultTyping.dispose();"); ; )
      try {
        this._mutex.cancel(), await this._mutex.acquire();
        break;
      } catch (e) {
        if (e === ae)
          this._logger.debug("DefaultTyping.dispose(); mutex was canceled"), await new Promise((t) => setTimeout(t, 200)), this._logger.debug("DefaultTyping.dispose(); retrying mutex acquisition");
        else {
          this._logger.error("DefaultTyping.dispose(); failed to acquire mutex; could not complete resource disposal", {
            error: e
          });
          return;
        }
      }
    this._clearAllTypingStates(), this._mutex.release();
  }
  /**
   * Update the currently typing users. This method is called when a typing event is received.
   * It will also acquire a mutex to ensure that the currentlyTyping state is updated safely.
   * @param clientId The client ID of the user.
   * @param event The typing event.
   */
  _updateCurrentlyTyping(e, t) {
    this._logger.trace("DefaultTyping._updateCurrentlyTyping();", { clientId: e, event: t }), t === T.Start ? this._handleTypingStart(e) : this._handleTypingStop(e);
  }
  /**
   * Starts a new inactivity timer for the client.
   * This timer will expire after the configured timeout,
   * which is the sum of the heartbeat interval and the inactivity timeout.
   * @param clientId
   */
  _startNewClientInactivityTimer(e) {
    this._logger.trace("DefaultTyping._startNewClientInactivityTimer(); starting new inactivity timer", {
      clientId: e
    });
    const t = setTimeout(() => {
      if (this._logger.trace("DefaultTyping._startNewClientInactivityTimer(); client typing timeout expired", {
        clientId: e
      }), this._currentlyTyping.get(e) !== t) {
        this._logger.debug("DefaultTyping._startNewClientInactivityTimer(); timeout already cleared; ignoring", {
          clientId: e
        });
        return;
      }
      this._currentlyTyping.delete(e), this.emit(U.SetChanged, {
        type: U.SetChanged,
        currentlyTyping: new Set(this._currentlyTyping.keys()),
        change: {
          clientId: e,
          type: T.Stop
        }
      });
    }, this._heartbeatThrottleMs + this._timeoutMs);
    return t;
  }
  /**
   * Handles logic for TypingEventType.Start, including starting a new timeout or resetting an existing one.
   * @param clientId
   */
  _handleTypingStart(e) {
    this._logger.debug("DefaultTyping._handleTypingStart();", { clientId: e });
    const t = this._startNewClientInactivityTimer(e), i = this._currentlyTyping.get(e);
    this._currentlyTyping.set(e, t), i ? (this._logger.debug("DefaultTyping._handleTypingStart(); received heartbeat for currently typing client", {
      clientId: e
    }), clearTimeout(i)) : (this._logger.debug("DefaultTyping._handleTypingStart(); new client started typing", {
      clientId: e
    }), this.emit(U.SetChanged, {
      type: U.SetChanged,
      currentlyTyping: new Set(this._currentlyTyping.keys()),
      change: {
        clientId: e,
        type: T.Start
      }
    }));
  }
  /**
   * Handles logic for TypingEventType.Stop, including clearing the timeout for the client.
   * @param clientId
   * @private
   */
  _handleTypingStop(e) {
    const t = this._currentlyTyping.get(e);
    if (!t) {
      this._logger.trace(
        'DefaultTyping._handleTypingStop(); received "Stop" event for client not in currentlyTyping list',
        { clientId: e }
      );
      return;
    }
    this._logger.debug("DefaultTyping._handleTypingStop(); client stopped typing", { clientId: e }), clearTimeout(t), this._currentlyTyping.delete(e), this.emit(U.SetChanged, {
      type: U.SetChanged,
      currentlyTyping: new Set(this._currentlyTyping.keys()),
      change: {
        clientId: e,
        type: T.Stop
      }
    });
  }
  get heartbeatThrottleMs() {
    return this._heartbeatThrottleMs;
  }
  get hasHeartbeatTimer() {
    return !!this._heartbeatTimerId;
  }
}
class Hn {
  /**
   * Constructs a new Room instance.
   *
   * @param name The unique identifier of the room.
   * @param nonce A random identifier for the room instance, useful in debugging and logging.
   * @param options The options for the room.
   * @param realtime An instance of the Ably Realtime client.
   * @param chatApi An instance of the ChatApi.
   * @param logger An instance of the Logger.
   * @param connection An instance of the Connection.
   */
  constructor(e, t, i, a, c, u) {
    xn(i), this._nonce = t, this._logger = u.withContext({ roomName: e, roomNonce: t }), this._logger.debug("Room();", { options: i }), this._name = e, this._options = i, this._chatApi = c, this._lifecycle = new En(this._logger);
    const f = this._channelManager = this._getChannelManager(i, a, this._logger), _ = f.get();
    this._messages = new fn(
      e,
      i.messages,
      _,
      this._chatApi,
      a.auth.clientId,
      this._logger
    ), this._presence = new vt(_, a.auth.clientId, this._logger, i), this._typing = new Fn(
      i.typing,
      a.connection,
      _,
      a.auth.clientId,
      this._logger
    ), this._reactions = new $n(_, a.connection, a.auth.clientId, this._logger), this._occupancy = new wt(e, _, this._chatApi, this._logger, i), this._lifecycleManager = new On(f, this._lifecycle, this._logger);
    let m = !1;
    this._finalizer = async () => {
      if (m) {
        this._logger.debug("Room.finalizer(); already finalized");
        return;
      }
      await this._lifecycleManager.release(), await this._typing.dispose(), m = !0;
    };
  }
  /**
   * Gets the channel manager for the room, which handles merging channel options together and creating channels.
   *
   * @param options The room options.
   * @param realtime  An instance of the Ably Realtime client.
   * @param logger An instance of the Logger.
   */
  _getChannelManager(e, t, i) {
    const a = new Rn(this._name, t, i, e.isReactClient);
    return a.mergeOptions(wt.channelOptionMerger(e)), a.mergeOptions(vt.channelOptionMerger(e)), a.mergeOptions(It.channelOptionMerger(e)), a;
  }
  /**
   * @inheritdoc Room
   */
  get name() {
    return this._name;
  }
  /**
   * @inheritDoc Room
   */
  options() {
    return D(this._options);
  }
  /**
   * @inheritdoc Room
   */
  get messages() {
    return this._messages;
  }
  /**
   * @inheritdoc Room
   */
  get presence() {
    return this._presence;
  }
  /**
   * @inheritdoc Room
   */
  get reactions() {
    return this._reactions;
  }
  /**
   * @inheritdoc Room
   */
  get typing() {
    return this._typing;
  }
  /**
   * @inheritdoc Room
   */
  get occupancy() {
    return this._occupancy;
  }
  /**
   * @inheritdoc Room
   */
  get status() {
    return this._lifecycle.status;
  }
  /**
   * @inheritdoc Room
   */
  get error() {
    return this._lifecycle.error;
  }
  /**
   * @inheritdoc Room
   */
  onStatusChange(e) {
    return this._lifecycle.onChange(e);
  }
  /**
   * @inheritdoc Room
   */
  async attach() {
    return this._logger.trace("Room.attach();"), this._lifecycleManager.attach();
  }
  /**
   * @inheritdoc Room
   */
  async detach() {
    return this._logger.trace("Room.detach();"), this._lifecycleManager.detach();
  }
  /**
   * Releases resources associated with the room.
   * We guarantee that this does not throw an error.
   */
  release() {
    return this._logger.trace("Room.release();"), this._finalizer();
  }
  /**
   * A random identifier for the room instance, useful in debugging and logging.
   *
   * @returns The nonce.
   */
  get nonce() {
    return this._nonce;
  }
  /**
   * @internal
   *
   * Returns the rooms lifecycle.
   */
  get lifecycle() {
    return this._lifecycle;
  }
  /**
   * @internal
   */
  get lifecycleManager() {
    return this._lifecycleManager;
  }
  /**
   * @inheritdoc Room
   */
  onDiscontinuity(e) {
    return this._logger.trace("Room.onDiscontinuity();"), this._lifecycleManager.onDiscontinuity(e);
  }
  /**
   * @inheritdoc Room
   */
  get channel() {
    return this._channelManager.get();
  }
}
class Vn {
  /**
   * Constructs a new Rooms instance.
   *
   * @param realtime An instance of the Ably Realtime client.
   * @param clientOptions The client options from the chat instance.
   * @param logger An instance of the Logger.
   */
  constructor(e, t, i) {
    this._rooms = /* @__PURE__ */ new Map(), this._releasing = /* @__PURE__ */ new Map(), this._isReact = !1, this._realtime = e, this._chatApi = new mn(e, i), this._clientOptions = t, this._logger = i;
  }
  /**
   * @inheritDoc
   */
  get(e, t) {
    this._logger.trace("Rooms.get();", { roomName: e });
    const i = this._rooms.get(e);
    if (i)
      return K(i.options, t) ? (this._logger.debug("Rooms.get(); returning existing room", { roomName: e, nonce: i.nonce }), i.promise) : Promise.reject(new l.ErrorInfo("room already exists with different options", 4e4, 400));
    const a = this._releasing.get(e), c = yn();
    if (!a) {
      const _ = this._makeRoom(e, c, t), m = {
        promise: Promise.resolve(_),
        nonce: c,
        options: t
      };
      return this._rooms.set(e, m), this._logger.debug("Rooms.get(); returning new room", { roomName: e, nonce: _.nonce }), m.promise;
    }
    const u = new AbortController(), f = new Promise((_, m) => {
      const d = () => {
        this._logger.debug("Rooms.get(); aborted before init", { roomName: e }), m(
          new l.ErrorInfo(
            "room released before get operation could complete",
            j.RoomReleasedBeforeOperationCompleted,
            400
          )
        );
      };
      u.signal.addEventListener("abort", d), a.then(() => {
        if (u.signal.aborted) {
          this._logger.debug("Rooms.get(); aborted before releasing promise resolved", { roomName: e });
          return;
        }
        this._logger.debug("Rooms.get(); releasing finished", { roomName: e });
        const w = this._makeRoom(e, c, t);
        u.signal.removeEventListener("abort", d), _(w);
      }).catch((w) => {
        m(w);
      });
    });
    return this._rooms.set(e, {
      promise: f,
      options: t,
      nonce: c,
      abort: u
    }), this._logger.debug("Rooms.get(); creating new promise dependent on previous release", { roomName: e }), f;
  }
  /**
   * @inheritDoc
   */
  get clientOptions() {
    return this._clientOptions;
  }
  /**
   * @inheritDoc
   */
  release(e) {
    this._logger.trace("Rooms.release();", { roomName: e });
    const t = this._rooms.get(e), i = this._releasing.get(e);
    if (!t)
      return i ? (this._logger.debug("Rooms.release(); waiting for previous release call", {
        roomName: e
      }), i) : (this._logger.debug("Rooms.release(); room does not exist", { roomName: e }), Promise.resolve());
    if (i)
      return t.abort && (this._logger.debug("Rooms.release(); aborting get call", { roomName: e, existingNonce: t.nonce }), t.abort.abort(), this._rooms.delete(e)), i;
    this._rooms.delete(e);
    const a = t.promise.then((c) => (this._logger.debug("Rooms.release(); releasing room", { roomName: e, nonce: t.nonce }), c.release().then(() => {
      this._logger.debug("Rooms.release(); room released", { roomName: e, nonce: t.nonce }), this._releasing.delete(e);
    })));
    return this._logger.debug("Rooms.release(); creating new release promise", { roomName: e, nonce: t.nonce }), this._releasing.set(e, a), a;
  }
  /**
   * makes a new room object
   *
   * @param name The unique identifier of the room.
   * @param nonce A random, internal identifier useful for debugging and logging.
   * @param options The options for the room.
   *
   * @returns DefaultRoom A new room object.
   */
  _makeRoom(e, t, i) {
    return new Hn(
      e,
      t,
      Un(i, this._isReact),
      this._realtime,
      this._chatApi,
      this._logger
    );
  }
  /**
   * Sets react JS mode.
   */
  useReact() {
    this._logger.trace("Rooms.useReact();"), this._isReact = !0;
  }
}
class Wn {
  /**
   * Constructor for Chat
   * @param realtime - The Ably Realtime client.
   * @param clientOptions - The client options.
   */
  constructor(e, t) {
    this._realtime = e, this._clientOptions = nn(t), this._logger = tn(this._clientOptions), this._connection = new on(e, this._logger), this._rooms = new Vn(e, this._clientOptions, this._logger), this._addAgent("chat-js"), this._logger.trace(`ably chat client version ${ce}; initialized`);
  }
  /**
   * Returns the rooms object, which provides access to chat rooms.
   *
   * @returns The rooms object.
   */
  get rooms() {
    return this._rooms;
  }
  /**
   * Returns the underlying connection to Ably, which can be used to monitor the client's
   * connection to Ably servers.
   *
   * @returns The connection object.
   */
  get connection() {
    return this._connection;
  }
  /**
   * Returns the clientId of the current client.
   *
   * @returns The clientId.
   */
  get clientId() {
    return this._realtime.auth.clientId;
  }
  /**
   * Returns the underlying Ably Realtime client.
   * @returns The Ably Realtime client.
   */
  get realtime() {
    return this._realtime;
  }
  /**
   * Returns the resolved client options for the client, including any defaults that have been set.
   * @returns The client options.
   */
  get clientOptions() {
    return this._clientOptions;
  }
  /**
   * Returns the logger instance for the client.
   * @internal
   * @returns The logger instance.
   */
  get logger() {
    return this._logger;
  }
  /**
   * Adds additional agent information to the client.
   * Used internally to add React-specific agent information.
   * @internal
   */
  addReactAgent() {
    this._addAgent("chat-react"), this._rooms.useReact();
  }
  /**
   * Adds additional agent information to the client.
   * This is used internally to add a specific agent with a version.
   * @param agent - The agent to add.
   * @param version - The version of the agent, defaults to the current client version.
   * @internal
   */
  addAgentWithVersion(e, t) {
    this._addAgent(e, t), this._logger.trace(`Added agent ${e} with version ${t}`);
  }
  /**
   * Sets the agent string for the client.
   * @param agent - The agent to add.
   * @param version - The version of the agent, defaults to the current client version.
   * @internal
   */
  _addAgent(e, t) {
    const i = this._realtime;
    i.options.agents = { ...i.options.agents ?? i.options.agents, [e]: t ?? ce };
  }
}
export {
  Wn as ChatClient,
  y as ChatMessageAction,
  N as ChatMessageEventType,
  an as ConnectionStatus,
  j as ErrorCode,
  Tt as LogLevel,
  R as MessageReactionEventType,
  x as MessageReactionType,
  Me as OccupancyEventType,
  Ce as OrderBy,
  cn as PresenceEventType,
  G as RoomEventType,
  p as RoomStatus,
  T as TypingEventType,
  U as TypingSetEventType,
  Gn as errorInfoIs
};
//# sourceMappingURL=ably-chat.js.map
