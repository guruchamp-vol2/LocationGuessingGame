(function(f,G){typeof exports=="object"&&typeof module<"u"?G(exports,require("ably")):typeof define=="function"&&define.amd?define(["exports","ably"],G):(f=typeof globalThis<"u"?globalThis:f||self,G(f.AblyChat={},f.Ably))})(this,function(f,G){"use strict";function Pt(n){const e=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(n){for(const t in n)if(t!=="default"){const i=Object.getOwnPropertyDescriptor(n,t);Object.defineProperty(e,t,i.get?i:{enumerable:!0,get:()=>n[t]})}}return e.default=n,Object.freeze(e)}const l=Pt(G);var _e=(n=>(n.Trace="trace",n.Debug="debug",n.Info="info",n.Warn="warn",n.Error="error",n.Silent="silent",n))(_e||{});const Nt=(n,e,t)=>{const i=t?`, context: ${JSON.stringify(t)}`:"",a=`[${new Date().toISOString()}] ${e.valueOf().toUpperCase()} ably-chat: ${n}${i}`;switch(e){case"trace":case"debug":{console.log(a);break}case"info":{console.info(a);break}case"warn":{console.warn(a);break}case"error":{console.error(a);break}}},qt=n=>{const e=n.logHandler??Nt;return new pe(e,n.logLevel)},Le=new Map([["trace",0],["debug",1],["info",2],["warn",3],["error",4],["silent",5]]);class pe{constructor(e,t,i){this._handler=e,this._context=i;const a=Le.get(t);if(a===void 0)throw new l.ErrorInfo(`Invalid log level: ${t}`,5e4,500);this._levelNumber=a}trace(e,t){this._write(e,"trace",0,t)}debug(e,t){this._write(e,"debug",1,t)}info(e,t){this._write(e,"info",2,t)}warn(e,t){this._write(e,"warn",3,t)}error(e,t){this._write(e,"error",4,t)}withContext(e){const t=[...Le.entries()].find(([,i])=>i===this._levelNumber)?.[0]??"error";return new pe(this._handler,t,this._mergeContext(e))}_write(e,t,i,a){i>=this._levelNumber&&this._handler(e,t,this._mergeContext(a))}_mergeContext(e){return this._context?e?{...this._context,...e}:this._context:e??void 0}}const kt={logLevel:_e.Error},jt=n=>(n=n??{},{...n,logLevel:n.logLevel??kt.logLevel}),Ut=l.Realtime.EventEmitter;class C extends Ut{}const I=n=>(...e)=>n(...e);var Pe=(n=>(n.Initialized="initialized",n.Connecting="connecting",n.Connected="connected",n.Disconnected="disconnected",n.Suspended="suspended",n.Failed="failed",n))(Pe||{});class Bt{constructor(e,t){this._status="initialized",this._emitter=new C,this._logger=t,this._status=this._mapAblyStatusToChat(e.connection.state),this._error=e.connection.errorReason,this._connection=e.connection,this._connection.on(i=>{const a=this._mapAblyStatusToChat(i.current);if(a===this._status)return;const c={current:a,previous:this._status,error:i.reason,retryIn:i.retryIn};this._applyStatusChange(c)})}get status(){return this._status}get error(){return this._error}onStatusChange(e){const t=I(e);return this._emitter.on(t),{off:()=>{this._emitter.off(t)}}}_applyStatusChange(e){this._status=e.current,this._error=e.error,this._logger.info("Connection state changed",e),this._emitter.emit(e.current,e)}_mapAblyStatusToChat(e){switch(e){case"closing":case"closed":return"failed";default:return e}}}var Ne=Object.prototype.hasOwnProperty;function qe(n,e,t){for(t of n.keys())if(W(t,e))return t}function W(n,e){var t,i,a;if(n===e)return!0;if(n&&e&&(t=n.constructor)===e.constructor){if(t===Date)return n.getTime()===e.getTime();if(t===RegExp)return n.toString()===e.toString();if(t===Array){if((i=n.length)===e.length)for(;i--&&W(n[i],e[i]););return i===-1}if(t===Set){if(n.size!==e.size)return!1;for(i of n)if(a=i,a&&typeof a=="object"&&(a=qe(e,a),!a)||!e.has(a))return!1;return!0}if(t===Map){if(n.size!==e.size)return!1;for(i of n)if(a=i[0],a&&typeof a=="object"&&(a=qe(e,a),!a)||!W(i[1],e.get(a)))return!1;return!0}if(t===ArrayBuffer)n=new Uint8Array(n),e=new Uint8Array(e);else if(t===DataView){if((i=n.byteLength)===e.byteLength)for(;i--&&n.getInt8(i)===e.getInt8(i););return i===-1}if(ArrayBuffer.isView(n)){if((i=n.byteLength)===e.byteLength)for(;i--&&n[i]===e[i];);return i===-1}if(!t||typeof n=="object"){i=0;for(t in n)if(Ne.call(n,t)&&++i&&!Ne.call(e,t)||!(t in e)||!W(n[t],e[t]))return!1;return Object.keys(e).length===i}}return n!==n&&e!==e}var E=(n=>(n.Created="message.created",n.Updated="message.updated",n.Deleted="message.deleted",n))(E||{}),ke=(n=>(n.ChatMessage="chat.message",n))(ke||{}),je=(n=>(n.Occupancy="[meta]occupancy",n))(je||{}),b=(n=>(n.MessageCreate="message.create",n.MessageUpdate="message.update",n.MessageDelete="message.delete",n.MessageAnnotationSummary="message.summary",n.MessageMetaOccupancy="meta.occupancy",n))(b||{}),Ue=(n=>(n.Enter="enter",n.Leave="leave",n.Update="update",n.Present="present",n))(Ue||{}),R=(n=>(n.Start="typing.started",n.Stop="typing.stopped",n))(R||{}),L=(n=>(n.SetChanged="typing.set.changed",n))(L||{}),fe=(n=>(n.Reaction="roomReaction",n))(fe||{}),me=(n=>(n.Reaction="reaction",n))(me||{}),A=(n=>(n.Unique="unique",n.Distinct="distinct",n.Multiple="multiple",n))(A||{}),X=(n=>(n.Unique="reaction:unique.v1",n.Distinct="reaction:distinct.v1",n.Multiple="reaction:multiple.v1",n))(X||{});const zt={"reaction:unique.v1":"unique","reaction:distinct.v1":"distinct","reaction:multiple.v1":"multiple"};var M=(n=>(n.Create="reaction.create",n.Delete="reaction.delete",n.Summary="reaction.summary",n))(M||{}),Y=(n=>(n.Updated="occupancy.updated",n))(Y||{}),z=(n=>(n.Discontinuity="room.discontinuity",n))(z||{}),Z=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function $t(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}var K={exports:{}};K.exports;var Be;function Ft(){return Be||(Be=1,function(n,e){var t=200,i="__lodash_hash_undefined__",a=9007199254740991,c="[object Arguments]",u="[object Array]",m="[object Boolean]",p="[object Date]",y="[object Error]",_="[object Function]",v="[object GeneratorFunction]",se="[object Map]",Ke="[object Number]",we="[object Object]",Qe="[object Promise]",Je="[object RegExp]",ae="[object Set]",Xe="[object String]",Ye="[object Symbol]",ve="[object WeakMap]",Ze="[object ArrayBuffer]",oe="[object DataView]",et="[object Float32Array]",tt="[object Float64Array]",rt="[object Int8Array]",nt="[object Int16Array]",it="[object Int32Array]",st="[object Uint8Array]",at="[object Uint8ClampedArray]",ot="[object Uint16Array]",ct="[object Uint32Array]",Ir=/[\\^$.*+?()[\]{}|]/g,Cr=/\w*$/,Er=/^\[object .+?Constructor\]$/,Ar=/^(?:0|[1-9]\d*)$/,g={};g[c]=g[u]=g[Ze]=g[oe]=g[m]=g[p]=g[et]=g[tt]=g[rt]=g[nt]=g[it]=g[se]=g[Ke]=g[we]=g[Je]=g[ae]=g[Xe]=g[Ye]=g[st]=g[at]=g[ot]=g[ct]=!0,g[y]=g[_]=g[ve]=!1;var Or=typeof Z=="object"&&Z&&Z.Object===Object&&Z,Dr=typeof self=="object"&&self&&self.Object===Object&&self,O=Or||Dr||Function("return this")(),ht=e&&!e.nodeType&&e,lt=ht&&!0&&n&&!n.nodeType&&n,xr=lt&&lt.exports===ht;function Lr(r,s){return r.set(s[0],s[1]),r}function Pr(r,s){return r.add(s),r}function Nr(r,s){for(var o=-1,h=r?r.length:0;++o<h&&s(r[o],o,r)!==!1;);return r}function qr(r,s){for(var o=-1,h=s.length,w=r.length;++o<h;)r[w+o]=s[o];return r}function ut(r,s,o,h){for(var w=-1,S=r?r.length:0;++w<S;)o=s(o,r[w],w,r);return o}function kr(r,s){for(var o=-1,h=Array(r);++o<r;)h[o]=s(o);return h}function jr(r,s){return r?.[s]}function gt(r){var s=!1;if(r!=null&&typeof r.toString!="function")try{s=!!(r+"")}catch{}return s}function dt(r){var s=-1,o=Array(r.size);return r.forEach(function(h,w){o[++s]=[w,h]}),o}function Se(r,s){return function(o){return r(s(o))}}function _t(r){var s=-1,o=Array(r.size);return r.forEach(function(h){o[++s]=h}),o}var Ur=Array.prototype,Br=Function.prototype,ce=Object.prototype,Te=O["__core-js_shared__"],pt=function(){var r=/[^.]+$/.exec(Te&&Te.keys&&Te.keys.IE_PROTO||"");return r?"Symbol(src)_1."+r:""}(),ft=Br.toString,k=ce.hasOwnProperty,he=ce.toString,zr=RegExp("^"+ft.call(k).replace(Ir,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),mt=xr?O.Buffer:void 0,yt=O.Symbol,bt=O.Uint8Array,$r=Se(Object.getPrototypeOf,Object),Fr=Object.create,Hr=ce.propertyIsEnumerable,Vr=Ur.splice,wt=Object.getOwnPropertySymbols,Gr=mt?mt.isBuffer:void 0,Wr=Se(Object.keys,Object),Re=H(O,"DataView"),Q=H(O,"Map"),Me=H(O,"Promise"),Ie=H(O,"Set"),Ce=H(O,"WeakMap"),J=H(Object,"create"),Kr=B(Re),Qr=B(Q),Jr=B(Me),Xr=B(Ie),Yr=B(Ce),vt=yt?yt.prototype:void 0,St=vt?vt.valueOf:void 0;function j(r){var s=-1,o=r?r.length:0;for(this.clear();++s<o;){var h=r[s];this.set(h[0],h[1])}}function Zr(){this.__data__=J?J(null):{}}function en(r){return this.has(r)&&delete this.__data__[r]}function tn(r){var s=this.__data__;if(J){var o=s[r];return o===i?void 0:o}return k.call(s,r)?s[r]:void 0}function rn(r){var s=this.__data__;return J?s[r]!==void 0:k.call(s,r)}function nn(r,s){var o=this.__data__;return o[r]=J&&s===void 0?i:s,this}j.prototype.clear=Zr,j.prototype.delete=en,j.prototype.get=tn,j.prototype.has=rn,j.prototype.set=nn;function D(r){var s=-1,o=r?r.length:0;for(this.clear();++s<o;){var h=r[s];this.set(h[0],h[1])}}function sn(){this.__data__=[]}function an(r){var s=this.__data__,o=le(s,r);if(o<0)return!1;var h=s.length-1;return o==h?s.pop():Vr.call(s,o,1),!0}function on(r){var s=this.__data__,o=le(s,r);return o<0?void 0:s[o][1]}function cn(r){return le(this.__data__,r)>-1}function hn(r,s){var o=this.__data__,h=le(o,r);return h<0?o.push([r,s]):o[h][1]=s,this}D.prototype.clear=sn,D.prototype.delete=an,D.prototype.get=on,D.prototype.has=cn,D.prototype.set=hn;function $(r){var s=-1,o=r?r.length:0;for(this.clear();++s<o;){var h=r[s];this.set(h[0],h[1])}}function ln(){this.__data__={hash:new j,map:new(Q||D),string:new j}}function un(r){return ue(this,r).delete(r)}function gn(r){return ue(this,r).get(r)}function dn(r){return ue(this,r).has(r)}function _n(r,s){return ue(this,r).set(r,s),this}$.prototype.clear=ln,$.prototype.delete=un,$.prototype.get=gn,$.prototype.has=dn,$.prototype.set=_n;function F(r){this.__data__=new D(r)}function pn(){this.__data__=new D}function fn(r){return this.__data__.delete(r)}function mn(r){return this.__data__.get(r)}function yn(r){return this.__data__.has(r)}function bn(r,s){var o=this.__data__;if(o instanceof D){var h=o.__data__;if(!Q||h.length<t-1)return h.push([r,s]),this;o=this.__data__=new $(h)}return o.set(r,s),this}F.prototype.clear=pn,F.prototype.delete=fn,F.prototype.get=mn,F.prototype.has=yn,F.prototype.set=bn;function wn(r,s){var o=Oe(r)||Hn(r)?kr(r.length,String):[],h=o.length,w=!!h;for(var S in r)k.call(r,S)&&!(w&&(S=="length"||Bn(S,h)))&&o.push(S);return o}function Tt(r,s,o){var h=r[s];(!(k.call(r,s)&&Ct(h,o))||o===void 0&&!(s in r))&&(r[s]=o)}function le(r,s){for(var o=r.length;o--;)if(Ct(r[o][0],s))return o;return-1}function vn(r,s){return r&&Rt(s,De(s),r)}function Ee(r,s,o,h,w,S,x){var T;if(h&&(T=S?h(r,w,S,x):h(r)),T!==void 0)return T;if(!ge(r))return r;var Ot=Oe(r);if(Ot){if(T=kn(r),!s)return Pn(r,T)}else{var V=U(r),Dt=V==_||V==v;if(Gn(r))return Cn(r,s);if(V==we||V==c||Dt&&!S){if(gt(r))return S?r:{};if(T=jn(Dt?{}:r),!s)return Nn(r,vn(T,r))}else{if(!g[V])return S?r:{};T=Un(r,V,Ee,s)}}x||(x=new F);var xt=x.get(r);if(xt)return xt;if(x.set(r,T),!Ot)var Lt=o?qn(r):De(r);return Nr(Lt||r,function(xe,de){Lt&&(de=xe,xe=r[de]),Tt(T,de,Ee(xe,s,o,h,de,r,x))}),T}function Sn(r){return ge(r)?Fr(r):{}}function Tn(r,s,o){var h=s(r);return Oe(r)?h:qr(h,o(r))}function Rn(r){return he.call(r)}function Mn(r){if(!ge(r)||$n(r))return!1;var s=At(r)||gt(r)?zr:Er;return s.test(B(r))}function In(r){if(!It(r))return Wr(r);var s=[];for(var o in Object(r))k.call(r,o)&&o!="constructor"&&s.push(o);return s}function Cn(r,s){if(s)return r.slice();var o=new r.constructor(r.length);return r.copy(o),o}function Ae(r){var s=new r.constructor(r.byteLength);return new bt(s).set(new bt(r)),s}function En(r,s){var o=s?Ae(r.buffer):r.buffer;return new r.constructor(o,r.byteOffset,r.byteLength)}function An(r,s,o){var h=s?o(dt(r),!0):dt(r);return ut(h,Lr,new r.constructor)}function On(r){var s=new r.constructor(r.source,Cr.exec(r));return s.lastIndex=r.lastIndex,s}function Dn(r,s,o){var h=s?o(_t(r),!0):_t(r);return ut(h,Pr,new r.constructor)}function xn(r){return St?Object(St.call(r)):{}}function Ln(r,s){var o=s?Ae(r.buffer):r.buffer;return new r.constructor(o,r.byteOffset,r.length)}function Pn(r,s){var o=-1,h=r.length;for(s||(s=Array(h));++o<h;)s[o]=r[o];return s}function Rt(r,s,o,h){o||(o={});for(var w=-1,S=s.length;++w<S;){var x=s[w],T=void 0;Tt(o,x,T===void 0?r[x]:T)}return o}function Nn(r,s){return Rt(r,Mt(r),s)}function qn(r){return Tn(r,De,Mt)}function ue(r,s){var o=r.__data__;return zn(s)?o[typeof s=="string"?"string":"hash"]:o.map}function H(r,s){var o=jr(r,s);return Mn(o)?o:void 0}var Mt=wt?Se(wt,Object):Qn,U=Rn;(Re&&U(new Re(new ArrayBuffer(1)))!=oe||Q&&U(new Q)!=se||Me&&U(Me.resolve())!=Qe||Ie&&U(new Ie)!=ae||Ce&&U(new Ce)!=ve)&&(U=function(r){var s=he.call(r),o=s==we?r.constructor:void 0,h=o?B(o):void 0;if(h)switch(h){case Kr:return oe;case Qr:return se;case Jr:return Qe;case Xr:return ae;case Yr:return ve}return s});function kn(r){var s=r.length,o=r.constructor(s);return s&&typeof r[0]=="string"&&k.call(r,"index")&&(o.index=r.index,o.input=r.input),o}function jn(r){return typeof r.constructor=="function"&&!It(r)?Sn($r(r)):{}}function Un(r,s,o,h){var w=r.constructor;switch(s){case Ze:return Ae(r);case m:case p:return new w(+r);case oe:return En(r,h);case et:case tt:case rt:case nt:case it:case st:case at:case ot:case ct:return Ln(r,h);case se:return An(r,h,o);case Ke:case Xe:return new w(r);case Je:return On(r);case ae:return Dn(r,h,o);case Ye:return xn(r)}}function Bn(r,s){return s=s??a,!!s&&(typeof r=="number"||Ar.test(r))&&r>-1&&r%1==0&&r<s}function zn(r){var s=typeof r;return s=="string"||s=="number"||s=="symbol"||s=="boolean"?r!=="__proto__":r===null}function $n(r){return!!pt&&pt in r}function It(r){var s=r&&r.constructor,o=typeof s=="function"&&s.prototype||ce;return r===o}function B(r){if(r!=null){try{return ft.call(r)}catch{}try{return r+""}catch{}}return""}function Fn(r){return Ee(r,!0,!0)}function Ct(r,s){return r===s||r!==r&&s!==s}function Hn(r){return Vn(r)&&k.call(r,"callee")&&(!Hr.call(r,"callee")||he.call(r)==c)}var Oe=Array.isArray;function Et(r){return r!=null&&Wn(r.length)&&!At(r)}function Vn(r){return Kn(r)&&Et(r)}var Gn=Gr||Jn;function At(r){var s=ge(r)?he.call(r):"";return s==_||s==v}function Wn(r){return typeof r=="number"&&r>-1&&r%1==0&&r<=a}function ge(r){var s=typeof r;return!!r&&(s=="object"||s=="function")}function Kn(r){return!!r&&typeof r=="object"}function De(r){return Et(r)?wn(r):In(r)}function Qn(){return[]}function Jn(){return!1}n.exports=Fn}(K,K.exports)),K.exports}var Ht=Ft();const P=$t(Ht);class N{constructor({serial:e,clientId:t,text:i,metadata:a,headers:c,action:u,version:m,createdAt:p,timestamp:y,reactions:_,operation:v}){this.serial=e,this.clientId=t,this.text=i,this.metadata=a,this.headers=c,this.action=u,this.version=m,this.createdAt=p,this.timestamp=y,this.reactions=_,this.operation=v,Object.freeze(this.reactions),Object.freeze(this.reactions.multiple),Object.freeze(this.reactions.distinct),Object.freeze(this.reactions.unique),Object.freeze(this)}get isUpdated(){return this.action===b.MessageUpdate}get isDeleted(){return this.action===b.MessageDelete}get updatedBy(){return this.isUpdated?this.operation?.clientId:void 0}get deletedBy(){return this.isDeleted?this.operation?.clientId:void 0}get updatedAt(){return this.isUpdated?this.timestamp:void 0}get deletedAt(){return this.isDeleted?this.timestamp:void 0}isOlderVersionOf(e){return this.equal(e)?this.version<e.version:!1}isNewerVersionOf(e){return this.equal(e)?this.version>e.version:!1}isSameVersionAs(e){return this.equal(e)?this.version===e.version:!1}before(e){return this.serial<e.serial}after(e){return this.serial>e.serial}equal(e){return this.serial===e.serial}isSameAs(e){return this.equal(e)}with(e){if("serial"in e)return this._getLatestMessageVersion(e);if(e.type===E.Created)throw new l.ErrorInfo("cannot apply a created event to a message",4e4,400);if(e.type===M.Summary){if(e.summary.messageSerial!==this.serial)throw new l.ErrorInfo("cannot apply event for a different message",4e4,400);const t={unique:P(e.summary.unique),distinct:P(e.summary.distinct),multiple:P(e.summary.multiple)};return N._clone(this,{reactions:t})}return this._getLatestMessageVersion(e.message)}_getLatestMessageVersion(e){if(e.serial!==this.serial)throw new l.ErrorInfo("cannot apply event for a different message",4e4,400);return this.version>=e.version?this:N._clone(e,{reactions:this.reactions})}static _clone(e,t){return new N({serial:t?.serial??e.serial,clientId:t?.clientId??e.clientId,text:t?.text??e.text,metadata:t?.metadata??P(e.metadata),headers:t?.headers??P(e.headers),action:t?.action??e.action,version:t?.version??e.version,createdAt:t?.createdAt??e.createdAt,timestamp:t?.timestamp??e.timestamp,reactions:t?.reactions??P(e.reactions),operation:t?.operation??P(e.operation)})}copy(e={}){return N._clone(this,e)}}function ye(){return{unique:{},distinct:{},multiple:{}}}const Vt=n=>{const e=n;if(!e.data)throw new l.ErrorInfo("received incoming message without data",5e4,500);if(!e.clientId)throw new l.ErrorInfo("received incoming message without clientId",5e4,500);if(!e.extras)throw new l.ErrorInfo("received incoming message without extras",5e4,500);if(e.action!==b.MessageDelete&&e.data.text===void 0)throw new l.ErrorInfo("received incoming message without text",5e4,500);if(e.action!==b.MessageDelete&&!e.extras.headers)throw new l.ErrorInfo("received incoming message without headers",5e4,500);if(e.action!==b.MessageDelete&&!e.data.metadata)throw new l.ErrorInfo("received incoming message without metadata",5e4,500);if(!e.serial)throw new l.ErrorInfo("received incoming message without serial",5e4,500);if(!e.version)throw new l.ErrorInfo("received incoming message without version",5e4,500);if(!e.createdAt)throw new l.ErrorInfo("received incoming message without createdAt",5e4,500);if(!e.timestamp)throw new l.ErrorInfo("received incoming message without timestamp",5e4,500);switch(e.action){case b.MessageCreate:case b.MessageUpdate:case b.MessageDelete:break;default:throw new l.ErrorInfo(`received incoming message with unhandled action; ${e.action}`,5e4,500)}const t=e.action===b.MessageDelete?{}:e.data,i=e.action===b.MessageDelete?{}:e.extras;return new N({serial:e.serial,clientId:e.clientId,text:t.text??"",metadata:t.metadata??{},headers:i.headers??{},action:e.action,version:e.version,createdAt:new Date(e.createdAt),timestamp:new Date(e.timestamp),reactions:ye(),operation:e.operation})},ee=n=>{let e="";if(typeof n=="string")e=n;else try{"serial"in n&&(e=n.serial)}catch{}if(e==="")throw new l.ErrorInfo("invalid serial; must be string or object with serial property",4e4,400);return e},Gt={"annotation.create":M.Create,"annotation.delete":M.Delete};class ze{constructor(e,t,i,a,c){this._logger=e,this._options=t,this._api=i,this._roomName=a,this._channel=c,this._emitter=new C,c.subscribe(this._processMessageEvent.bind(this)),this._options?.rawMessageReactions&&c.annotations.subscribe(this._processAnnotationEvent.bind(this)),this._defaultType=this._options?.defaultMessageReactionType??A.Distinct}_processAnnotationEvent(e){if(this._logger.trace("MessagesReactions._processAnnotationEvent();",{event:e}),!e.messageSerial){this._logger.warn("DefaultMessageReactions._processAnnotationEvent(); received event with missing messageSerial",{event:e});return}const t=zt[e.type];if(!t){this._logger.debug("DefaultMessageReactions._processAnnotationEvent(); received event with unknown type",{event:e});return}const i=Gt[e.action];if(!i){this._logger.warn("DefaultMessageReactions._processAnnotationEvent(); received event with unknown action",{event:e});return}let a=e.name;if(!a)if(i===M.Delete&&t===A.Unique)a="";else return;const c={type:i,timestamp:new Date(e.timestamp),reaction:{messageSerial:e.messageSerial,type:t,name:a,clientId:e.clientId??""}};e.count?c.reaction.count=e.count:i===M.Create&&t===A.Multiple&&(c.reaction.count=1),this._emitter.emit(i,c)}_processMessageEvent(e){if(this._logger.trace("MessagesReactions._processMessageEvent();",{event:e}),e.action!==b.MessageAnnotationSummary)return;if(e.summary||(e.summary={}),!e.serial){this._logger.warn("DefaultMessageReactions._processMessageEvent(); received summary without serial",{event:e});return}const t=e.summary[X.Unique]??{},i=e.summary[X.Distinct]??{},a=e.summary[X.Multiple]??{};this._emitter.emit(M.Summary,{type:M.Summary,summary:{messageSerial:e.serial,unique:t,distinct:i,multiple:a}})}send(e,t){this._logger.trace("MessagesReactions.add();",{messageSerial:e,params:t});const i=ee(e);let{type:a,count:c}=t;a||(a=this._defaultType),a===A.Multiple&&!c&&(c=1);const u={type:a,name:t.name};return c&&(u.count=c),this._api.addMessageReaction(this._roomName,i,u)}delete(e,t){this._logger.trace("MessagesReactions.delete();",{messageSerial:e,params:t});const i=ee(e);let a=t?.type;if(a||(a=this._defaultType),a!==A.Unique&&!t?.name)throw new l.ErrorInfo(`cannot delete reaction of type ${a} without a name`,40001,400);const c={type:a};return a!==A.Unique&&(c.name=t?.name),this._api.deleteMessageReaction(this._roomName,i,c)}subscribe(e){this._logger.trace("MessagesReactions.subscribe();");const t=I(e);return this._emitter.on(M.Summary,t),{unsubscribe:()=>{this._emitter.off(t)}}}subscribeRaw(e){if(this._logger.trace("MessagesReactions.subscribeRaw();"),!this._options?.rawMessageReactions)throw new l.ErrorInfo("Raw message reactions are not enabled",40001,400);const t=I(e);return this._emitter.on([M.Create,M.Delete],t),{unsubscribe:()=>{this._emitter.off(t)}}}static channelOptionMerger(e){return t=>(t.modes.includes("ANNOTATION_PUBLISH")||t.modes.push("ANNOTATION_PUBLISH"),e.messages.rawMessageReactions&&!t.modes.includes("ANNOTATION_SUBSCRIBE")&&t.modes.push("ANNOTATION_SUBSCRIBE"),t)}}const be=n=>{const e={...ye(),...n.reactions},t=Object.values(b).includes(n.action)?n.action:b.MessageCreate;return new N({...n,action:t,createdAt:new Date(n.createdAt),timestamp:new Date(n.timestamp),reactions:e})},Wt=new Map([[b.MessageCreate,E.Created],[b.MessageUpdate,E.Updated],[b.MessageDelete,E.Deleted]]);var te=(n=>(n.OldestFirst="oldestFirst",n.NewestFirst="newestFirst",n))(te||{});class Kt{constructor(e,t,i,a,c,u){this._emitter=new C,this._roomName=e,this._options=t,this._channel=i,this._chatApi=a,this._clientId=c,this._logger=u,this._listenerSubscriptionPoints=new Map,this.reactions=new ze(this._logger,t,this._chatApi,this._roomName,this._channel),this._applyChannelSubscriptions()}_applyChannelSubscriptions(){this._channel.subscribe([ke.ChatMessage],this._processEvent.bind(this)),this._channel.on("attached",e=>{this._handleAttach(e.resumed)}),this._channel.on("update",e=>{e.current==="attached"&&e.previous==="attached"&&this._handleAttach(e.resumed)})}async _getBeforeSubscriptionStart(e,t){this._logger.trace("DefaultSubscriptionManager.getBeforeSubscriptionStart();");const i=this._listenerSubscriptionPoints.get(e);if(i===void 0)throw this._logger.error("DefaultSubscriptionManager.getBeforeSubscriptionStart(); listener has not been subscribed yet"),new l.ErrorInfo("cannot query history; listener has not been subscribed yet",4e4,400);const a=await i;return this._chatApi.getMessages(this._roomName,{...t,orderBy:"newestFirst",...a})}_handleAttach(e){if(this._logger.trace("DefaultSubscriptionManager.handleAttach();"),e)return;const t=this._subscribeAtChannelAttach();for(const[i]of this._listenerSubscriptionPoints.entries())this._listenerSubscriptionPoints.set(i,t)}async _resolveSubscriptionStart(){const e=this._getChannelProperties();if(e.state==="attached"){if(e.properties.channelSerial)return{fromSerial:e.properties.channelSerial};throw this._logger.error("DefaultSubscriptionManager.handleAttach(); channelSerial is undefined"),new l.ErrorInfo("channel is attached, but channelSerial is not defined",4e4,400)}return this._subscribeAtChannelAttach()}_getChannelProperties(){return this._channel}async _subscribeAtChannelAttach(){const e=this._getChannelProperties();return new Promise((t,i)=>{e.state==="attached"&&(this._logger.debug("Messages._subscribeAtChannelAttach(); channel is attached already, using attachSerial",{attachSerial:e.properties.attachSerial}),e.properties.attachSerial?t({fromSerial:e.properties.attachSerial}):(this._logger.error("DefaultSubscriptionManager.handleAttach(); attachSerial is undefined"),i(new l.ErrorInfo("channel is attached, but attachSerial is not defined",4e4,400)))),e.once("attached",()=>{this._logger.debug("Messages._subscribeAtChannelAttach(); channel is now attached, using attachSerial",{attachSerial:e.properties.attachSerial}),e.properties.attachSerial?t({fromSerial:e.properties.attachSerial}):(this._logger.error("DefaultSubscriptionManager.handleAttach(); attachSerial is undefined"),i(new l.ErrorInfo("channel is attached, but attachSerial is not defined",4e4,400)))})})}async history(e){return this._logger.trace("Messages.query();"),this._chatApi.getMessages(this._roomName,e)}async send(e){this._logger.trace("Messages.send();",{params:e});const{text:t,metadata:i,headers:a}=e,c=await this._chatApi.sendMessage(this._roomName,{text:t,headers:a,metadata:i});return new N({serial:c.serial,clientId:this._clientId,text:t,metadata:i??{},headers:a??{},action:b.MessageCreate,version:c.serial,createdAt:new Date(c.createdAt),timestamp:new Date(c.createdAt),reactions:ye()})}async delete(e,t){this._logger.trace("Messages.delete();",{params:t}),e=ee(e),this._logger.debug("Messages.delete(); serial",{serial:e});const i=await this._chatApi.deleteMessage(this._roomName,e,t);return be(i.message)}async update(e,t,i){this._logger.trace("Messages.update();",{updateParams:t,details:i}),e=ee(e),this._logger.debug("Messages.update(); serial",{serial:e});const a=await this._chatApi.updateMessage(this._roomName,e,{message:{text:t.text,metadata:t.metadata,headers:t.headers},...i});return this._logger.debug("Messages.update(); message update successfully",{updateParams:t}),be(a.message)}subscribe(e){this._logger.trace("Messages.subscribe();");const t=I(e);this._emitter.on([E.Created,E.Updated,E.Deleted],t);const i=this._resolveSubscriptionStart();return i.catch(()=>{this._logger.debug("Messages.subscribe(); subscription point was not resolved before the room was released")}),this._listenerSubscriptionPoints.set(t,i),{unsubscribe:()=>{this._listenerSubscriptionPoints.delete(t),this._logger.trace("Messages.unsubscribe();"),this._emitter.off(t)},historyBeforeSubscribe:a=>this._getBeforeSubscriptionStart(t,a)}}_processEvent(e){this._logger.trace("Messages._processEvent();",{channelEventMessage:e});const{action:t}=e,i=Wt.get(t);if(!i){this._logger.debug("Messages._processEvent(); received unknown message action",{action:t});return}const a=this._parseNewMessage(e);a&&this._emitter.emit(i,{type:i,message:a})}_parseNewMessage(e){try{return Vt(e)}catch(t){this._logger.error("failed to parse incoming message;",{channelEventMessage:e,error:t})}}}class Qt{constructor(e,t){this._apiProtocolVersion=3,this._realtime=e,this._logger=t}async getMessages(e,t){e=encodeURIComponent(e);const i={...t};if(t.orderBy)switch(t.orderBy){case te.NewestFirst:{i.direction="backwards";break}case te.OldestFirst:{i.direction="forwards";break}default:throw new l.ErrorInfo(`invalid orderBy value: ${t.orderBy}`,4e4,400)}const a=await this._makeAuthorizedPaginatedRequest(`/chat/v3/rooms/${e}/messages`,i);return this._recursivePaginateMessages(a)}_recursivePaginateMessages(e){const t={};return t.items=e.items.map(i=>be(i)),t.next=()=>e.next().then(i=>i?this._recursivePaginateMessages(i):null),t.first=()=>e.first().then(i=>this._recursivePaginateMessages(i)),t.current=()=>e.current().then(i=>this._recursivePaginateMessages(i)),t.hasNext=()=>e.hasNext(),t.isLast=()=>e.isLast(),{...e,...t}}deleteMessage(e,t,i){const a={description:i?.description,metadata:i?.metadata};return t=encodeURIComponent(t),e=encodeURIComponent(e),this._makeAuthorizedRequest(`/chat/v3/rooms/${e}/messages/${t}/delete`,"POST",a,{})}sendMessage(e,t){const i={text:t.text};return t.metadata&&(i.metadata=t.metadata),t.headers&&(i.headers=t.headers),e=encodeURIComponent(e),this._makeAuthorizedRequest(`/chat/v3/rooms/${e}/messages`,"POST",i)}updateMessage(e,t,i){const a=encodeURIComponent(t);return e=encodeURIComponent(e),this._makeAuthorizedRequest(`/chat/v3/rooms/${e}/messages/${a}`,"PUT",i)}addMessageReaction(e,t,i){const a=encodeURIComponent(t);return e=encodeURIComponent(e),this._makeAuthorizedRequest(`/chat/v3/rooms/${e}/messages/${a}/reactions`,"POST",i)}deleteMessageReaction(e,t,i){const a=encodeURIComponent(t);return e=encodeURIComponent(e),this._makeAuthorizedRequest(`/chat/v3/rooms/${e}/messages/${a}/reactions`,"DELETE",void 0,i)}getOccupancy(e){return e=encodeURIComponent(e),this._makeAuthorizedRequest(`/chat/v3/rooms/${e}/occupancy`,"GET")}async _makeAuthorizedRequest(e,t,i,a){const c=await this._realtime.request(t,e,this._apiProtocolVersion,a,i);if(!c.success)throw this._logger.error("ChatApi._makeAuthorizedRequest(); failed to make request",{url:e,statusCode:c.statusCode,errorCode:c.errorCode,errorMessage:c.errorMessage}),new l.ErrorInfo(c.errorMessage,c.errorCode,c.statusCode);return c.items[0]}async _makeAuthorizedPaginatedRequest(e,t,i){const a=await this._realtime.request("GET",e,this._apiProtocolVersion,t,i);if(!a.success)throw this._logger.error("ChatApi._makeAuthorizedPaginatedRequest(); failed to make request",{url:e,statusCode:a.statusCode,errorCode:a.errorCode,errorMessage:a.errorMessage}),new l.ErrorInfo(a.errorMessage,a.errorCode,a.statusCode);return a}}var q=(n=>(n[n.BadRequest=4e4]="BadRequest",n[n.MessageRejectedByBeforePublishRule=42211]="MessageRejectedByBeforePublishRule",n[n.MessageRejectedByModeration=42213]="MessageRejectedByModeration",n[n.RoomDiscontinuity=102100]="RoomDiscontinuity",n[n.RoomInFailedState=102101]="RoomInFailedState",n[n.RoomIsReleasing=102102]="RoomIsReleasing",n[n.RoomIsReleased=102103]="RoomIsReleased",n[n.RoomReleasedBeforeOperationCompleted=102106]="RoomReleasedBeforeOperationCompleted",n))(q||{});const Jt=(n,e)=>n.code===e,Xt=()=>Math.random().toString(36).slice(2),Yt=n=>`${n}::$chat`,re="0.10.0",Zt=`chat-js/${re}`,er=`chat-react/${re}`,$e=["PUBLISH","SUBSCRIBE"],tr={params:{agent:Zt},attachOnSubscribe:!1,modes:$e},rr={params:{agent:er},attachOnSubscribe:!1,modes:$e};class nr{constructor(e,t,i,a){i.trace("ChannelManager();",{isReact:a}),this._realtime=t,this._logger=i,this._isReact=a,this._registeredOptions=this._defaultChannelOptions(),this._channelId=Yt(e)}mergeOptions(e){if(this._logger.trace("ChannelManager.mergeOptions();"),this._resolvedChannel)throw this._logger.error("channel options cannot be modified after the channel has been requested"),new l.ErrorInfo("channel options cannot be modified after the channel has been requested",4e4,400);this._registeredOptions=e(this._registeredOptions)}get(){return this._logger.trace("ChannelManager.get();"),this._resolvedChannel??=this._realtime.channels.get(this._channelId,this._registeredOptions),this._resolvedChannel}release(){this._logger.trace("ChannelManager.release();",{channelId:this._channelId}),this._resolvedChannel&&this._realtime.channels.release(this._channelId)}_defaultChannelOptions(){this._logger.trace("ChannelManager._defaultChannelOptions();");const e=this._isReact?rr:tr;return this._logger.trace(this._isReact?"using react channel options":"using default channel options"),{...e,modes:[...e.modes??[]]}}}class Fe{constructor(e,t,i,a,c){this._emitter=new C,this._roomName=e,this._channel=t,this._chatApi=i,this._logger=a,this._roomOptions=c,this._applyChannelSubscriptions()}_applyChannelSubscriptions(){this._channel.subscribe([je.Occupancy],this._internalOccupancyListener.bind(this))}subscribe(e){if(this._logger.trace("Occupancy.subscribe();"),!this._roomOptions.occupancy.enableEvents)throw new l.ErrorInfo("cannot subscribe to occupancy; occupancy events are not enabled in room options",4e4,400);const t=I(e);return this._emitter.on(t),{unsubscribe:()=>{this._logger.trace("Occupancy.unsubscribe();"),this._emitter.off(t)}}}async get(){return this._logger.trace("Occupancy.get();"),this._chatApi.getOccupancy(this._roomName)}current(){if(this._logger.trace("Occupancy.current();"),!this._roomOptions.occupancy.enableEvents)throw new l.ErrorInfo("cannot get current occupancy; occupancy events are not enabled in room options",4e4,400);return this._latestOccupancyData}_internalOccupancyListener(e){if(this._logger.trace("Occupancy._internalOccupancyListener();",e),typeof e.data!="object"){this._logger.error("Occupancy._internalOccupancyListener(); invalid occupancy event received; data is not an object",e);return}const{metrics:t}=e.data;if(t===void 0){this._logger.error("Occupancy._internalOccupancyListener(); invalid occupancy event received; metrics is missing",e);return}const{connections:i,presenceMembers:a}=t;if(i===void 0){this._logger.error("Occupancy._internalOccupancyListener(); invalid occupancy event received; connections is missing",e);return}if(!Number.isInteger(i)){this._logger.error("Occupancy._internalOccupancyListener(); invalid occupancy event received; connections is not a number",e);return}if(a===void 0){this._logger.error("Occupancy._internalOccupancyListener(); invalid occupancy event received; presenceMembers is missing",e);return}if(!Number.isInteger(a)){this._logger.error("Occupancy._internalOccupancyListener(); invalid occupancy event received; presenceMembers is not a number",e);return}this._latestOccupancyData={connections:i,presenceMembers:a},this._emitter.emit(Y.Updated,{type:Y.Updated,occupancy:this._latestOccupancyData})}static channelOptionMerger(e){return t=>e.occupancy.enableEvents?{...t,params:{...t.params,occupancy:"metrics"}}:t}}class He{constructor(e,t,i,a){this._emitter=new C,this.subscribeToEvents=c=>{try{const u=c.data;this._emitter.emit(c.action,{type:c.action,member:{clientId:c.clientId,data:u.userCustomData,extras:c.extras,updatedAt:c.timestamp}})}catch(u){throw this._logger.error("unable to handle presence event: not a valid presence event",{action:c.action}),new l.ErrorInfo(`unable to handle ${c.action} presence event: not a valid presence event`,5e4,500,u.message)}},this._channel=e,this._clientId=t,this._logger=i,this._options=a,this._applyChannelSubscriptions()}_applyChannelSubscriptions(){this._channel.presence.subscribe(this.subscribeToEvents.bind(this))}async get(e){return this._logger.trace("Presence.get()",{params:e}),this._assertChannelState(),(await this._channel.presence.get(e)).map(i=>({clientId:i.clientId,data:i.data?.userCustomData,updatedAt:i.timestamp,extras:i.extras}))}async isUserPresent(e){return this._logger.trace("Presence.isUserPresent()",{clientId:e}),this._assertChannelState(),(await this._channel.presence.get({clientId:e})).length>0}async enter(e){this._logger.trace("Presence.enter()",{data:e}),this._assertChannelState();const t={userCustomData:e};return this._channel.presence.enterClient(this._clientId,t)}async update(e){this._logger.trace("Presence.update()",{data:e}),this._assertChannelState();const t={userCustomData:e};return this._channel.presence.updateClient(this._clientId,t)}async leave(e){this._logger.trace("Presence.leave()",{data:e}),this._assertChannelState();const t={userCustomData:e};return this._channel.presence.leaveClient(this._clientId,t)}subscribe(e,t){if(this._logger.trace("Presence.subscribe(); listenerOrEvents",{listenerOrEvents:e}),!this._options.presence.enableEvents)throw this._logger.error("could not subscribe to presence; presence events are not enabled"),new l.ErrorInfo("could not subscribe to presence; presence events are not enabled",4e4,400);if(!e&&!t)throw this._logger.error("could not subscribe to presence; invalid arguments"),new l.ErrorInfo("could not subscribe listener: invalid arguments",4e4,400);if(t){const i=I(t);return this._emitter.on(e,i),{unsubscribe:()=>{this._logger.trace("Presence.unsubscribe();",{events:e}),this._emitter.off(i)}}}else{const i=I(e);return this._emitter.on(i),{unsubscribe:()=>{this._logger.trace("Presence.unsubscribe();"),this._emitter.off(i)}}}}static channelOptionMerger(e){return t=>(t.modes.includes("PRESENCE")||t.modes.push("PRESENCE"),e.presence.enableEvents&&!t.modes.includes("PRESENCE_SUBSCRIBE")&&t.modes.push("PRESENCE_SUBSCRIBE"),t)}_assertChannelState(){if(this._channel.state!=="attaching"&&this._channel.state!=="attached")throw this._logger.error("could not perform presence operation; room is not attached"),new l.ErrorInfo("could not perform presence operation; room is not attached",4e4,400)}}const ne=new Error("request for lock canceled");var ir=function(n,e,t,i){function a(c){return c instanceof t?c:new t(function(u){u(c)})}return new(t||(t=Promise))(function(c,u){function m(_){try{y(i.next(_))}catch(v){u(v)}}function p(_){try{y(i.throw(_))}catch(v){u(v)}}function y(_){_.done?c(_.value):a(_.value).then(m,p)}y((i=i.apply(n,e||[])).next())})};class sr{constructor(e,t=ne){this._value=e,this._cancelError=t,this._queue=[],this._weightedWaiters=[]}acquire(e=1,t=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return new Promise((i,a)=>{const c={resolve:i,reject:a,weight:e,priority:t},u=Ve(this._queue,m=>t<=m.priority);u===-1&&e<=this._value?this._dispatchItem(c):this._queue.splice(u+1,0,c)})}runExclusive(e){return ir(this,arguments,void 0,function*(t,i=1,a=0){const[c,u]=yield this.acquire(i,a);try{return yield t(c)}finally{u()}})}waitForUnlock(e=1,t=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return this._couldLockImmediately(e,t)?Promise.resolve():new Promise(i=>{this._weightedWaiters[e-1]||(this._weightedWaiters[e-1]=[]),ar(this._weightedWaiters[e-1],{resolve:i,priority:t})})}isLocked(){return this._value<=0}getValue(){return this._value}setValue(e){this._value=e,this._dispatchQueue()}release(e=1){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);this._value+=e,this._dispatchQueue()}cancel(){this._queue.forEach(e=>e.reject(this._cancelError)),this._queue=[]}_dispatchQueue(){for(this._drainUnlockWaiters();this._queue.length>0&&this._queue[0].weight<=this._value;)this._dispatchItem(this._queue.shift()),this._drainUnlockWaiters()}_dispatchItem(e){const t=this._value;this._value-=e.weight,e.resolve([t,this._newReleaser(e.weight)])}_newReleaser(e){let t=!1;return()=>{t||(t=!0,this.release(e))}}_drainUnlockWaiters(){if(this._queue.length===0)for(let e=this._value;e>0;e--){const t=this._weightedWaiters[e-1];t&&(t.forEach(i=>i.resolve()),this._weightedWaiters[e-1]=[])}else{const e=this._queue[0].priority;for(let t=this._value;t>0;t--){const i=this._weightedWaiters[t-1];if(!i)continue;const a=i.findIndex(c=>c.priority<=e);(a===-1?i:i.splice(0,a)).forEach(c=>c.resolve())}}}_couldLockImmediately(e,t){return(this._queue.length===0||this._queue[0].priority<t)&&e<=this._value}}function ar(n,e){const t=Ve(n,i=>e.priority<=i.priority);n.splice(t+1,0,e)}function Ve(n,e){for(let t=n.length-1;t>=0;t--)if(e(n[t]))return t;return-1}var or=function(n,e,t,i){function a(c){return c instanceof t?c:new t(function(u){u(c)})}return new(t||(t=Promise))(function(c,u){function m(_){try{y(i.next(_))}catch(v){u(v)}}function p(_){try{y(i.throw(_))}catch(v){u(v)}}function y(_){_.done?c(_.value):a(_.value).then(m,p)}y((i=i.apply(n,e||[])).next())})};class Ge{constructor(e){this._semaphore=new sr(1,e)}acquire(){return or(this,arguments,void 0,function*(e=0){const[,t]=yield this._semaphore.acquire(1,e);return t})}runExclusive(e,t=0){return this._semaphore.runExclusive(()=>e(),1,t)}isLocked(){return this._semaphore.isLocked()}waitForUnlock(e=0){return this._semaphore.waitForUnlock(1,e)}release(){this._semaphore.isLocked()&&this._semaphore.release()}cancel(){return this._semaphore.cancel()}}var d=(n=>(n.Initializing="initializing",n.Initialized="initialized",n.Attaching="attaching",n.Attached="attached",n.Detaching="detaching",n.Detached="detached",n.Suspended="suspended",n.Failed="failed",n.Releasing="releasing",n.Released="released",n))(d||{});class cr{constructor(e){this._status="initialized",this._internalEmitter=new C,this._emitter=new C,this._logger=e}get status(){return this._status}get error(){return this._error}onChange(e){const t=I(e);return this._emitter.on(t),{off:()=>{this._emitter.off(t)}}}setStatus(e){const t={current:e.status,error:e.error,previous:this._status};this._status=t.current,this._error=t.error,this._logger.info("room status changed",{...t}),this._internalEmitter.emit(t.current,t),this._emitter.emit(t.current,t)}}class hr{constructor(e,t,i){this._channelManager=e,this._roomLifecycle=t,this._logger=i,this._eventEmitter=new C,this._hasAttachedOnce=!1,this._isExplicitlyDetached=!1,this._mutex=new Ge,this._startMonitoringChannelState(),this._startMonitoringDiscontinuity()}_startMonitoringChannelState(){this._channelManager.get().on(t=>{if(this._logger.debug("RoomLifecycleManager.channel state changed",{oldState:t.previous,newState:t.current,reason:t.reason,resumed:t.resumed}),this._operationInProgress()){this._logger.debug("RoomLifecycleManager._startMonitoringChannelState(); ignoring channel state change - operation in progress",{status:this._roomLifecycle.status});return}const i=this._mapChannelStateToRoomStatus(t.current);this._setStatus(i,t.reason)})}_startMonitoringDiscontinuity(){const e=this._channelManager.get();e.on("attached",t=>{if(!t.resumed&&this._hasAttachedOnce&&!this._isExplicitlyDetached){const i=new l.ErrorInfo("discontinuity detected",q.RoomDiscontinuity,t.reason?.statusCode??0,t.reason);this._logger.warn("RoomLifecycleManager._startMonitoringDiscontinuity(); discontinuity detected",{error:i}),this._eventEmitter.emit(z.Discontinuity,i)}}),e.on("update",t=>{if(!t.resumed&&this._hasAttachedOnce&&!this._isExplicitlyDetached&&t.current==="attached"&&t.previous==="attached"){const i=new l.ErrorInfo("discontinuity detected",q.RoomDiscontinuity,t.reason?.statusCode??0,t.reason);this._logger.warn("RoomLifecycleManager._startMonitoringDiscontinuity(); discontinuity detected",{error:i}),this._eventEmitter.emit(z.Discontinuity,i)}})}onDiscontinuity(e){this._logger.trace("RoomLifecycleManager.onDiscontinuity()");const t=I(e);return this._eventEmitter.on(z.Discontinuity,t),{off:()=>{this._eventEmitter.off(z.Discontinuity,t)}}}async attach(){await this._mutex.runExclusive(async()=>{if(this._logger.trace("RoomLifecycleManager.attach();"),this._checkRoomNotReleasing("attach"),this._roomStatusIs(d.Attached)){this._logger.debug("RoomLifecycleManager.attach(); room already attached, no-op");return}const e=this._channelManager.get();this._logger.debug("RoomLifecycleManager.attach(); attaching room",{channelState:e.state});try{this._setStatus(d.Attaching),await e.attach(),this._setStatus(d.Attached),this._isExplicitlyDetached=!1,this._hasAttachedOnce=!0,this._logger.debug("RoomLifecycleManager.attach(); room attached successfully")}catch(t){const i=t,a=new l.ErrorInfo(`failed to attach room: ${i.message}`,i.code,i.statusCode,i),c=this._mapChannelStateToRoomStatus(e.state);throw this._setStatus(c,a),a}},1)}async detach(){await this._mutex.runExclusive(async()=>{if(this._logger.trace("RoomLifecycleManager.detach();"),this._roomStatusIs(d.Failed))throw new l.ErrorInfo("cannot detach room, room is in failed state",q.RoomInFailedState,400);if(this._checkRoomNotReleasing("detach"),this._roomStatusIs(d.Detached)){this._logger.debug("RoomLifecycleManager.detach(); room already detached, no-op");return}const e=this._channelManager.get();this._logger.debug("RoomLifecycleManager.detach(); detaching room",{channelState:e.state});try{this._setStatus(d.Detaching),await e.detach(),this._isExplicitlyDetached=!0,this._setStatus(d.Detached),this._logger.debug("RoomLifecycleManager.detach(); room detached successfully")}catch(t){const i=t,a=new l.ErrorInfo(`failed to detach room: ${i.message}`,i.code,i.statusCode,i),c=this._mapChannelStateToRoomStatus(e.state);throw this._setStatus(c,a),a}},1)}async release(){await this._mutex.runExclusive(async()=>{if(this._logger.trace("RoomLifecycleManager.release();"),this._roomStatusIs(d.Released)){this._logger.debug("RoomLifecycleManager.release(); room already released, no-op");return}if(this._roomStatusIs(d.Initialized)||this._roomStatusIs(d.Detached)){this._logger.debug("RoomLifecycleManager.release(); room is initialized or detached, releasing immediately",{status:this._roomLifecycle.status}),this._releaseChannel();return}this._setStatus(d.Releasing);const e=this._channelManager.get();this._logger.debug("RoomLifecycleManager.release(); attempting channel detach before release",{channelState:e.state}),await this._channelDetachLoop(e),this._releaseChannel()},0)}_mapChannelStateToRoomStatus(e){switch(e){case"initialized":return d.Initialized;case"attaching":return d.Attaching;case"attached":return d.Attached;case"detaching":return d.Detaching;case"detached":return d.Detached;case"suspended":return d.Suspended;case"failed":return d.Failed;default:return this._logger.error("RoomLifecycleManager._mapChannelStateToRoomStatus(); unknown channel state",{channelState:e}),d.Failed}}_checkRoomNotReleasing(e){switch(this._roomLifecycle.status){case d.Released:throw new l.ErrorInfo(`cannot ${e} room, room is released`,q.RoomIsReleased,400);case d.Releasing:throw new l.ErrorInfo(`cannot ${e} room, room is currently releasing`,q.RoomIsReleasing,400)}}_roomStatusIs(e){return this._roomLifecycle.status===e}async _channelDetachLoop(e){for(;;){if(e.state==="failed"){this._logger.debug("RoomLifecycleManager._channelDetachLoop(); channel is failed, skipping detach");break}try{await e.detach();break}catch(i){this._logger.error("RoomLifecycleManager._channelDetachLoop(); failed to detach channel during release",{error:i}),await new Promise(a=>setTimeout(a,250))}}}_setStatus(e,t){this._logger.debug("RoomLifecycleManager._setStatus(); updating room status",{oldStatus:this._roomLifecycle.status,newStatus:e,hasError:!!t}),this._roomLifecycle.setStatus({status:e,error:t})}_releaseChannel(){this._channelManager.release(),this._setStatus(d.Released),this._logger.debug("RoomLifecycleManager._releaseChannel(); room released successfully")}_operationInProgress(){return this._mutex.isLocked()}testForceHasAttachedOnce(e){this._hasAttachedOnce=e}}const ie={typing:{heartbeatThrottleMs:1e4},occupancy:{enableEvents:!1},presence:{enableEvents:!0},messages:{rawMessageReactions:!1,defaultMessageReactionType:A.Distinct}},lr=n=>new l.ErrorInfo(`invalid room configuration: ${n}`,40001,400),ur=n=>{gr(n.typing)},gr=n=>{if(n.heartbeatThrottleMs<=0)throw lr("typing heartbeat interval must be greater than 0")},dr=n=>({...ie.typing,...n?.typing}),_r=n=>({...ie.occupancy,...n?.occupancy}),pr=n=>({...ie.presence,...n?.presence}),fr=n=>({...ie.messages,...n?.messages}),mr=(n,e)=>({typing:dr(n),occupancy:_r(n),presence:pr(n),messages:fr(n),isReactClient:e}),We=(n,e)=>({name:n,data:e,extras:{ephemeral:!0}}),yr=n=>{const e=n.extras?n.extras:{};return{...n,extras:{...e,ephemeral:!0}}};class br{constructor(e,t,i,a,c,u){this.name=e,this.clientId=t,this.createdAt=i,this.isSelf=a,this.metadata=c,this.headers=u,Object.freeze(this)}}function wr(n,e){const t=n;if(!t.data)throw new l.ErrorInfo("received incoming room reaction message without data",5e4,500);if(!t.data.name||typeof t.data.name!="string")throw new l.ErrorInfo("invalid room reaction message with no name",5e4,500);if(!t.clientId)throw new l.ErrorInfo("received incoming room reaction message without clientId",5e4,500);if(!t.timestamp)throw new l.ErrorInfo("received incoming room reaction message without timestamp",5e4,500);return new br(t.data.name,t.clientId,new Date(t.timestamp),e?e===t.clientId:!1,t.data.metadata??{},t.extras?.headers??{})}class vr{constructor(e,t,i,a){this._emitter=new C,this._forwarder=c=>{const u=this._parseNewReaction(c,this._clientId);u&&this._emitter.emit(me.Reaction,{type:me.Reaction,reaction:u})},this._channel=e,this._connection=t,this._clientId=i,this._logger=a,this._applyChannelSubscriptions()}_applyChannelSubscriptions(){this._channel.subscribe([fe.Reaction],this._forwarder.bind(this))}send(e){this._logger.trace("RoomReactions.send();",e);const{name:t,metadata:i,headers:a}=e;if(!t)return Promise.reject(new l.ErrorInfo("unable to send reaction; name not set and it is required",40001,400));if(this._connection.state!=="connected")return Promise.reject(new l.ErrorInfo("unable to send reaction; not connected to Ably",4e4,400));const c={name:t,metadata:i??{}},u={name:fe.Reaction,data:c,extras:{headers:a??{}}};return this._channel.publish(yr(u))}subscribe(e){this._logger.trace("RoomReactions.subscribe();");const t=I(e);return this._emitter.on(t),{unsubscribe:()=>{this._logger.trace("RoomReactions.unsubscribe();"),this._emitter.off(t)}}}_parseNewReaction(e,t){try{return wr(e,t)}catch(i){this._logger.error("failed to parse incoming reaction;",{inbound:e,error:i})}}}class Sr extends C{constructor(e,t,i,a,c){super(),this._timeoutMs=2e3,this._mutex=new Ge,this._internalSubscribeToEvents=u=>{const{name:m,clientId:p}=u;if(this._logger.trace("DefaultTyping._internalSubscribeToEvents(); received event",{name:m,clientId:p}),!p){this._logger.error("DefaultTyping._internalSubscribeToEvents(); invalid clientId in received event",{inbound:u});return}m===R.Start||m===R.Stop?this._updateCurrentlyTyping(p,m):this._logger.warn("DefaultTyping._internalSubscribeToEvents(); unrecognized event",{name:m})},this._clientId=a,this._channel=i,this._connection=t,this._heartbeatThrottleMs=e.heartbeatThrottleMs,this._currentlyTyping=new Map,this._logger=c,this._applyChannelSubscriptions()}_applyChannelSubscriptions(){this._channel.subscribe([R.Start,R.Stop],this._internalSubscribeToEvents.bind(this))}_clearAllTypingStates(){this._logger.debug("DefaultTyping._clearAllTypingStates(); clearing all typing states"),this._clearHeartbeatTimer(),this._clearCurrentlyTyping()}_clearHeartbeatTimer(){this._logger.trace("DefaultTyping._clearHeartbeatTimer(); clearing heartbeat timer"),this._heartbeatTimerId&&(clearTimeout(this._heartbeatTimerId),this._heartbeatTimerId=void 0)}_clearCurrentlyTyping(){this._logger.trace("DefaultTyping._clearCurrentlyTyping(); clearing current store and timeouts");for(const[,e]of this._currentlyTyping.entries())clearTimeout(e);this._currentlyTyping.clear()}current(){return this._logger.trace("DefaultTyping.current();"),new Set(this._currentlyTyping.keys())}get channel(){return this._channel}_startHeartbeatTimer(){if(!this._heartbeatTimerId){this._logger.trace("DefaultTyping.startHeartbeatTimer();");const e=this._heartbeatTimerId=setTimeout(()=>{this._logger.debug("DefaultTyping.startHeartbeatTimer(); heartbeat timer expired"),e===this._heartbeatTimerId&&(this._heartbeatTimerId=void 0)},this._heartbeatThrottleMs)}}async keystroke(){this._logger.trace("DefaultTyping.keystroke();"),this._mutex.cancel();try{await this._mutex.acquire()}catch(e){if(e===ne){this._logger.debug("DefaultTyping.keystroke(); mutex was canceled by a later operation");return}throw new l.ErrorInfo("mutex acquisition failed",5e4,500)}try{if(this._connection.state!=="connected")throw this._logger.error("DefaultTyping.keystroke(); connection is not connected",{status:this._connection.state}),new l.ErrorInfo("cannot type, connection is not connected",4e4,400);if(this._heartbeatTimerId){this._logger.debug("DefaultTyping.keystroke(); no-op, already typing and heartbeat timer has not expired");return}await this._channel.publish(We(R.Start)),this._startHeartbeatTimer(),this._logger.trace("DefaultTyping.keystroke(); starting timers")}finally{this._logger.trace("DefaultTyping.keystroke(); releasing mutex"),this._mutex.release()}}async stop(){this._logger.trace("DefaultTyping.stop();"),this._mutex.cancel();try{await this._mutex.acquire()}catch(e){if(e===ne){this._logger.debug("DefaultTyping.stop(); mutex was canceled by a later operation");return}throw new l.ErrorInfo("mutex acquisition failed",5e4,500)}try{if(this._connection.state!=="connected")throw this._logger.error("DefaultTyping.stop(); connection is not connected",{status:this._connection.state}),new l.ErrorInfo("cannot stop typing, connection is not connected",4e4,400);if(!this._heartbeatTimerId){this._logger.debug("DefaultTyping.stop(); no-op, not currently typing");return}await this._channel.publish(We(R.Stop)),this._logger.trace("DefaultTyping.stop(); clearing timers"),clearTimeout(this._heartbeatTimerId),this._heartbeatTimerId=void 0}finally{this._logger.trace("DefaultTyping.stop(); releasing mutex"),this._mutex.release()}}subscribe(e){this._logger.trace("DefaultTyping.subscribe();");const t=I(e);return this.on(t),{unsubscribe:()=>{this._logger.trace("DefaultTyping.unsubscribe();"),this.off(t)}}}async dispose(){for(this._logger.trace("DefaultTyping.dispose();");;)try{this._mutex.cancel(),await this._mutex.acquire();break}catch(e){if(e===ne)this._logger.debug("DefaultTyping.dispose(); mutex was canceled"),await new Promise(t=>setTimeout(t,200)),this._logger.debug("DefaultTyping.dispose(); retrying mutex acquisition");else{this._logger.error("DefaultTyping.dispose(); failed to acquire mutex; could not complete resource disposal",{error:e});return}}this._clearAllTypingStates(),this._mutex.release()}_updateCurrentlyTyping(e,t){this._logger.trace("DefaultTyping._updateCurrentlyTyping();",{clientId:e,event:t}),t===R.Start?this._handleTypingStart(e):this._handleTypingStop(e)}_startNewClientInactivityTimer(e){this._logger.trace("DefaultTyping._startNewClientInactivityTimer(); starting new inactivity timer",{clientId:e});const t=setTimeout(()=>{if(this._logger.trace("DefaultTyping._startNewClientInactivityTimer(); client typing timeout expired",{clientId:e}),this._currentlyTyping.get(e)!==t){this._logger.debug("DefaultTyping._startNewClientInactivityTimer(); timeout already cleared; ignoring",{clientId:e});return}this._currentlyTyping.delete(e),this.emit(L.SetChanged,{type:L.SetChanged,currentlyTyping:new Set(this._currentlyTyping.keys()),change:{clientId:e,type:R.Stop}})},this._heartbeatThrottleMs+this._timeoutMs);return t}_handleTypingStart(e){this._logger.debug("DefaultTyping._handleTypingStart();",{clientId:e});const t=this._startNewClientInactivityTimer(e),i=this._currentlyTyping.get(e);this._currentlyTyping.set(e,t),i?(this._logger.debug("DefaultTyping._handleTypingStart(); received heartbeat for currently typing client",{clientId:e}),clearTimeout(i)):(this._logger.debug("DefaultTyping._handleTypingStart(); new client started typing",{clientId:e}),this.emit(L.SetChanged,{type:L.SetChanged,currentlyTyping:new Set(this._currentlyTyping.keys()),change:{clientId:e,type:R.Start}}))}_handleTypingStop(e){const t=this._currentlyTyping.get(e);if(!t){this._logger.trace('DefaultTyping._handleTypingStop(); received "Stop" event for client not in currentlyTyping list',{clientId:e});return}this._logger.debug("DefaultTyping._handleTypingStop(); client stopped typing",{clientId:e}),clearTimeout(t),this._currentlyTyping.delete(e),this.emit(L.SetChanged,{type:L.SetChanged,currentlyTyping:new Set(this._currentlyTyping.keys()),change:{clientId:e,type:R.Stop}})}get heartbeatThrottleMs(){return this._heartbeatThrottleMs}get hasHeartbeatTimer(){return!!this._heartbeatTimerId}}class Tr{constructor(e,t,i,a,c,u){ur(i),this._nonce=t,this._logger=u.withContext({roomName:e,roomNonce:t}),this._logger.debug("Room();",{options:i}),this._name=e,this._options=i,this._chatApi=c,this._lifecycle=new cr(this._logger);const m=this._channelManager=this._getChannelManager(i,a,this._logger),p=m.get();this._messages=new Kt(e,i.messages,p,this._chatApi,a.auth.clientId,this._logger),this._presence=new He(p,a.auth.clientId,this._logger,i),this._typing=new Sr(i.typing,a.connection,p,a.auth.clientId,this._logger),this._reactions=new vr(p,a.connection,a.auth.clientId,this._logger),this._occupancy=new Fe(e,p,this._chatApi,this._logger,i),this._lifecycleManager=new hr(m,this._lifecycle,this._logger);let y=!1;this._finalizer=async()=>{if(y){this._logger.debug("Room.finalizer(); already finalized");return}await this._lifecycleManager.release(),await this._typing.dispose(),y=!0}}_getChannelManager(e,t,i){const a=new nr(this._name,t,i,e.isReactClient);return a.mergeOptions(Fe.channelOptionMerger(e)),a.mergeOptions(He.channelOptionMerger(e)),a.mergeOptions(ze.channelOptionMerger(e)),a}get name(){return this._name}options(){return P(this._options)}get messages(){return this._messages}get presence(){return this._presence}get reactions(){return this._reactions}get typing(){return this._typing}get occupancy(){return this._occupancy}get status(){return this._lifecycle.status}get error(){return this._lifecycle.error}onStatusChange(e){return this._lifecycle.onChange(e)}async attach(){return this._logger.trace("Room.attach();"),this._lifecycleManager.attach()}async detach(){return this._logger.trace("Room.detach();"),this._lifecycleManager.detach()}release(){return this._logger.trace("Room.release();"),this._finalizer()}get nonce(){return this._nonce}get lifecycle(){return this._lifecycle}get lifecycleManager(){return this._lifecycleManager}onDiscontinuity(e){return this._logger.trace("Room.onDiscontinuity();"),this._lifecycleManager.onDiscontinuity(e)}get channel(){return this._channelManager.get()}}class Rr{constructor(e,t,i){this._rooms=new Map,this._releasing=new Map,this._isReact=!1,this._realtime=e,this._chatApi=new Qt(e,i),this._clientOptions=t,this._logger=i}get(e,t){this._logger.trace("Rooms.get();",{roomName:e});const i=this._rooms.get(e);if(i)return W(i.options,t)?(this._logger.debug("Rooms.get(); returning existing room",{roomName:e,nonce:i.nonce}),i.promise):Promise.reject(new l.ErrorInfo("room already exists with different options",4e4,400));const a=this._releasing.get(e),c=Xt();if(!a){const p=this._makeRoom(e,c,t),y={promise:Promise.resolve(p),nonce:c,options:t};return this._rooms.set(e,y),this._logger.debug("Rooms.get(); returning new room",{roomName:e,nonce:p.nonce}),y.promise}const u=new AbortController,m=new Promise((p,y)=>{const _=()=>{this._logger.debug("Rooms.get(); aborted before init",{roomName:e}),y(new l.ErrorInfo("room released before get operation could complete",q.RoomReleasedBeforeOperationCompleted,400))};u.signal.addEventListener("abort",_),a.then(()=>{if(u.signal.aborted){this._logger.debug("Rooms.get(); aborted before releasing promise resolved",{roomName:e});return}this._logger.debug("Rooms.get(); releasing finished",{roomName:e});const v=this._makeRoom(e,c,t);u.signal.removeEventListener("abort",_),p(v)}).catch(v=>{y(v)})});return this._rooms.set(e,{promise:m,options:t,nonce:c,abort:u}),this._logger.debug("Rooms.get(); creating new promise dependent on previous release",{roomName:e}),m}get clientOptions(){return this._clientOptions}release(e){this._logger.trace("Rooms.release();",{roomName:e});const t=this._rooms.get(e),i=this._releasing.get(e);if(!t)return i?(this._logger.debug("Rooms.release(); waiting for previous release call",{roomName:e}),i):(this._logger.debug("Rooms.release(); room does not exist",{roomName:e}),Promise.resolve());if(i)return t.abort&&(this._logger.debug("Rooms.release(); aborting get call",{roomName:e,existingNonce:t.nonce}),t.abort.abort(),this._rooms.delete(e)),i;this._rooms.delete(e);const a=t.promise.then(c=>(this._logger.debug("Rooms.release(); releasing room",{roomName:e,nonce:t.nonce}),c.release().then(()=>{this._logger.debug("Rooms.release(); room released",{roomName:e,nonce:t.nonce}),this._releasing.delete(e)})));return this._logger.debug("Rooms.release(); creating new release promise",{roomName:e,nonce:t.nonce}),this._releasing.set(e,a),a}_makeRoom(e,t,i){return new Tr(e,t,mr(i,this._isReact),this._realtime,this._chatApi,this._logger)}useReact(){this._logger.trace("Rooms.useReact();"),this._isReact=!0}}class Mr{constructor(e,t){this._realtime=e,this._clientOptions=jt(t),this._logger=qt(this._clientOptions),this._connection=new Bt(e,this._logger),this._rooms=new Rr(e,this._clientOptions,this._logger),this._addAgent("chat-js"),this._logger.trace(`ably chat client version ${re}; initialized`)}get rooms(){return this._rooms}get connection(){return this._connection}get clientId(){return this._realtime.auth.clientId}get realtime(){return this._realtime}get clientOptions(){return this._clientOptions}get logger(){return this._logger}addReactAgent(){this._addAgent("chat-react"),this._rooms.useReact()}addAgentWithVersion(e,t){this._addAgent(e,t),this._logger.trace(`Added agent ${e} with version ${t}`)}_addAgent(e,t){const i=this._realtime;i.options.agents={...i.options.agents??i.options.agents,[e]:t??re}}}f.ChatClient=Mr,f.ChatMessageAction=b,f.ChatMessageEventType=E,f.ConnectionStatus=Pe,f.ErrorCode=q,f.LogLevel=_e,f.MessageReactionEventType=M,f.MessageReactionType=A,f.OccupancyEventType=Y,f.OrderBy=te,f.PresenceEventType=Ue,f.RoomEventType=z,f.RoomStatus=d,f.TypingEventType=R,f.TypingSetEventType=L,f.errorInfoIs=Jt,Object.defineProperty(f,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=ably-chat.umd.cjs.map
