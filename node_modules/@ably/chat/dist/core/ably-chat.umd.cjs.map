{"version":3,"file":"ably-chat.umd.cjs","sources":["../../src/core/logger.ts","../../src/core/config.ts","../../src/core/utils/event-emitter.ts","../../src/core/connection.ts","../../node_modules/dequal/dist/index.mjs","../../src/core/events.ts","../../node_modules/lodash.clonedeep/index.js","../../src/core/message.ts","../../src/core/message-parser.ts","../../src/core/serial.ts","../../src/core/messages-reactions.ts","../../src/core/rest-types.ts","../../src/core/messages.ts","../../src/core/chat-api.ts","../../src/core/errors.ts","../../src/core/id.ts","../../src/core/channel.ts","../../src/core/version.ts","../../src/core/channel-manager.ts","../../src/core/occupancy.ts","../../src/core/presence.ts","../../node_modules/async-mutex/index.mjs","../../src/core/room-status.ts","../../src/core/room-lifecycle-manager.ts","../../src/core/room-options.ts","../../src/core/realtime.ts","../../src/core/room-reaction.ts","../../src/core/room-reaction-parser.ts","../../src/core/room-reactions.ts","../../src/core/typing.ts","../../src/core/room.ts","../../src/core/rooms.ts","../../src/core/chat.ts"],"sourcesContent":["import * as Ably from 'ably';\n\nimport { NormalizedChatClientOptions } from './config.js';\n\n/**\n * Interface for loggers.\n */\nexport interface Logger {\n  /**\n   * Log a message at the trace level.\n   * @param message The message to log.\n   * @param context The context of the log message as key-value pairs.\n   */\n  trace(message: string, context?: LogContext): void;\n\n  /**\n   * Log a message at the debug level.\n   * @param message The message to log.\n   * @param context The context of the log message as key-value pairs.\n   */\n  debug(message: string, context?: LogContext): void;\n\n  /**\n   * Log a message at the info level.\n   * @param message The message to log.\n   * @param context The context of the log message as key-value pairs.\n   */\n  info(message: string, context?: LogContext): void;\n\n  /**\n   * Log a message at the warn level.\n   * @param message The message to log.\n   * @param context The context of the log message as key-value pairs.\n   */\n  warn(message: string, context?: LogContext): void;\n\n  /**\n   * Log a message at the error level.\n   * @param message The message to log.\n   * @param context The context of the log message as key-value pairs.\n   */\n  error(message: string, context?: LogContext): void;\n\n  /**\n   * Creates a new logger with a context that will be merged with any context provided to individual log calls.\n   * The context will be overridden by any matching keys in the individual log call's context.\n   * @param context The context to use for all log calls.\n   * @returns A new logger instance with the context.\n   */\n  withContext(context: LogContext): Logger;\n}\n\n/**\n * Represents the different levels of logging that can be used.\n */\nexport enum LogLevel {\n  /**\n   * Something routine and expected has occurred. This level will provide logs for the vast majority of operations\n   * and function calls.\n   */\n  Trace = 'trace',\n\n  /**\n   * Development information, messages that are useful when trying to debug library behavior,\n   * but superfluous to normal operation.\n   */\n  Debug = 'debug',\n\n  /**\n   * Informational messages. Operationally significant to the library but not out of the ordinary.\n   */\n  Info = 'info',\n\n  /**\n   * Anything that is not immediately an error, but could cause unexpected behavior in the future. For example,\n   * passing an invalid value to an option. Indicates that some action should be taken to prevent future errors.\n   */\n  Warn = 'warn',\n\n  /**\n   * A given operation has failed and cannot be automatically recovered. The error may threaten the continuity\n   * of operation.\n   */\n  Error = 'error',\n\n  /**\n   * No logging will be performed.\n   */\n  Silent = 'silent',\n}\n\n/**\n * Represents the context of a log message.\n * It is an object of key-value pairs that can be used to provide additional context to a log message.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type LogContext = Record<string, any>;\n\n/**\n * A function that can be used to handle log messages.\n * @param message The message to log.\n * @param level The log level of the message.\n * @param context The context of the log message as key-value pairs.\n */\nexport type LogHandler = (message: string, level: LogLevel, context?: LogContext) => void;\n\n/**\n * A simple console logger that logs messages to the console.\n *\n * @param message The message to log.\n * @param level The log level of the message.\n * @param context - The context of the log message as key-value pairs.\n */\nexport const consoleLogger = (message: string, level: LogLevel, context?: LogContext) => {\n  const contextString = context ? `, context: ${JSON.stringify(context)}` : '';\n  const formattedMessage = `[${new Date().toISOString()}] ${level.valueOf().toUpperCase()} ably-chat: ${message}${contextString}`;\n\n  switch (level) {\n    case LogLevel.Trace:\n    case LogLevel.Debug: {\n      console.log(formattedMessage);\n      break;\n    }\n    case LogLevel.Info: {\n      console.info(formattedMessage);\n      break;\n    }\n    case LogLevel.Warn: {\n      console.warn(formattedMessage);\n      break;\n    }\n    case LogLevel.Error: {\n      console.error(formattedMessage);\n      break;\n    }\n    case LogLevel.Silent: {\n      break;\n    }\n  }\n};\n\nexport const makeLogger = (options: NormalizedChatClientOptions): Logger => {\n  const logHandler = options.logHandler ?? consoleLogger;\n\n  return new DefaultLogger(logHandler, options.logLevel);\n};\n\n/**\n * A convenient list of log levels as numbers that can be used for easier comparison.\n */\nenum LogLevelNumber {\n  Trace = 0,\n  Debug = 1,\n  Info = 2,\n  Warn = 3,\n  Error = 4,\n  Silent = 5,\n}\n\n/**\n * A mapping of log levels to their numeric equivalents.\n */\nconst logLevelNumberMap = new Map<LogLevel, LogLevelNumber>([\n  [LogLevel.Trace, LogLevelNumber.Trace],\n  [LogLevel.Debug, LogLevelNumber.Debug],\n  [LogLevel.Info, LogLevelNumber.Info],\n  [LogLevel.Warn, LogLevelNumber.Warn],\n  [LogLevel.Error, LogLevelNumber.Error],\n  [LogLevel.Silent, LogLevelNumber.Silent],\n]);\n\n/**\n * A default logger implementation.\n */\nclass DefaultLogger implements Logger {\n  private readonly _handler: LogHandler;\n  private readonly _levelNumber: LogLevelNumber;\n  private readonly _context?: LogContext;\n\n  constructor(handler: LogHandler, level: LogLevel, context?: LogContext) {\n    this._handler = handler;\n    this._context = context;\n\n    const levelNumber = logLevelNumberMap.get(level);\n    if (levelNumber === undefined) {\n      throw new Ably.ErrorInfo(`Invalid log level: ${level}`, 50000, 500);\n    }\n\n    this._levelNumber = levelNumber;\n  }\n\n  trace(message: string, context?: LogContext): void {\n    this._write(message, LogLevel.Trace, LogLevelNumber.Trace, context);\n  }\n\n  debug(message: string, context?: LogContext): void {\n    this._write(message, LogLevel.Debug, LogLevelNumber.Debug, context);\n  }\n\n  info(message: string, context?: LogContext): void {\n    this._write(message, LogLevel.Info, LogLevelNumber.Info, context);\n  }\n\n  warn(message: string, context?: LogContext): void {\n    this._write(message, LogLevel.Warn, LogLevelNumber.Warn, context);\n  }\n\n  error(message: string, context?: LogContext): void {\n    this._write(message, LogLevel.Error, LogLevelNumber.Error, context);\n  }\n\n  withContext(context: LogContext): Logger {\n    // Get the original log level by finding the key in logLevelNumberMap that matches this._levelNumber\n    const originalLevel =\n      [...logLevelNumberMap.entries()].find(([, value]) => value === this._levelNumber)?.[0] ?? LogLevel.Error;\n\n    return new DefaultLogger(this._handler, originalLevel, this._mergeContext(context));\n  }\n\n  private _write(message: string, level: LogLevel, levelNumber: LogLevelNumber, context?: LogContext): void {\n    if (levelNumber >= this._levelNumber) {\n      this._handler(message, level, this._mergeContext(context));\n    }\n  }\n\n  private _mergeContext(context?: LogContext): LogContext | undefined {\n    if (!this._context) {\n      return context ?? undefined;\n    }\n\n    return context ? { ...this._context, ...context } : this._context;\n  }\n}\n","import { LogHandler, LogLevel } from './logger.js';\n\n/**\n * Configuration options for the chat client.\n */\nexport interface ChatClientOptions {\n  /**\n   * A custom log handler that will be used to log messages from the client.\n   * @defaultValue The client will log messages to the console.\n   */\n  logHandler?: LogHandler;\n\n  /**\n   * The minimum log level at which messages will be logged.\n   * @defaultValue LogLevel.error\n   */\n  logLevel?: LogLevel;\n}\n\n/**\n * Default configuration options for the chat client.\n */\nconst defaultClientOptions = {\n  logLevel: LogLevel.Error,\n};\n\n/**\n * This type is used to modify the properties of one type with the properties of another type and thus\n * can be used to turn client options into normalized client options.\n */\ntype Modify<T, R> = Omit<T, keyof R> & R;\n\n/**\n * These are the normalized client options, with default values filled in for any missing properties.\n */\nexport type NormalizedChatClientOptions = Modify<\n  ChatClientOptions,\n  {\n    logLevel: LogLevel;\n  }\n>;\n\nexport const normalizeClientOptions = (options?: ChatClientOptions): NormalizedChatClientOptions => {\n  options = options ?? {};\n\n  return {\n    ...options,\n    logLevel: options.logLevel ?? defaultClientOptions.logLevel,\n  };\n};\n","import * as Ably from 'ably';\n\n/**\n * This type represents a callback that can be registered with an EventEmitter.\n *\n * The EventsMap is an interface of event names to the types of the payloads of\n * those events. For example:\n *\n *     interface MyEvents {\n *         reaction: {emoji: string}\n *     }\n *\n * There is no need to use this type directly, it is used for defining the\n * InterfaceEventEmitter.\n */\ntype Callback<EventsMap> = (arg: EventsMap[keyof EventsMap]) => void;\ntype CallbackSingle<K> = (arg: K) => void;\n\n/**\n * This interface extends the Ably.EventEmitter interface to add a type-safe\n * emit method as well as convert an EventsMap into the type parameters used by\n * Ably.EventEmitter.\n */\ninterface InterfaceEventEmitter<EventsMap> extends Ably.EventEmitter<Callback<EventsMap>, void, keyof EventsMap> {\n  emit<K extends keyof EventsMap>(event: K, arg: EventsMap[K]): void;\n\n  on<K extends keyof EventsMap>(event: K, callback: CallbackSingle<EventsMap[K]>): void;\n  on<K1 extends keyof EventsMap, K2 extends keyof EventsMap>(\n    events: [K1, K2],\n    callback: CallbackSingle<EventsMap[K1] | EventsMap[K2]>,\n  ): void;\n  on<K1 extends keyof EventsMap, K2 extends keyof EventsMap, K3 extends keyof EventsMap>(\n    events: [K1, K2, K3],\n    callback: CallbackSingle<EventsMap[K1] | EventsMap[K2] | EventsMap[K3]>,\n  ): void;\n  on(events: (keyof EventsMap)[], callback: Callback<EventsMap>): void;\n  on(callback: Callback<EventsMap>): void;\n\n  off<K extends keyof EventsMap>(event: K, listener: CallbackSingle<EventsMap[K]>): void;\n  off(listener?: Callback<EventsMap>): void;\n  off<K extends EventsMap[keyof EventsMap]>(listener: CallbackSingle<K>): void;\n}\n\n/**\n * This is a workaround for the fact that the EventEmitter constructor is only\n * exported from the ably-js package for internal use by other Ably SDKs (like\n * this one).\n *\n * It is a correctly-typed constructor for the ably-js EventEmitter.\n *\n * We do not export this directly because we prefer to export a class, which is\n * what we normally expect EventEmitter to be.\n */\nconst InternalEventEmitter: new <EventsMap>() => InterfaceEventEmitter<EventsMap> = (\n  Ably.Realtime as unknown as { EventEmitter: new <EventsMap>() => InterfaceEventEmitter<EventsMap> }\n).EventEmitter;\n\n/**\n * EventEmitter class based on the internal ably-js EventEmitter. It is\n * different from the ably-js EventEmitter because it takes an EventsMap type\n * parameter as opposed to the three type parameters required by\n * {@link Ably.EventEmitter}.\n *\n * We find the EventsMap type parameter to be more convenient to use in this\n * Chat SDK.\n *\n * The EventsMap is an interface of event names to the types of the payloads of\n * those events. For example:\n *\n *     interface MyEvents {\n *         reaction: {emoji: string}\n *     }\n *\n * There is no need to use this type directly, it is used for defining the\n * InterfaceEventEmitter.\n */\nclass EventEmitter<EventsMap> extends InternalEventEmitter<EventsMap> {}\n\nexport default EventEmitter;\n\n/**\n * Creates a wrapper function that forwards all arguments to the provided function.\n * @param fn The function to wrap\n * @returns A new function with the same signature as the input function\n */\nexport const wrap = <Args extends unknown[], Return>(fn: (...args: Args) => Return): ((...args: Args) => Return) => {\n  return (...args: Args) => fn(...args);\n};\n","import * as Ably from 'ably';\n\nimport { Logger } from './logger.js';\nimport { StatusSubscription } from './subscription.js';\nimport EventEmitter, { wrap } from './utils/event-emitter.js';\n\n/**\n * The different states that the connection can be in through its lifecycle.\n */\nexport enum ConnectionStatus {\n  /**\n   * A temporary state for when the library is first initialized.\n   */\n  Initialized = 'initialized',\n\n  /**\n   * The library is currently connecting to Ably.\n   */\n  Connecting = 'connecting',\n\n  /**\n   * The library is currently connected to Ably.\n   */\n  Connected = 'connected',\n\n  /**\n   * The library is currently disconnected from Ably, but will attempt to reconnect.\n   */\n  Disconnected = 'disconnected',\n\n  /**\n   * The library is in an extended state of disconnection, but will attempt to reconnect.\n   */\n  Suspended = 'suspended',\n\n  /**\n   * The library is currently disconnected from Ably and will not attempt to reconnect.\n   */\n  Failed = 'failed',\n}\n\n/**\n * Represents a change in the status of the connection.\n */\nexport interface ConnectionStatusChange {\n  /**\n   * The new status of the connection.\n   */\n  current: ConnectionStatus;\n\n  /**\n   * The previous status of the connection.\n   */\n  previous: ConnectionStatus;\n\n  /**\n   * An error that provides a reason why the connection has\n   * entered the new status, if applicable.\n   */\n  error?: Ably.ErrorInfo;\n\n  /**\n   * The time in milliseconds that the client will wait before attempting to reconnect.\n   */\n  retryIn?: number;\n}\n\n/**\n * A function that can be called when the connection status changes.\n * @param change The change in status.\n */\nexport type ConnectionStatusListener = (change: ConnectionStatusChange) => void;\n\n/**\n * Represents a connection to Ably.\n */\nexport interface Connection {\n  /**\n   * The current status of the connection.\n   */\n  get status(): ConnectionStatus;\n\n  /**\n   * The current error, if any, that caused the connection to enter the current status.\n   */\n  get error(): Ably.ErrorInfo | undefined;\n\n  /**\n   * Registers a listener that will be called whenever the connection status changes.\n   * @param listener The function to call when the status changes.\n   * @returns An object that can be used to unregister the listener.\n   */\n  onStatusChange(listener: ConnectionStatusListener): StatusSubscription;\n}\n\ntype ConnectionEventsMap = Record<ConnectionStatus, ConnectionStatusChange>;\n\n/**\n * An implementation of the `Connection` interface.\n * @internal\n */\nexport class DefaultConnection implements Connection {\n  private _status: ConnectionStatus = ConnectionStatus.Initialized;\n  private _error?: Ably.ErrorInfo;\n  private readonly _connection: Ably.Connection;\n  private readonly _logger: Logger;\n  private _emitter = new EventEmitter<ConnectionEventsMap>();\n\n  /**\n   * Constructs a new `DefaultConnection` instance.\n   * @param ably The Ably Realtime client.\n   * @param logger The logger to use.\n   */\n  constructor(ably: Ably.Realtime, logger: Logger) {\n    this._logger = logger;\n\n    // Set our initial status and error\n    // CHA-RS5\n    this._status = this._mapAblyStatusToChat(ably.connection.state);\n    this._error = ably.connection.errorReason;\n\n    // Listen for changes to the connection status\n    this._connection = ably.connection;\n    this._connection.on((change: Ably.ConnectionStateChange) => {\n      const chatState = this._mapAblyStatusToChat(change.current);\n      if (chatState === this._status) {\n        return;\n      }\n\n      const stateChange: ConnectionStatusChange = {\n        current: chatState,\n        previous: this._status,\n        error: change.reason,\n        retryIn: change.retryIn,\n      };\n\n      this._applyStatusChange(stateChange);\n    });\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get status(): ConnectionStatus {\n    return this._status;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get error(): Ably.ErrorInfo | undefined {\n    return this._error;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  onStatusChange(listener: ConnectionStatusListener): StatusSubscription {\n    const wrapped = wrap(listener);\n    this._emitter.on(wrapped);\n\n    return {\n      off: () => {\n        this._emitter.off(wrapped);\n      },\n    };\n  }\n\n  private _applyStatusChange(change: ConnectionStatusChange): void {\n    this._status = change.current;\n    this._error = change.error;\n    this._logger.info(`Connection state changed`, change);\n    this._emitter.emit(change.current, change);\n  }\n\n  private _mapAblyStatusToChat(status: Ably.ConnectionState): ConnectionStatus {\n    switch (status) {\n      case 'closing':\n      case 'closed': {\n        return ConnectionStatus.Failed;\n      }\n      default: {\n        return status as ConnectionStatus;\n      }\n    }\n  }\n}\n","var has = Object.prototype.hasOwnProperty;\n\nfunction find(iter, tar, key) {\n\tfor (key of iter.keys()) {\n\t\tif (dequal(key, tar)) return key;\n\t}\n}\n\nexport function dequal(foo, bar) {\n\tvar ctor, len, tmp;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ctor === Set) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len;\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!bar.has(tmp)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === Map) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len[0];\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!dequal(len[1], bar.get(tmp))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === ArrayBuffer) {\n\t\t\tfoo = new Uint8Array(foo);\n\t\t\tbar = new Uint8Array(bar);\n\t\t} else if (ctor === DataView) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo.getInt8(len) === bar.getInt8(len));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ArrayBuffer.isView(foo)) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo[len] === bar[len]);\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n","import * as Ably from 'ably';\n\nimport { Message } from './message.js';\nimport { RoomReaction } from './room-reaction.js';\n\n/**\n * All chat message events.\n */\nexport enum ChatMessageEventType {\n  /** Fires when a new chat message is received. */\n  Created = 'message.created',\n\n  /** Fires when a chat message is updated. */\n  Updated = 'message.updated',\n\n  /** Fires when a chat message is deleted. */\n  Deleted = 'message.deleted',\n}\n\n/**\n * Realtime chat message names.\n */\nexport enum RealtimeMessageName {\n  /** Represents a regular chat message. */\n  ChatMessage = 'chat.message',\n}\n\n/**\n * Realtime meta event types.\n */\nexport enum RealtimeMetaEventType {\n  /** Represents a meta occupancy event. */\n  Occupancy = '[meta]occupancy',\n}\n\n/**\n * Chat Message Actions.\n */\nexport enum ChatMessageAction {\n  /** Action applied to a new message. */\n  MessageCreate = 'message.create',\n\n  /** Action applied to an updated message. */\n  MessageUpdate = 'message.update',\n\n  /** Action applied to a deleted message. */\n  MessageDelete = 'message.delete',\n\n  /** Action applied to an annotation summary message. */\n  MessageAnnotationSummary = 'message.summary',\n\n  /** Action applied to a meta occupancy message. */\n  MessageMetaOccupancy = 'meta.occupancy',\n}\n\n/**\n * Enum representing presence events.\n */\nexport enum PresenceEventType {\n  /**\n   * Event triggered when a user enters.\n   */\n  Enter = 'enter',\n\n  /**\n   * Event triggered when a user leaves.\n   */\n  Leave = 'leave',\n\n  /**\n   * Event triggered when a user updates their presence data.\n   */\n  Update = 'update',\n  /**\n   * Event triggered when a user initially subscribes to presence.\n   */\n  Present = 'present',\n}\n\n/**\n * Enum representing the typing event types.\n */\nexport enum TypingEventType {\n  /**\n   * Event triggered when a user is typing.\n   */\n  Start = 'typing.started',\n\n  /**\n   * Event triggered when a user stops typing.\n   */\n  Stop = 'typing.stopped',\n}\n\n/**\n * Enum representing the typing set event types.\n */\nexport enum TypingSetEventType {\n  /**\n   * Event triggered when a change occurs in the set of typers.\n   */\n  SetChanged = 'typing.set.changed',\n}\n\n/**\n * Represents a change in the state of current typers.\n */\nexport interface TypingSetEvent {\n  /**\n   * The type of the event.\n   */\n  type: TypingSetEventType;\n\n  /**\n   * The set of clientIds that are currently typing.\n   */\n  currentlyTyping: Set<string>;\n\n  /**\n   * Represents the change that resulted in the new set of typers.\n   */\n  change: {\n    /**\n     * The client ID of the user who stopped/started typing.\n     */\n    clientId: string;\n\n    /**\n     * Type of the change.\n     */\n    type: TypingEventType;\n  };\n}\n\n/**\n * Room reaction events. This is used for the realtime system since room reactions\n * have only one event: \"roomReaction\".\n */\nexport enum RoomReactionRealtimeEventType {\n  /**\n   * Event triggered when a room reaction was received.\n   */\n  Reaction = 'roomReaction',\n}\n\n/**\n * The type of room reaction events.\n */\nexport enum RoomReactionEventType {\n  /**\n   * Event triggered when a room reaction was received.\n   */\n  Reaction = 'reaction',\n}\n\n/**\n * Event that is emitted when a room reaction is received.\n */\nexport interface RoomReactionEvent {\n  /**\n   * The type of the event.\n   */\n  readonly type: RoomReactionEventType;\n\n  /**\n   * The reaction that was received.\n   */\n  readonly reaction: RoomReaction;\n}\n\n/**\n * Payload for a message event.\n */\nexport interface ChatMessageEvent {\n  /**\n   * The type of the message event.\n   */\n  type: ChatMessageEventType;\n\n  /**\n   * The message that was received.\n   */\n  message: Message;\n}\n\n/**\n * All annotation types supported by Chat Message Reactions.\n */\nexport enum MessageReactionType {\n  /**\n   * Allows for at most one reaction per client per message. If a client reacts\n   * to a message a second time, only the second reaction is counted in the\n   * summary.\n   *\n   * This is similar to reactions on iMessage, Facebook Messenger or WhatsApp.\n   */\n  Unique = 'unique',\n\n  /**\n   * Allows for at most one reaction of each type per client per message. It is\n   * possible for a client to add multiple reactions to the same message as\n   * long as they are different (eg different emojis). Duplicates are not\n   * counted in the summary.\n   *\n   * This is similar to reactions on Slack.\n   */\n  Distinct = 'distinct',\n\n  /**\n   * Allows any number of reactions, including repeats, and they are counted in\n   * the summary. The reaction payload also includes a count of how many times\n   * each reaction should be counted (defaults to 1 if not set).\n   *\n   * This is similar to the clap feature on Medium or how room reactions work.\n   */\n  Multiple = 'multiple',\n}\n\n/**\n * Enum representing the different annotation types used for message reactions.\n */\nexport enum ReactionAnnotationType {\n  Unique = 'reaction:unique.v1',\n  Distinct = 'reaction:distinct.v1',\n  Multiple = 'reaction:multiple.v1',\n}\n\n/**\n * Maps Ably PubSub annotation types to Ably Chat message reaction types.\n *\n * The key type is string because we use it to lookup by PubSub event.type, which is a string.\n */\nexport const AnnotationTypeToReactionType: Record<string, MessageReactionType> = {\n  [ReactionAnnotationType.Unique]: MessageReactionType.Unique,\n  [ReactionAnnotationType.Distinct]: MessageReactionType.Distinct,\n  [ReactionAnnotationType.Multiple]: MessageReactionType.Multiple,\n} as const;\n\n/**\n * Enum representing different message reaction events in the chat system.\n * @enum {string}\n */\nexport enum MessageReactionEventType {\n  /**\n   * A reaction was added to a message.\n   */\n  Create = 'reaction.create',\n  /**\n   * A reaction was removed from a message.\n   */\n  Delete = 'reaction.delete',\n  /**\n   * A reactions summary was updated for a message.\n   */\n  Summary = 'reaction.summary',\n}\n\n/**\n * Represents an individual message reaction event.\n */\nexport interface MessageReactionRawEvent {\n  /** Whether reaction was added or removed */\n  type: MessageReactionEventType.Create | MessageReactionEventType.Delete;\n\n  /** The timestamp of this event */\n  timestamp: Date;\n\n  /** The message reaction that was received. */\n  reaction: {\n    /** Serial of the message this reaction is for */\n    messageSerial: string;\n\n    /** Type of reaction */\n    type: MessageReactionType;\n\n    /** The reaction name (typically an emoji) */\n    name: string;\n\n    /** Count of the reaction (only for type Multiple, if set) */\n    count?: number;\n\n    /** The client ID of the user who added/removed the reaction */\n    clientId: string;\n  };\n}\n\n/**\n * Event interface representing a summary of message reactions.\n * This event aggregates different types of reactions (single, distinct, counter) for a specific message.\n */\nexport interface MessageReactionSummaryEvent {\n  /** The type of the event */\n  type: MessageReactionEventType.Summary;\n\n  /** The message reactions summary. */\n  summary: {\n    /** Reference to the original message's serial number */\n    messageSerial: string;\n\n    /** Map of unique-type reactions summaries */\n    unique: Ably.SummaryUniqueValues;\n\n    /** Map of distinct-type reactions summaries */\n    distinct: Ably.SummaryDistinctValues;\n\n    /** Map of multiple-type reactions summaries */\n    multiple: Ably.SummaryMultipleValues;\n  };\n}\n\n/**\n * Enum representing occupancy events.\n */\nexport enum OccupancyEventType {\n  /**\n   * Event triggered when occupancy is updated.\n   */\n  Updated = 'occupancy.updated',\n}\n\n/**\n * Represents an occupancy event.\n */\nexport interface OccupancyEvent {\n  /**\n   * The type of the occupancy event.\n   */\n  type: OccupancyEventType;\n\n  /**\n   * The occupancy data.\n   */\n  occupancy: {\n    /**\n     * The number of connections to the chat room.\n     */\n    connections: number;\n\n    /**\n     * The number of presence members in the chat room - members who have entered presence.\n     */\n    presenceMembers: number;\n  };\n}\n\n/**\n * Room events.\n */\nexport enum RoomEventType {\n  /**\n   * Event triggered when a discontinuity is detected in the room's channel connection.\n   * A discontinuity occurs when an attached or update event comes from the channel with resume=false,\n   * except for the first attach or attaches after explicit detach calls.\n   */\n  Discontinuity = 'room.discontinuity',\n}\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/**\n * Adds the key-value `pair` to `map`.\n *\n * @private\n * @param {Object} map The map to modify.\n * @param {Array} pair The key-value pair to add.\n * @returns {Object} Returns `map`.\n */\nfunction addMapEntry(map, pair) {\n  // Don't return `map.set` because it's not chainable in IE 11.\n  map.set(pair[0], pair[1]);\n  return map;\n}\n\n/**\n * Adds `value` to `set`.\n *\n * @private\n * @param {Object} set The set to modify.\n * @param {*} value The value to add.\n * @returns {Object} Returns `set`.\n */\nfunction addSetEntry(set, value) {\n  // Don't return `set.add` because it's not chainable in IE 11.\n  set.add(value);\n  return set;\n}\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    getPrototype = overArg(Object.getPrototypeOf, Object),\n    objectCreate = Object.create,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  this.__data__ = new ListCache(entries);\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  return this.__data__['delete'](key);\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var cache = this.__data__;\n  if (cache instanceof ListCache) {\n    var pairs = cache.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      return this;\n    }\n    cache = this.__data__ = new MapCache(pairs);\n  }\n  cache.set(key, value);\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = (isArray(value) || isArguments(value))\n    ? baseTimes(value.length, String)\n    : [];\n\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    object[key] = value;\n  }\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @param {boolean} [isFull] Specify a clone including symbols.\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, isDeep, isFull, customizer, key, object, stack) {\n  var result;\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      if (isHostObject(value)) {\n        return object ? value : {};\n      }\n      result = initCloneObject(isFunc ? {} : value);\n      if (!isDeep) {\n        return copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, baseClone, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (!isArr) {\n    var props = isFull ? getAllKeys(value) : keys(value);\n  }\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));\n  });\n  return result;\n}\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} prototype The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nfunction baseCreate(proto) {\n  return isObject(proto) ? objectCreate(proto) : {};\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  return objectToString.call(value);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var result = new buffer.constructor(buffer.length);\n  buffer.copy(result);\n  return result;\n}\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\n/**\n * Creates a clone of `map`.\n *\n * @private\n * @param {Object} map The map to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned map.\n */\nfunction cloneMap(map, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);\n  return arrayReduce(array, addMapEntry, new map.constructor);\n}\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\n/**\n * Creates a clone of `set`.\n *\n * @private\n * @param {Object} set The set to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned set.\n */\nfunction cloneSet(set, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);\n  return arrayReduce(array, addSetEntry, new set.constructor);\n}\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    assignValue(object, key, newValue === undefined ? source[key] : newValue);\n  }\n  return object;\n}\n\n/**\n * Copies own symbol properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Creates an array of the own enumerable symbol properties of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11,\n// for data views in Edge < 14, and promises in Node.js.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = objectToString.call(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : undefined;\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, cloneFunc, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return cloneMap(object, isDeep, cloneFunc);\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return cloneSet(object, isDeep, cloneFunc);\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, true, true);\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = cloneDeep;\n","import * as Ably from 'ably';\nimport cloneDeep from 'lodash.clonedeep';\n\nimport {\n  ChatMessageAction,\n  ChatMessageEvent,\n  ChatMessageEventType,\n  MessageReactionEventType,\n  MessageReactionSummaryEvent,\n} from './events.js';\nimport { Headers } from './headers.js';\nimport { Metadata } from './metadata.js';\nimport { OperationMetadata } from './operation-metadata.js';\n\n/**\n * {@link Headers} type for chat messages.\n */\nexport type MessageHeaders = Headers;\n\n/**\n * {@link Metadata} type for chat messages.\n */\nexport type MessageMetadata = Metadata;\n\n/**\n * {@link OperationMetadata} type for a chat messages {@link Operation}.\n */\nexport type MessageOperationMetadata = OperationMetadata;\n\n/**\n * Represents the detail of a message deletion or update.\n */\nexport interface Operation {\n  /**\n   * The optional clientId of the user who performed the update or deletion.\n   */\n  clientId?: string;\n  /**\n   * The optional description for the update or deletion.\n   */\n  description?: string;\n  /**\n   * The optional metadata associated with the update or deletion.\n   */\n  metadata?: MessageOperationMetadata;\n}\n\n/**\n * Represents a single message in a chat room.\n */\nexport interface Message {\n  /**\n   * The unique identifier of the message.\n   */\n  readonly serial: string;\n\n  /**\n   * The clientId of the user who created the message.\n   */\n  readonly clientId: string;\n\n  /**\n   * The text of the message.\n   */\n  readonly text: string;\n\n  /**\n   * The timestamp at which the message was created.\n   */\n  readonly createdAt: Date;\n\n  /**\n   * The metadata of a chat message. Allows for attaching extra info to a message,\n   * which can be used for various features such as animations, effects, or simply\n   * to link it to other resources such as images, relative points in time, etc.\n   *\n   * Metadata is part of the Ably Pub/sub message content and is not read by Ably.\n   *\n   * This value is always set. If there is no metadata, this is an empty object.\n   *\n   * Do not use metadata for authoritative information. There is no server-side\n   * validation. When reading the metadata treat it like user input.\n   */\n  readonly metadata: MessageMetadata;\n\n  /**\n   * The headers of a chat message. Headers enable attaching extra info to a message,\n   * which can be used for various features such as linking to a relative point in\n   * time of a livestream video or flagging this message as important or pinned.\n   *\n   * Headers are part of the Ably realtime message extras.headers and they can be used\n   * for Filtered Subscriptions and similar.\n   *\n   * This value is always set. If there are no headers, this is an empty object.\n   *\n   * Do not use the headers for authoritative information. There is no server-side\n   * validation. When reading the headers, treat them like user input.\n   */\n  readonly headers: MessageHeaders;\n\n  /**\n   * The action type of the message. This can be used to determine if the message was created, updated, or deleted.\n   */\n  readonly action: ChatMessageAction;\n\n  /**\n   * A unique identifier for the latest version of this message.\n   */\n  readonly version: string;\n\n  /**\n   * The timestamp at which this version was updated, deleted, or created.\n   */\n  readonly timestamp: Date;\n\n  /**\n   * The details of the operation that modified the message. This is only set for update and delete actions. It contains\n   * information about the operation: the clientId of the user who performed the operation, a description, and metadata.\n   */\n  readonly operation?: Operation;\n\n  /**\n   * The reactions summary for this message.\n   */\n  readonly reactions: MessageReactions;\n\n  /**\n   * Indicates if the message has been updated.\n   */\n  get isUpdated(): boolean;\n\n  /**\n   * Indicates if the message has been deleted.\n   */\n  get isDeleted(): boolean;\n\n  /**\n   * The clientId of the user who deleted the message.\n   */\n  get deletedBy(): string | undefined;\n\n  /**\n   * The clientId of the user who updated the message.\n   */\n  get updatedBy(): string | undefined;\n\n  /**\n   * The timestamp at which the message was deleted.\n   */\n  get deletedAt(): Date | undefined;\n\n  /**\n   * The timestamp at which the message was updated.\n   */\n  get updatedAt(): Date | undefined;\n\n  /**\n   * Determines if this message is an older version of the given message.\n   *\n   * **Note** that negating this function does not mean that the message is a newer\n   * version of the same message, as the two may be different messages entirely.\n   *\n   * ```ts\n   *  !message.isOlderVersionOf(other) !== message.isNewerVersionOf(other)\n   * ```\n   * @param message The message to compare against.\n   * @returns true if the two messages are the same message (isSameAs returns true) and this message is an older version.\n   */\n  isOlderVersionOf(message: Message): boolean;\n\n  /**\n   * Determines if this message is a newer version of the given message.\n   *\n   * **Note** that negating this function does not mean that the message is an older\n   * version of the same message, as the two may be different messages entirely.\n   *\n   * ```ts\n   *  !message.isNewerVersionOf(other) !== message.isOlderVersionOf(other)\n   * ```\n   *\n   * @param message The message to compare against.\n   * @returns true if the two messages are the same message (isSameAs returns true) and this message is a newer version.\n   */\n  isNewerVersionOf(message: Message): boolean;\n\n  /**\n   * Determines if this message is the same version as the given message.\n   * @param message The message to compare against.\n   * @returns true if the two messages are the same message and have the same version.\n   */\n  isSameVersionAs(message: Message): boolean;\n\n  /**\n   * Determines if this message was created before the given message. This comparison is based on\n   * global order, so does not necessarily represent the order that messages are received in realtime\n   * from the backend.\n   * @param message The message to compare against.\n   * @returns true if this message was created before the given message, in global order.\n   * @throws {@link ErrorInfo} if serials of either message is invalid.\n   */\n  before(message: Message): boolean;\n\n  /**\n   * Determines if this message was created after the given message. This comparison is based on\n   * global order, so does not necessarily represent the order that messages are received in realtime\n   * from the backend.\n   * @param message The message to compare against.\n   * @returns true if this message was created after the given message, in global order.\n   * @throws {@link ErrorInfo} if serials of either message is invalid.\n   */\n  after(message: Message): boolean;\n\n  /**\n   * Determines if this message is equal to the given message.\n   *\n   * Note that this method compares messages based on {@link Message.serial} alone. It returns true if the\n   * two messages represent different versions of the same message.\n   * @param message The message to compare against.\n   * @returns true if the two messages are the same message.\n   */\n  equal(message: Message): boolean;\n\n  /**\n   * Alias for {@link equal}.\n   * @param message The message to compare against.\n   * @returns true if the two messages are the same message.\n   */\n  isSameAs(message: Message): boolean;\n\n  /**\n   * Creates a new message instance with the event applied.\n   *\n   * NOTE: This method will not replace the message reactions if the event is of type `Message`.\n   *\n   * @param event The event to be applied to the returned message.\n   * @throws {@link ErrorInfo} if the event is for a different message.\n   * @throws {@link ErrorInfo} if the event is a {@link ChatMessageEventType.Created}.\n   * @returns A new message instance with the event applied. If the event is a no-op, such\n   *    as an event for an old version, the same message is returned (not a copy).\n   */\n  with(event: Message | ChatMessageEvent | MessageReactionSummaryEvent): Message;\n\n  /**\n   * Creates a copy of the message with fields replaced per the parameters.\n   *\n   * @param params The parameters to replace in the message.\n   * @return The message copy.\n   */\n  copy(params?: MessageCopyParams): Message;\n}\n\n/**\n * Parameters for copying a message.\n */\nexport interface MessageCopyParams {\n  /**\n   * The text of the copied message.\n   */\n  text?: string;\n\n  /**\n   * The metadata of the copied message.\n   */\n  metadata?: MessageMetadata;\n\n  /**\n   * The headers of the copied message.\n   */\n  headers?: MessageHeaders;\n}\n\n/**\n * Represents a summary of all reactions on a message.\n */\nexport interface MessageReactions {\n  /**\n   * Map of reaction to the summary (total and clients) for reactions of type {@link MessageReactionType.Unique}.\n   */\n  unique: Ably.SummaryUniqueValues;\n\n  /**\n   * Map of reaction to the summary (total and clients) for reactions of type {@link MessageReactionType.Distinct}.\n   */\n  distinct: Ably.SummaryDistinctValues;\n\n  /**\n   * Map of reaction to the summary (total and clients) for reactions of type {@link MessageReactionType.Multiple}.\n   */\n  multiple: Ably.SummaryMultipleValues;\n}\n\n/**\n * Parameters for creating a new DefaultMessage instance.\n */\nexport interface DefaultMessageParams {\n  serial: string;\n  clientId: string;\n  text: string;\n  metadata: MessageMetadata;\n  headers: MessageHeaders;\n  action: ChatMessageAction;\n  version: string;\n  createdAt: Date;\n  timestamp: Date;\n  reactions: MessageReactions;\n  operation?: Operation;\n}\n\n/**\n * An implementation of the Message interface for chat messages.\n *\n * Allows for comparison of messages based on their serials.\n */\nexport class DefaultMessage implements Message {\n  public readonly serial: string;\n  public readonly clientId: string;\n  public readonly text: string;\n  public readonly metadata: MessageMetadata;\n  public readonly headers: MessageHeaders;\n  public readonly action: ChatMessageAction;\n  public readonly version: string;\n  public readonly createdAt: Date;\n  public readonly timestamp: Date;\n  public readonly reactions: MessageReactions;\n  public readonly operation?: Operation;\n\n  constructor({\n    serial,\n    clientId,\n    text,\n    metadata,\n    headers,\n    action,\n    version,\n    createdAt,\n    timestamp,\n    reactions,\n    operation,\n  }: DefaultMessageParams) {\n    this.serial = serial;\n    this.clientId = clientId;\n    this.text = text;\n    this.metadata = metadata;\n    this.headers = headers;\n    this.action = action;\n    this.version = version;\n    this.createdAt = createdAt;\n    this.timestamp = timestamp;\n    this.reactions = reactions;\n    this.operation = operation;\n    // The object is frozen after constructing to enforce readonly at runtime too\n    Object.freeze(this.reactions);\n    Object.freeze(this.reactions.multiple);\n    Object.freeze(this.reactions.distinct);\n    Object.freeze(this.reactions.unique);\n    Object.freeze(this);\n  }\n\n  get isUpdated(): boolean {\n    return this.action === ChatMessageAction.MessageUpdate;\n  }\n\n  get isDeleted(): boolean {\n    return this.action === ChatMessageAction.MessageDelete;\n  }\n\n  get updatedBy(): string | undefined {\n    return this.isUpdated ? this.operation?.clientId : undefined;\n  }\n\n  get deletedBy(): string | undefined {\n    return this.isDeleted ? this.operation?.clientId : undefined;\n  }\n\n  get updatedAt(): Date | undefined {\n    return this.isUpdated ? this.timestamp : undefined;\n  }\n\n  get deletedAt(): Date | undefined {\n    return this.isDeleted ? this.timestamp : undefined;\n  }\n\n  isOlderVersionOf(message: Message): boolean {\n    if (!this.equal(message)) {\n      return false;\n    }\n\n    return this.version < message.version;\n  }\n\n  isNewerVersionOf(message: Message): boolean {\n    if (!this.equal(message)) {\n      return false;\n    }\n\n    return this.version > message.version;\n  }\n\n  isSameVersionAs(message: Message): boolean {\n    if (!this.equal(message)) {\n      return false;\n    }\n\n    return this.version === message.version;\n  }\n\n  before(message: Message): boolean {\n    return this.serial < message.serial;\n  }\n\n  after(message: Message): boolean {\n    return this.serial > message.serial;\n  }\n\n  equal(message: Message): boolean {\n    return this.serial === message.serial;\n  }\n\n  isSameAs(message: Message): boolean {\n    return this.equal(message);\n  }\n\n  with(event: Message | ChatMessageEvent | MessageReactionSummaryEvent): Message {\n    // If event has the property \"serial\", then it's a message\n    if ('serial' in event) {\n      return this._getLatestMessageVersion(event);\n    }\n\n    // If the event is a created event, throw an error\n    if (event.type === ChatMessageEventType.Created) {\n      throw new Ably.ErrorInfo('cannot apply a created event to a message', 40000, 400);\n    }\n\n    // reaction summary\n    if (event.type === MessageReactionEventType.Summary) {\n      if (event.summary.messageSerial !== this.serial) {\n        throw new Ably.ErrorInfo('cannot apply event for a different message', 40000, 400);\n      }\n\n      const newReactions: MessageReactions = {\n        unique: cloneDeep(event.summary.unique),\n        distinct: cloneDeep(event.summary.distinct),\n        multiple: cloneDeep(event.summary.multiple),\n      };\n\n      return DefaultMessage._clone(this, { reactions: newReactions });\n    }\n\n    // Message event (update or delete)\n    return this._getLatestMessageVersion(event.message);\n  }\n\n  /**\n   * Get the latest message version, based on the event.\n   * If \"this\" is the latest version, return \"this\", otherwise clone the message and apply the reactions.\n   *\n   * @param message The message to get the latest version of\n   * @returns The latest message version\n   */\n  private _getLatestMessageVersion(message: Message): Message {\n    // message event (update or delete)\n    if (message.serial !== this.serial) {\n      throw new Ably.ErrorInfo('cannot apply event for a different message', 40000, 400);\n    }\n\n    // event is older, keep this instead\n    if (this.version >= message.version) {\n      return this;\n    }\n\n    // event is newer, copy reactions from this and make new message from event\n    // TODO: This ignores summaries being newer on the message passed in, and is something we need to address\n    return DefaultMessage._clone(message, { reactions: this.reactions });\n  }\n\n  // Clone a message, optionally replace the given fields\n  private static _clone(source: Message, replace?: Partial<Message>): DefaultMessage {\n    return new DefaultMessage({\n      serial: replace?.serial ?? source.serial,\n      clientId: replace?.clientId ?? source.clientId,\n      text: replace?.text ?? source.text,\n      metadata: replace?.metadata ?? cloneDeep(source.metadata),\n      headers: replace?.headers ?? cloneDeep(source.headers),\n      action: replace?.action ?? source.action,\n      version: replace?.version ?? source.version,\n      createdAt: replace?.createdAt ?? source.createdAt,\n      timestamp: replace?.timestamp ?? source.timestamp,\n      reactions: replace?.reactions ?? cloneDeep(source.reactions),\n      operation: replace?.operation ?? cloneDeep(source.operation),\n    });\n  }\n\n  copy(params: MessageCopyParams = {}): Message {\n    return DefaultMessage._clone(this, params);\n  }\n}\n\nexport function emptyMessageReactions(): MessageReactions {\n  return {\n    unique: {},\n    distinct: {},\n    multiple: {},\n  };\n}\n","import * as Ably from 'ably';\n\nimport { ChatMessageAction } from './events.js';\nimport {\n  DefaultMessage,\n  emptyMessageReactions,\n  Message,\n  MessageHeaders,\n  MessageMetadata,\n  Operation,\n} from './message.js';\n\ninterface MessagePayload {\n  data?: {\n    text?: string;\n    metadata?: MessageMetadata;\n  };\n  clientId?: string;\n  timestamp: number;\n  extras?: {\n    headers?: MessageHeaders;\n  };\n\n  serial: string;\n  createdAt: number;\n  version: string;\n  action: Ably.MessageAction;\n  operation?: Ably.Operation;\n}\n\n// Parse a realtime message to a chat message\nexport const parseMessage = (inboundMessage: Ably.InboundMessage): Message => {\n  const message = inboundMessage as MessagePayload;\n\n  if (!message.data) {\n    throw new Ably.ErrorInfo(`received incoming message without data`, 50000, 500);\n  }\n\n  if (!message.clientId) {\n    throw new Ably.ErrorInfo(`received incoming message without clientId`, 50000, 500);\n  }\n\n  if (!message.extras) {\n    throw new Ably.ErrorInfo(`received incoming message without extras`, 50000, 500);\n  }\n\n  // For non-delete messages, text is required\n  if (message.action !== ChatMessageAction.MessageDelete && message.data.text === undefined) {\n    throw new Ably.ErrorInfo(`received incoming message without text`, 50000, 500);\n  }\n\n  // For non-delete messages, extras.headers is required\n  if (message.action !== ChatMessageAction.MessageDelete && !message.extras.headers) {\n    throw new Ably.ErrorInfo(`received incoming message without headers`, 50000, 500);\n  }\n\n  // For non-delete messages, metadata is required\n  if (message.action !== ChatMessageAction.MessageDelete && !message.data.metadata) {\n    throw new Ably.ErrorInfo(`received incoming message without metadata`, 50000, 500);\n  }\n\n  if (!message.serial) {\n    throw new Ably.ErrorInfo(`received incoming message without serial`, 50000, 500);\n  }\n\n  if (!message.version) {\n    throw new Ably.ErrorInfo(`received incoming message without version`, 50000, 500);\n  }\n\n  if (!message.createdAt) {\n    throw new Ably.ErrorInfo(`received incoming message without createdAt`, 50000, 500);\n  }\n\n  if (!message.timestamp) {\n    throw new Ably.ErrorInfo(`received incoming message without timestamp`, 50000, 500);\n  }\n\n  switch (message.action) {\n    case ChatMessageAction.MessageCreate:\n    case ChatMessageAction.MessageUpdate:\n    case ChatMessageAction.MessageDelete: {\n      break;\n    }\n    default: {\n      throw new Ably.ErrorInfo(`received incoming message with unhandled action; ${message.action}`, 50000, 500);\n    }\n  }\n\n  // If it's a deleted message, we'll set message.data to an empty object and message.extras to an empty object\n  const data = message.action === ChatMessageAction.MessageDelete ? {} : message.data;\n  const extras = message.action === ChatMessageAction.MessageDelete ? {} : message.extras;\n\n  return new DefaultMessage({\n    serial: message.serial,\n    clientId: message.clientId,\n    text: data.text ?? '',\n    metadata: data.metadata ?? {},\n    headers: extras.headers ?? {},\n    action: message.action as ChatMessageAction,\n    version: message.version,\n    createdAt: new Date(message.createdAt),\n    timestamp: new Date(message.timestamp),\n    reactions: emptyMessageReactions(),\n    operation: message.operation as Operation,\n  });\n};\n","import * as Ably from 'ably';\n\nimport { Message } from './message.js';\n\n/**\n * A serial is used to identify a particular message, reaction or other chat event. It is the identifier\n * for that event in the chat history.\n *\n * Serials can be conveyed either as a string, or an object that contains `serial` as a property. Message is included\n * for type hinting and LLM purposes.\n *\n * The string-form of the serial should not be parsed or interpreted in any way, as it is subject to change without\n * warning.\n */\nexport type Serial =\n  | Message\n  | string\n  | {\n      /**\n       * The serial of the message.\n       */\n      serial: string;\n    };\n\n/**\n * Convert a type that may contain a serial into a string.\n *\n * @param serial - The serial to convert.\n * @returns The serial as a string.\n */\nexport const serialToString = (serial: Serial): string => {\n  let serialString = '';\n  if (typeof serial === 'string') {\n    serialString = serial;\n  } else {\n    try {\n      if ('serial' in serial) {\n        serialString = serial.serial;\n      }\n    } catch {\n      // 'in' operator failed, fall through to error\n    }\n  }\n\n  if (serialString === '') {\n    throw new Ably.ErrorInfo('invalid serial; must be string or object with serial property', 40000, 400);\n  }\n\n  return serialString;\n};\n","import * as Ably from 'ably';\n\nimport { ChannelOptionsMerger } from './channel-manager.js';\nimport {\n  AddMessageReactionParams as APIAddMessageReactionParams,\n  ChatApi,\n  DeleteMessageReactionParams as APIDeleteMessageReactionParams,\n} from './chat-api.js';\nimport {\n  AnnotationTypeToReactionType,\n  ChatMessageAction,\n  MessageReactionEventType,\n  MessageReactionRawEvent,\n  MessageReactionSummaryEvent,\n  MessageReactionType,\n  ReactionAnnotationType,\n} from './events.js';\nimport { Logger } from './logger.js';\nimport { InternalRoomOptions, MessageOptions } from './room-options.js';\nimport { Serial, serialToString } from './serial.js';\nimport { Subscription } from './subscription.js';\nimport EventEmitter, { wrap } from './utils/event-emitter.js';\n\n/**\n * A listener for summary message reaction events.\n * @param event The message reaction summary event that was received. Use it\n *   with {@link Message.with} to keep an up-to-date reaction count.\n */\nexport type MessageReactionListener = (event: MessageReactionSummaryEvent) => void;\n\n/**\n * A listener for individual message reaction events.\n * @param event The message reaction event that was received.\n */\nexport type MessageRawReactionListener = (event: MessageReactionRawEvent) => void;\n\n/**\n * Parameters for adding a message reaction.\n */\nexport interface AddMessageReactionParams {\n  /**\n   * The reaction name to add; ie. the emoji.\n   */\n  name: string;\n\n  /**\n   * The type of reaction, must be one of {@link MessageReactionType}.\n   * If not set, the default type will be used which is configured in the {@link MessageOptions.defaultMessageReactionType} of the room.\n   */\n  type?: MessageReactionType;\n\n  /**\n   * The count of the reaction for type {@link MessageReactionType.Multiple}.\n   * Defaults to 1 if not set. Not supported for other reaction types.\n   * @default 1\n   */\n  count?: number;\n}\n\n/**\n * Parameters for deleting a message reaction.\n */\nexport interface DeleteMessageReactionParams {\n  /**\n   * The reaction name to delete; ie. the emoji. Required for all reaction types\n   * except {@link MessageReactionType.Unique}.\n   */\n  name?: string;\n\n  /**\n   * The type of reaction, must be one of {@link MessageReactionType}.\n   * If not set, the default type will be used which is configured in the {@link MessageOptions.defaultMessageReactionType} of the room.\n   */\n  type?: MessageReactionType;\n}\n\n/**\n * Add, delete, and subscribe to message reactions.\n */\nexport interface MessagesReactions {\n  /**\n   * Add a message reactions\n   * @param messageSerial The serial of the message to react to\n   * @param params Describe the reaction to add.\n   * @returns A promise that resolves when the reaction is added.\n   */\n  send(messageSerial: Serial, params: AddMessageReactionParams): Promise<void>;\n\n  /**\n   * Delete a message reaction\n   * @param messageSerial The serial of the message to remove the reaction from.\n   * @param params The type of reaction annotation and the specific reaction to remove. The reaction to remove is required for all types except {@link MessageReactionType.Unique}.\n   * @returns A promise that resolves when the reaction is deleted.\n   */\n  delete(messageSerial: Serial, params?: DeleteMessageReactionParams): Promise<void>;\n\n  /**\n   * Subscribe to message reaction summaries. Use this to keep message reaction\n   * counts up to date efficiently in the UI.\n   * @param listener The listener to call when a message reaction summary is received.\n   * @returns A subscription object that should be used to unsubscribe.\n   */\n  subscribe(listener: MessageReactionListener): Subscription;\n\n  /**\n   * Subscribe to individual reaction events.\n   * @remarks If you only need to keep track of reaction counts and clients, use\n   *  {@link subscribe} instead.\n   * @param listener The listener to call when a message reaction event is received.\n   * @returns A subscription object that should be used to unsubscribe.\n   */\n  subscribeRaw(listener: MessageRawReactionListener): Subscription;\n}\n\n/**\n * Maps Ably PubSub annotation action to message reaction event type.\n */\nconst eventTypeMap: Record<string, MessageReactionEventType.Create | MessageReactionEventType.Delete> = {\n  'annotation.create': MessageReactionEventType.Create,\n  'annotation.delete': MessageReactionEventType.Delete,\n};\n\n/**\n * @inheritDoc\n */\nexport class DefaultMessageReactions implements MessagesReactions {\n  private _emitter = new EventEmitter<{\n    [MessageReactionEventType.Create]: MessageReactionRawEvent;\n    [MessageReactionEventType.Delete]: MessageReactionRawEvent;\n    [MessageReactionEventType.Summary]: MessageReactionSummaryEvent;\n  }>();\n\n  private readonly _defaultType: MessageReactionType;\n\n  constructor(\n    private readonly _logger: Logger,\n    private readonly _options: MessageOptions | undefined,\n    private readonly _api: ChatApi,\n    private readonly _roomName: string,\n    private readonly _channel: Ably.RealtimeChannel,\n  ) {\n    void _channel.subscribe(this._processMessageEvent.bind(this));\n    if (this._options?.rawMessageReactions) {\n      void _channel.annotations.subscribe(this._processAnnotationEvent.bind(this));\n    }\n    this._defaultType = this._options?.defaultMessageReactionType ?? MessageReactionType.Distinct;\n  }\n\n  private _processAnnotationEvent(event: Ably.Annotation) {\n    this._logger.trace('MessagesReactions._processAnnotationEvent();', { event });\n\n    if (!event.messageSerial) {\n      this._logger.warn(\n        'DefaultMessageReactions._processAnnotationEvent(); received event with missing messageSerial',\n        {\n          event,\n        },\n      );\n      return;\n    }\n\n    const reactionType = AnnotationTypeToReactionType[event.type];\n\n    // unknown reaction type, meaning we've received an unknown annotation type\n    if (!reactionType) {\n      this._logger.debug('DefaultMessageReactions._processAnnotationEvent(); received event with unknown type', {\n        event,\n      });\n      return;\n    }\n\n    const eventType = eventTypeMap[event.action];\n    if (!eventType) {\n      // unknown action\n      this._logger.warn('DefaultMessageReactions._processAnnotationEvent(); received event with unknown action', {\n        event,\n      });\n      return;\n    }\n\n    let name = event.name;\n    if (!name) {\n      if (eventType === MessageReactionEventType.Delete && reactionType === MessageReactionType.Unique) {\n        // deletes of type unique are allowed to have no data\n        name = '';\n      } else {\n        return;\n      }\n    }\n\n    const reactionEvent: MessageReactionRawEvent = {\n      type: eventType,\n      timestamp: new Date(event.timestamp),\n      reaction: {\n        messageSerial: event.messageSerial,\n        type: reactionType,\n        name: name,\n        clientId: event.clientId ?? '',\n      },\n    };\n    if (event.count) {\n      reactionEvent.reaction.count = event.count;\n    } else if (eventType === MessageReactionEventType.Create && reactionType === MessageReactionType.Multiple) {\n      reactionEvent.reaction.count = 1; // count defaults to 1 for multiple if not set\n    }\n    this._emitter.emit(eventType, reactionEvent);\n  }\n\n  private _processMessageEvent(event: Ably.InboundMessage) {\n    this._logger.trace('MessagesReactions._processMessageEvent();', { event });\n\n    // only process summary events\n    if (event.action !== ChatMessageAction.MessageAnnotationSummary) {\n      return;\n    }\n    if (!event.summary) {\n      // This means the summary is now empty, which is valid.\n      // Happens when there are no reactions such as after deleting the last reaction.\n      event.summary = {};\n    }\n\n    // they must have a serial\n    if (!event.serial) {\n      this._logger.warn('DefaultMessageReactions._processMessageEvent(); received summary without serial', {\n        event,\n      });\n      return;\n    }\n\n    const unique = (event.summary[ReactionAnnotationType.Unique] ?? {}) as unknown as Ably.SummaryUniqueValues;\n    const distinct = (event.summary[ReactionAnnotationType.Distinct] ?? {}) as unknown as Ably.SummaryDistinctValues;\n    const multiple = (event.summary[ReactionAnnotationType.Multiple] ?? {}) as Ably.SummaryMultipleValues;\n\n    this._emitter.emit(MessageReactionEventType.Summary, {\n      type: MessageReactionEventType.Summary,\n      summary: {\n        messageSerial: event.serial,\n        unique: unique,\n        distinct: distinct,\n        multiple: multiple,\n      },\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  send(messageSerial: Serial, params: AddMessageReactionParams): Promise<void> {\n    this._logger.trace('MessagesReactions.add();', { messageSerial, params });\n    const serial = serialToString(messageSerial);\n\n    let { type, count } = params;\n    if (!type) {\n      type = this._defaultType;\n    }\n    if (type === MessageReactionType.Multiple && !count) {\n      count = 1;\n    }\n    const apiParams: APIAddMessageReactionParams = { type, name: params.name };\n    if (count) {\n      apiParams.count = count;\n    }\n    return this._api.addMessageReaction(this._roomName, serial, apiParams);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  delete(messageSerial: Serial, params?: DeleteMessageReactionParams): Promise<void> {\n    this._logger.trace('MessagesReactions.delete();', { messageSerial, params });\n    const serial = serialToString(messageSerial);\n\n    let type = params?.type;\n    if (!type) {\n      type = this._defaultType;\n    }\n    if (type !== MessageReactionType.Unique && !params?.name) {\n      throw new Ably.ErrorInfo(`cannot delete reaction of type ${type} without a name`, 40001, 400);\n    }\n    const apiParams: APIDeleteMessageReactionParams = { type };\n    if (type !== MessageReactionType.Unique) {\n      apiParams.name = params?.name;\n    }\n    return this._api.deleteMessageReaction(this._roomName, serial, apiParams);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  subscribe(listener: MessageReactionListener): Subscription {\n    this._logger.trace('MessagesReactions.subscribe();');\n\n    const wrapped = wrap(listener);\n    this._emitter.on(MessageReactionEventType.Summary, wrapped);\n    return {\n      unsubscribe: () => {\n        this._emitter.off(wrapped);\n      },\n    };\n  }\n\n  /**\n   * @inheritDoc\n   */\n  subscribeRaw(listener: MessageRawReactionListener): Subscription {\n    this._logger.trace('MessagesReactions.subscribeRaw();');\n\n    if (!this._options?.rawMessageReactions) {\n      throw new Ably.ErrorInfo('Raw message reactions are not enabled', 40001, 400);\n    }\n    const wrapped = wrap(listener);\n    this._emitter.on([MessageReactionEventType.Create, MessageReactionEventType.Delete], wrapped);\n    return {\n      unsubscribe: () => {\n        this._emitter.off(wrapped);\n      },\n    };\n  }\n\n  /**\n   * Merges the channel options to add support for message reactions.\n   *\n   * @param roomOptions The room options to merge for.\n   * @returns A function that merges the channel options for the room with the ones required for presence.\n   */\n  static channelOptionMerger(roomOptions: InternalRoomOptions): ChannelOptionsMerger {\n    return (options) => {\n      // annotation publish is always required for message reactions\n      if (!options.modes.includes('ANNOTATION_PUBLISH')) {\n        options.modes.push('ANNOTATION_PUBLISH');\n      }\n      // annotation subscribe is only required if the room has raw message reactions\n      if (roomOptions.messages.rawMessageReactions && !options.modes.includes('ANNOTATION_SUBSCRIBE')) {\n        options.modes.push('ANNOTATION_SUBSCRIBE');\n      }\n      return options;\n    };\n  }\n}\n","import { ChatMessageAction } from './events.js';\nimport { DefaultMessage, emptyMessageReactions, Message } from './message.js';\n\n// RestClientIdList represents a list of client IDs with aggregation data\nexport interface RestClientIdList {\n  total: number;\n  clientIds: string[];\n}\n\n// RestClientIdCounts represents client ID counts with aggregation data\nexport interface RestClientIdCounts {\n  total: number;\n  clientIds: Record<string, number>;\n  totalUnidentified: number;\n}\n\n// RestOperation represents an operation performed on a chat message\nexport interface RestOperation {\n  clientId?: string;\n  description?: string;\n  metadata?: Record<string, string>;\n}\n\n// ChatMessageReactions represents reactions on a chat message\nexport interface RestChatMessageReactions {\n  unique?: Record<string, RestClientIdList>;\n  distinct?: Record<string, RestClientIdList>;\n  multiple?: Record<string, RestClientIdCounts>;\n}\n\n// RestMessage represents a message in V3 of the REST API.\nexport interface RestMessage {\n  serial: string;\n  version: string;\n  text: string;\n  clientId: string;\n  action: 'message.create' | 'message.update' | 'message.delete';\n  metadata: Record<string, unknown>;\n  headers: Record<string, string>;\n  createdAt: number;\n  timestamp: number;\n  operation?: RestOperation;\n  reactions?: RestChatMessageReactions;\n}\n\n/**\n * Converts a message object from its REST representation to the standard message object in the SDK.\n *\n * @param message The message to convert from REST.\n * @returns The converted message.\n */\nexport const messageFromRest = (message: RestMessage): Message => {\n  const reactions = {\n    ...emptyMessageReactions(),\n    ...message.reactions,\n  };\n\n  // Convert the action to a ChatMessageAction enum, defaulting to MessageCreate if the action is not found.\n  const action = Object.values(ChatMessageAction).includes(message.action as ChatMessageAction)\n    ? (message.action as ChatMessageAction)\n    : ChatMessageAction.MessageCreate;\n\n  return new DefaultMessage({\n    ...message,\n    action,\n    createdAt: new Date(message.createdAt),\n    timestamp: new Date(message.timestamp),\n    reactions: reactions,\n  });\n};\n","import * as Ably from 'ably';\n\nimport { ChatApi } from './chat-api.js';\nimport { ChatMessageAction, ChatMessageEvent, ChatMessageEventType, RealtimeMessageName } from './events.js';\nimport { Logger } from './logger.js';\nimport {\n  DefaultMessage,\n  emptyMessageReactions,\n  Message,\n  MessageHeaders,\n  MessageMetadata,\n  MessageOperationMetadata,\n} from './message.js';\nimport { parseMessage } from './message-parser.js';\nimport { DefaultMessageReactions, MessagesReactions } from './messages-reactions.js';\nimport { PaginatedResult } from './query.js';\nimport { messageFromRest } from './rest-types.js';\nimport { MessageOptions } from './room-options.js';\nimport { Serial, serialToString } from './serial.js';\nimport { Subscription } from './subscription.js';\nimport EventEmitter, { wrap } from './utils/event-emitter.js';\n\n/**\n * Event names and their respective payloads emitted by the messages feature.\n */\ninterface MessageEventsMap {\n  [ChatMessageEventType.Created]: ChatMessageEvent;\n  [ChatMessageEventType.Updated]: ChatMessageEvent;\n  [ChatMessageEventType.Deleted]: ChatMessageEvent;\n}\n\n/**\n * Mapping of chat message actions to message events.\n */\nconst MessageActionsToEventsMap: Map<ChatMessageAction, ChatMessageEventType> = new Map<\n  ChatMessageAction,\n  ChatMessageEventType\n>([\n  [ChatMessageAction.MessageCreate, ChatMessageEventType.Created],\n  [ChatMessageAction.MessageUpdate, ChatMessageEventType.Updated],\n  [ChatMessageAction.MessageDelete, ChatMessageEventType.Deleted],\n]);\n\n/**\n * The order in which results should be returned when performing a paginated query (e.g. message history).\n */\nexport enum OrderBy {\n  /**\n   * Return results in ascending order (oldest first).\n   */\n  OldestFirst = 'oldestFirst',\n\n  /**\n   * Return results in descending order (newest first).\n   */\n  NewestFirst = 'newestFirst',\n}\n\n/**\n * Options for querying messages in a chat room.\n */\nexport interface QueryOptions {\n  /**\n   * The start of the time window to query from. If provided, the response will include\n   * messages with timestamps equal to or greater than this value.\n   *\n   * @defaultValue The beginning of time\n   */\n  start?: number;\n\n  /**\n   * The end of the time window to query from. If provided, the response will include\n   * messages with timestamps less than this value.\n   *\n   * @defaultValue Now\n   */\n  end?: number;\n\n  /**\n   * The maximum number of messages to return in the response.\n   *\n   * @defaultValue 100\n   */\n  limit?: number;\n\n  /**\n   * The direction to query messages in.\n   * If {@link OrderBy.OldestFirst}, the response will include messages from the start of the time window to the end.\n   * If {@link OrderBy.NewestFirst}, the response will include messages from the end of the time window to the start.\n   * If not provided, the default is {@link OrderBy.NewestFirst}.\n   *\n   * @defaultValue {@link OrderBy.NewestFirst}\n   */\n  orderBy?: OrderBy;\n}\n\n/**\n * The parameters supplied to a message action like delete or update.\n */\nexport interface OperationDetails {\n  /**\n   * Optional description for the message action.\n   */\n  description?: string;\n\n  /**\n   * Optional metadata that will be added to the action. Defaults to empty.\n   *\n   */\n  metadata?: MessageOperationMetadata;\n}\n\n/**\n * Parameters for updating a message.\n */\nexport interface UpdateMessageParams {\n  /**\n   * The new text of the message.\n   */\n  text: string;\n\n  /**\n   * Optional metadata of the message.\n   */\n  metadata?: MessageMetadata;\n\n  /**\n   * Optional headers of the message.\n   */\n  headers?: MessageHeaders;\n}\n\n/**\n * Parameters for deleting a message.\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface DeleteMessageParams extends OperationDetails {}\n\n/**\n * Params for sending a text message. Only `text` is mandatory.\n */\nexport interface SendMessageParams {\n  /**\n   * The text of the message.\n   */\n  text: string;\n\n  /**\n   * Optional metadata of the message.\n   *\n   * The metadata is a map of extra information that can be attached to chat\n   * messages. It is not used by Ably and is sent as part of the realtime\n   * message payload. Example use cases are setting custom styling like\n   * background or text colors or fonts, adding links to external images,\n   * emojis, etc.\n   *\n   * Do not use metadata for authoritative information. There is no server-side\n   * validation. When reading the metadata, treat it like user input.\n   *\n   */\n  metadata?: MessageMetadata;\n\n  /**\n   * Optional headers of the message.\n   *\n   * The headers are a flat key-value map and are sent as part of the realtime\n   * message's extras inside the `headers` property. They can serve similar\n   * purposes as the metadata, but they are read by Ably and can be used for\n   * features such as\n   * [subscription filters](https://faqs.ably.com/subscription-filters).\n   *\n   * Do not use the headers for authoritative information. There is no\n   * server-side validation. When reading the headers, treat them like user\n   * input.\n   *\n   */\n  headers?: MessageHeaders;\n}\n\n/**\n * A listener for message events in a chat room.\n * @param event The message event that was received.\n */\nexport type MessageListener = (event: ChatMessageEvent) => void;\n\n/**\n * A response object that allows you to control a message subscription.\n */\nexport interface MessageSubscriptionResponse extends Subscription {\n  /**\n   * Get the previous messages that were sent to the room before the listener was subscribed.\n   *\n   * If the client experiences a discontinuity event (i.e. the connection was lost and could not be resumed), the starting point of\n   * historyBeforeSubscribe will be reset.\n   *\n   * Calls to historyBeforeSubscribe will wait for continuity to be restored before resolving.\n   *\n   * Once continuity is restored, the subscription point will be set to the beginning of this new period of continuity. To\n   * ensure that no messages are missed, you should call historyBeforeSubscribe after any period of discontinuity to\n   * fill any gaps in the message history.\n   *\n   * ```typescript\n   * const { historyBeforeSubscribe } = room.messages.subscribe(listener);\n   * await historyBeforeSubscribe({ limit: 10 });\n   * ```\n   *\n   * @param params Options for the history query.\n   * @returns A promise that resolves with the paginated result of messages, in newest-to-oldest order.\n   */\n  historyBeforeSubscribe(params: Omit<QueryOptions, 'orderBy'>): Promise<PaginatedResult<Message>>;\n}\n\n/**\n * This interface is used to interact with messages in a chat room: subscribing\n * to new messages, fetching history, or sending messages.\n *\n * Get an instance via {@link Room.messages}.\n */\nexport interface Messages {\n  /**\n   * Subscribe to new messages in this chat room.\n   * @param listener callback that will be called\n   * @returns A response object that allows you to control the subscription.\n   */\n  subscribe(listener: MessageListener): MessageSubscriptionResponse;\n\n  /**\n   * Get messages that have been previously sent to the chat room, based on the provided options.\n   *\n   * @param options Options for the query.\n   * @returns A promise that resolves with the paginated result of messages. This paginated result can\n   * be used to fetch more messages if available.\n   */\n  history(options: QueryOptions): Promise<PaginatedResult<Message>>;\n\n  /**\n   * Send a message in the chat room.\n   *\n   * This method uses the Ably Chat API endpoint for sending messages.\n   *\n   * Note that the Promise may resolve before OR after the message is received\n   * from the realtime channel. This means you may see the message that was just\n   * sent in a callback to `subscribe` before the returned promise resolves.\n   *\n   * @param params an object containing {text, headers, metadata} for the message\n   * to be sent. Text is required, metadata and headers are optional.\n   * @returns A promise that resolves when the message was published.\n   */\n  send(params: SendMessageParams): Promise<Message>;\n\n  /**\n   * Delete a message in the chat room.\n   *\n   * This method uses the Ably Chat API REST endpoint for deleting messages.\n   * It performs a `soft` delete, meaning the message is marked as deleted.\n   *\n   * Note that the Promise may resolve before OR after the message is deleted\n   * from the realtime channel. This means you may see the message that was just\n   * deleted in a callback to `subscribe` before the returned promise resolves.\n   *\n   * NOTE: The Message instance returned by this method is the state of the message as a result of the delete operation.\n   * If you have a subscription to message events via `subscribe`, you should discard the message instance returned by\n   * this method and use the event payloads from the subscription instead.\n   *\n   * Should you wish to restore a deleted message, and providing you have the appropriate permissions,\n   * you can simply send an update to the original message.\n   * Note: This is subject to change in future versions, whereby a new permissions model will be introduced\n   * and a deleted message may not be restorable in this way.\n   *\n   * @returns A promise that resolves when the message was deleted.\n   * @param serial - A string or object that conveys the serial of the message to delete.\n   * @param deleteMessageParams - Optional details to record about the delete action.\n   * @return A promise that resolves to the deleted message.\n   */\n  delete(serial: Serial, deleteMessageParams?: DeleteMessageParams): Promise<Message>;\n\n  /**\n   * Update a message in the chat room.\n   *\n   * Note that the Promise may resolve before OR after the updated message is\n   * received from the realtime channel. This means you may see the update that\n   * was just sent in a callback to `subscribe` before the returned promise\n   * resolves.\n   *\n   * NOTE: The Message instance returned by this method is the state of the message as a result of the update operation.\n   * If you have a subscription to message events via `subscribe`, you should discard the message instance returned by\n   * this method and use the event payloads from the subscription instead.\n   *\n   * This method uses PUT-like semantics: if headers and metadata are omitted from the updateParams, then\n   * the existing headers and metadata are replaced with the empty objects.\n   *\n   * @param serial - A string or object that conveys the serial of the message to update.\n   * @param updateParams - The parameters for updating the message.\n   * @param details - Optional details to record about the update action.\n   * @returns A promise of the updated message.\n   */\n  update(serial: Serial, updateParams: UpdateMessageParams, details?: OperationDetails): Promise<Message>;\n\n  /**\n   * Add, delete, and subscribe to message reactions.\n   */\n  reactions: MessagesReactions;\n}\n\n/**\n * @inheritDoc\n */\nexport class DefaultMessages implements Messages {\n  private readonly _roomName: string;\n  private readonly _options: MessageOptions;\n  private readonly _channel: Ably.RealtimeChannel;\n  private readonly _chatApi: ChatApi;\n  private readonly _clientId: string;\n  private readonly _listenerSubscriptionPoints: Map<\n    MessageListener,\n    Promise<{\n      fromSerial: string;\n    }>\n  >;\n  private readonly _logger: Logger;\n  private readonly _emitter = new EventEmitter<MessageEventsMap>();\n\n  public readonly reactions: MessagesReactions;\n\n  /**\n   * Constructs a new `DefaultMessages` instance.\n   * @param roomName The unique identifier of the room.\n   * @param channel An instance of the Realtime channel for the room.\n   * @param chatApi An instance of the ChatApi.\n   * @param clientId The client ID of the user.\n   * @param logger An instance of the Logger.\n   */\n  constructor(\n    roomName: string,\n    options: MessageOptions,\n    channel: Ably.RealtimeChannel,\n    chatApi: ChatApi,\n    clientId: string,\n    logger: Logger,\n  ) {\n    this._roomName = roomName;\n    this._options = options;\n    this._channel = channel;\n    this._chatApi = chatApi;\n    this._clientId = clientId;\n    this._logger = logger;\n    this._listenerSubscriptionPoints = new Map<MessageListener, Promise<{ fromSerial: string }>>();\n\n    this.reactions = new DefaultMessageReactions(this._logger, options, this._chatApi, this._roomName, this._channel);\n    this._applyChannelSubscriptions();\n  }\n\n  /**\n   * Sets up channel subscriptions for messages.\n   */\n  private _applyChannelSubscriptions(): void {\n    // attachOnSubscribe is set to false in the default channel options, so this call cannot fail\n    void this._channel.subscribe([RealtimeMessageName.ChatMessage], this._processEvent.bind(this));\n\n    // Handles the case where channel attaches and resume state is false. This can happen when the channel is first attached,\n    // or when the channel is reattached after a detach. In both cases, we reset the subscription points for all listeners.\n    this._channel.on('attached', (message) => {\n      this._handleAttach(message.resumed);\n    });\n\n    // Handles the case where an update message is received from a channel after a detach and reattach.\n    this._channel.on('update', (message) => {\n      if (message.current === 'attached' && message.previous === 'attached') {\n        this._handleAttach(message.resumed);\n      }\n    });\n  }\n\n  /**\n   * @inheritdoc Messages\n   */\n  private async _getBeforeSubscriptionStart(\n    listener: MessageListener,\n    params: Omit<QueryOptions, 'orderBy'>,\n  ): Promise<PaginatedResult<Message>> {\n    this._logger.trace(`DefaultSubscriptionManager.getBeforeSubscriptionStart();`);\n\n    const subscriptionPoint = this._listenerSubscriptionPoints.get(listener);\n\n    if (subscriptionPoint === undefined) {\n      this._logger.error(\n        `DefaultSubscriptionManager.getBeforeSubscriptionStart(); listener has not been subscribed yet`,\n      );\n      throw new Ably.ErrorInfo(\n        'cannot query history; listener has not been subscribed yet',\n        40000,\n        400,\n      ) as unknown as Error;\n    }\n\n    // Get the subscription point of the listener\n    const subscriptionPointParams = await subscriptionPoint;\n\n    // Query messages from the subscription point to the start of the time window\n    return this._chatApi.getMessages(this._roomName, {\n      ...params,\n      orderBy: OrderBy.NewestFirst,\n      ...subscriptionPointParams,\n    });\n  }\n\n  /**\n   * Handle the case where the channel experiences a detach and reattaches.\n   */\n  private _handleAttach(fromResume: boolean) {\n    this._logger.trace(`DefaultSubscriptionManager.handleAttach();`);\n\n    // Do nothing if we have resumed as there is no discontinuity in the message stream\n    if (fromResume) return;\n\n    // Reset subscription points for all listeners\n    const newSubscriptionStartResolver = this._subscribeAtChannelAttach();\n    for (const [listener] of this._listenerSubscriptionPoints.entries()) {\n      this._listenerSubscriptionPoints.set(listener, newSubscriptionStartResolver);\n    }\n  }\n\n  /**\n   * Create a promise that resolves with the attachSerial of the channel or the serial of the latest message.\n   */\n  private async _resolveSubscriptionStart(): Promise<{\n    fromSerial: string;\n  }> {\n    const channelWithProperties = this._getChannelProperties();\n\n    // If we are attached, we can resolve with the channelSerial\n    if (channelWithProperties.state === 'attached') {\n      if (channelWithProperties.properties.channelSerial) {\n        return { fromSerial: channelWithProperties.properties.channelSerial };\n      }\n      this._logger.error(`DefaultSubscriptionManager.handleAttach(); channelSerial is undefined`);\n      throw new Ably.ErrorInfo('channel is attached, but channelSerial is not defined', 40000, 400) as unknown as Error;\n    }\n\n    return this._subscribeAtChannelAttach();\n  }\n\n  private _getChannelProperties(): Ably.RealtimeChannel & {\n    properties: { attachSerial: string | undefined; channelSerial: string | undefined };\n  } {\n    // Get the attachSerial from the channel properties\n    return this._channel as Ably.RealtimeChannel & {\n      properties: {\n        attachSerial: string | undefined;\n        channelSerial: string | undefined;\n      };\n    };\n  }\n\n  private async _subscribeAtChannelAttach(): Promise<{ fromSerial: string }> {\n    const channelWithProperties = this._getChannelProperties();\n    return new Promise((resolve, reject) => {\n      // Check if the state is now attached\n      if (channelWithProperties.state === 'attached') {\n        // Get the attachSerial from the channel properties\n        // AttachSerial should always be defined at this point, but we check just in case\n        this._logger.debug('Messages._subscribeAtChannelAttach(); channel is attached already, using attachSerial', {\n          attachSerial: channelWithProperties.properties.attachSerial,\n        });\n        if (channelWithProperties.properties.attachSerial) {\n          resolve({ fromSerial: channelWithProperties.properties.attachSerial });\n        } else {\n          this._logger.error(`DefaultSubscriptionManager.handleAttach(); attachSerial is undefined`);\n          reject(\n            new Ably.ErrorInfo('channel is attached, but attachSerial is not defined', 40000, 400) as unknown as Error,\n          );\n        }\n      }\n\n      channelWithProperties.once('attached', () => {\n        // Get the attachSerial from the channel properties\n        // AttachSerial should always be defined at this point, but we check just in case\n        this._logger.debug('Messages._subscribeAtChannelAttach(); channel is now attached, using attachSerial', {\n          attachSerial: channelWithProperties.properties.attachSerial,\n        });\n        if (channelWithProperties.properties.attachSerial) {\n          resolve({ fromSerial: channelWithProperties.properties.attachSerial });\n        } else {\n          this._logger.error(`DefaultSubscriptionManager.handleAttach(); attachSerial is undefined`);\n          reject(\n            new Ably.ErrorInfo('channel is attached, but attachSerial is not defined', 40000, 400) as unknown as Error,\n          );\n        }\n      });\n    });\n  }\n\n  /**\n   * @inheritdoc Messages\n   */\n  async history(options: QueryOptions): Promise<PaginatedResult<Message>> {\n    this._logger.trace('Messages.query();');\n    return this._chatApi.getMessages(this._roomName, options);\n  }\n\n  /**\n   * @inheritdoc Messages\n   */\n  async send(params: SendMessageParams): Promise<Message> {\n    this._logger.trace('Messages.send();', { params });\n\n    const { text, metadata, headers } = params;\n\n    const response = await this._chatApi.sendMessage(this._roomName, { text, headers, metadata });\n    return new DefaultMessage({\n      serial: response.serial,\n      clientId: this._clientId,\n      text: text,\n      metadata: metadata ?? {},\n      headers: headers ?? {},\n      action: ChatMessageAction.MessageCreate,\n      version: response.serial,\n      createdAt: new Date(response.createdAt),\n      timestamp: new Date(response.createdAt), // timestamp is the same as createdAt for new messages\n      reactions: emptyMessageReactions(),\n    });\n  }\n\n  /**\n   * @inheritdoc Messages\n   */\n  async delete(serial: Serial, params?: DeleteMessageParams): Promise<Message> {\n    this._logger.trace('Messages.delete();', { params });\n\n    serial = serialToString(serial);\n    this._logger.debug('Messages.delete(); serial', { serial });\n    const response = await this._chatApi.deleteMessage(this._roomName, serial, params);\n\n    return messageFromRest(response.message);\n  }\n\n  /**\n   * @inheritdoc Messages\n   */\n  async update(serial: Serial, updateParams: UpdateMessageParams, details?: OperationDetails): Promise<Message> {\n    this._logger.trace('Messages.update();', { updateParams, details });\n\n    serial = serialToString(serial);\n    this._logger.debug('Messages.update(); serial', { serial });\n    const response = await this._chatApi.updateMessage(this._roomName, serial, {\n      message: {\n        text: updateParams.text,\n        metadata: updateParams.metadata,\n        headers: updateParams.headers,\n      },\n      ...details,\n    });\n\n    this._logger.debug('Messages.update(); message update successfully', { updateParams });\n    return messageFromRest(response.message);\n  }\n\n  /**\n   * @inheritdoc Messages\n   */\n  subscribe(listener: MessageListener): MessageSubscriptionResponse {\n    this._logger.trace('Messages.subscribe();');\n    const wrapped = wrap(listener);\n    this._emitter.on(\n      [ChatMessageEventType.Created, ChatMessageEventType.Updated, ChatMessageEventType.Deleted],\n      wrapped,\n    );\n\n    // Set the subscription point to a promise that resolves when the channel attaches or with the latest message\n    const resolvedSubscriptionStart = this._resolveSubscriptionStart();\n\n    // Add a handler for unhandled rejections in case the room is released before the subscription point is resolved\n    resolvedSubscriptionStart.catch(() => {\n      this._logger.debug('Messages.subscribe(); subscription point was not resolved before the room was released');\n    });\n\n    this._listenerSubscriptionPoints.set(wrapped, resolvedSubscriptionStart);\n\n    return {\n      unsubscribe: () => {\n        // Remove the wrapped listener from the subscription points\n        this._listenerSubscriptionPoints.delete(wrapped);\n        this._logger.trace('Messages.unsubscribe();');\n        this._emitter.off(wrapped);\n      },\n      historyBeforeSubscribe: (params: Omit<QueryOptions, 'orderBy'>) =>\n        this._getBeforeSubscriptionStart(wrapped, params),\n    };\n  }\n\n  private _processEvent(channelEventMessage: Ably.InboundMessage) {\n    this._logger.trace('Messages._processEvent();', {\n      channelEventMessage,\n    });\n    const { action } = channelEventMessage;\n    const event = MessageActionsToEventsMap.get(action as ChatMessageAction);\n    if (!event) {\n      this._logger.debug('Messages._processEvent(); received unknown message action', { action });\n      return;\n    }\n    // Send the message to the listeners\n    const message = this._parseNewMessage(channelEventMessage);\n    if (!message) {\n      return;\n    }\n\n    this._emitter.emit(event, { type: event, message: message });\n  }\n\n  /**\n   * Validate the realtime message and convert it to a chat message.\n   */\n  private _parseNewMessage(channelEventMessage: Ably.InboundMessage): Message | undefined {\n    try {\n      return parseMessage(channelEventMessage);\n    } catch (error: unknown) {\n      this._logger.error(`failed to parse incoming message;`, { channelEventMessage, error: error as Ably.ErrorInfo });\n    }\n  }\n}\n","import * as Ably from 'ably';\n\nimport { Logger } from './logger.js';\nimport { Message, MessageHeaders, MessageMetadata, MessageOperationMetadata } from './message.js';\nimport { OrderBy } from './messages.js';\nimport { OccupancyData } from './occupancy.js';\nimport { PaginatedResult } from './query.js';\nimport { messageFromRest, RestMessage } from './rest-types.js';\n\nexport interface GetMessagesQueryParams {\n  start?: number;\n  end?: number;\n  orderBy?: OrderBy;\n  limit?: number;\n  /**\n   * Serial indicating the starting point for message retrieval.\n   * This serial is specific to the region of the channel the client is connected to. Messages published within\n   * the same region of the channel are guaranteed to be received in increasing serial order.\n   *\n   * @defaultValue undefined (not used if not specified)\n   */\n  fromSerial?: string;\n}\n\n/**\n * In the REST API, we currently use the `direction` query parameter to specify the order of messages instead\n * of orderBy. So define this type for conversion purposes.\n */\ntype ApiGetMessagesQueryParams = Omit<GetMessagesQueryParams, 'orderBy'> & {\n  direction?: 'forwards' | 'backwards';\n};\n\nexport interface CreateMessageResponse {\n  serial: string;\n  createdAt: number;\n}\n\ninterface SendMessageParams {\n  text: string;\n  metadata?: MessageMetadata;\n  headers?: MessageHeaders;\n}\n\n/**\n * Represents the response for deleting or updating a message.\n */\nexport interface MessageOperationResponse {\n  /**\n   * The new message version.\n   */\n  version: string;\n\n  /**\n   * The timestamp of the operation.\n   */\n  timestamp: number;\n\n  /**\n   * The message that was created or updated.\n   */\n  message: RestMessage;\n}\n\ntype UpdateMessageResponse = MessageOperationResponse;\n\ntype DeleteMessageResponse = MessageOperationResponse;\n\ninterface UpdateMessageParams {\n  /**\n   * Message data to update. All fields are updated and, if omitted, they are\n   * set to empty.\n   */\n  message: {\n    text: string;\n    metadata?: MessageMetadata;\n    headers?: MessageHeaders;\n  };\n\n  /** Description of the update action */\n  description?: string;\n\n  /** Metadata of the update action */\n  metadata?: MessageOperationMetadata;\n}\n\ninterface DeleteMessageParams {\n  /** Description of the delete action */\n  description?: string;\n\n  /** Metadata of the delete action */\n  metadata?: MessageOperationMetadata;\n}\n\n/**\n * Parameters for adding a message reaction.\n */\nexport interface AddMessageReactionParams {\n  /**\n   * The type of reaction, must be one of {@link MessageReactionType}.\n   */\n  type: string;\n\n  /**\n   * The reaction name to add; ie. the emoji.\n   */\n  name: string;\n\n  /**\n   * The count of the reaction for type {@link MessageReactionType.Multiple}.\n   * Defaults to 1 if not set. Not supported for other reaction types.\n   * @default 1\n   */\n  count?: number;\n}\n\n/**\n * Parameters for deleting a message reaction.\n */\nexport interface DeleteMessageReactionParams {\n  /**\n   * The type of reaction, must be one of {@link MessageReactionType}.\n   */\n  type: string;\n\n  /**\n   * The reaction name to remove, ie. the emoji. Required for all reaction types\n   * except {@link MessageReactionType.Unique}.\n   */\n  name?: string;\n}\n\n/**\n * Chat SDK Backend\n */\nexport class ChatApi {\n  private readonly _realtime: Ably.Realtime;\n  private readonly _logger: Logger;\n  private readonly _apiProtocolVersion: number = 3;\n\n  constructor(realtime: Ably.Realtime, logger: Logger) {\n    this._realtime = realtime;\n    this._logger = logger;\n  }\n\n  async getMessages(roomName: string, params: GetMessagesQueryParams): Promise<PaginatedResult<Message>> {\n    roomName = encodeURIComponent(roomName);\n\n    // convert the params into internal format\n    const apiParams: ApiGetMessagesQueryParams = { ...params };\n    if (params.orderBy) {\n      switch (params.orderBy) {\n        case OrderBy.NewestFirst: {\n          apiParams.direction = 'backwards';\n          break;\n        }\n        case OrderBy.OldestFirst: {\n          apiParams.direction = 'forwards';\n          break;\n        }\n        default: {\n          // in vanilla JS use-cases, without types, we need to check non-enum values\n          // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n          throw new Ably.ErrorInfo(`invalid orderBy value: ${params.orderBy}`, 40000, 400);\n        }\n      }\n    }\n\n    const data = await this._makeAuthorizedPaginatedRequest<RestMessage>(\n      `/chat/v3/rooms/${roomName}/messages`,\n      apiParams,\n    );\n    return this._recursivePaginateMessages(data);\n  }\n\n  private _recursivePaginateMessages(data: PaginatedResult<RestMessage>): PaginatedResult<Message> {\n    const paginatedResult: PaginatedResult<Message> = {} as PaginatedResult<Message>;\n    paginatedResult.items = data.items.map((payload) => messageFromRest(payload));\n\n    // Recursively map the next paginated data\n    paginatedResult.next = () =>\n      data.next().then((nextData) => {\n        // eslint-disable-next-line unicorn/no-null\n        return nextData ? this._recursivePaginateMessages(nextData) : null;\n      });\n\n    paginatedResult.first = () => data.first().then((firstData) => this._recursivePaginateMessages(firstData));\n\n    paginatedResult.current = () => data.current().then((currentData) => this._recursivePaginateMessages(currentData));\n\n    paginatedResult.hasNext = () => data.hasNext();\n\n    paginatedResult.isLast = () => data.isLast();\n\n    return { ...data, ...paginatedResult };\n  }\n\n  deleteMessage(roomName: string, serial: string, params?: DeleteMessageParams): Promise<DeleteMessageResponse> {\n    const body: { description?: string; metadata?: MessageOperationMetadata } = {\n      description: params?.description,\n      metadata: params?.metadata,\n    };\n    serial = encodeURIComponent(serial);\n    roomName = encodeURIComponent(roomName);\n    return this._makeAuthorizedRequest<DeleteMessageResponse>(\n      `/chat/v3/rooms/${roomName}/messages/${serial}/delete`,\n      'POST',\n      body,\n      {},\n    );\n  }\n\n  sendMessage(roomName: string, params: SendMessageParams): Promise<CreateMessageResponse> {\n    const body: {\n      text: string;\n      metadata?: MessageMetadata;\n      headers?: MessageHeaders;\n    } = { text: params.text };\n    if (params.metadata) {\n      body.metadata = params.metadata;\n    }\n    if (params.headers) {\n      body.headers = params.headers;\n    }\n    roomName = encodeURIComponent(roomName);\n    return this._makeAuthorizedRequest<CreateMessageResponse>(`/chat/v3/rooms/${roomName}/messages`, 'POST', body);\n  }\n\n  updateMessage(roomName: string, serial: string, params: UpdateMessageParams): Promise<UpdateMessageResponse> {\n    const encodedSerial = encodeURIComponent(serial);\n    roomName = encodeURIComponent(roomName);\n    return this._makeAuthorizedRequest<UpdateMessageResponse>(\n      `/chat/v3/rooms/${roomName}/messages/${encodedSerial}`,\n      'PUT',\n      params,\n    );\n  }\n\n  addMessageReaction(roomName: string, serial: string, data: AddMessageReactionParams): Promise<void> {\n    const encodedSerial = encodeURIComponent(serial);\n    roomName = encodeURIComponent(roomName);\n    return this._makeAuthorizedRequest(`/chat/v3/rooms/${roomName}/messages/${encodedSerial}/reactions`, 'POST', data);\n  }\n\n  deleteMessageReaction(roomName: string, serial: string, data: DeleteMessageReactionParams): Promise<void> {\n    const encodedSerial = encodeURIComponent(serial);\n    roomName = encodeURIComponent(roomName);\n    return this._makeAuthorizedRequest(\n      `/chat/v3/rooms/${roomName}/messages/${encodedSerial}/reactions`,\n      'DELETE',\n      undefined,\n      data,\n    );\n  }\n\n  getOccupancy(roomName: string): Promise<OccupancyData> {\n    roomName = encodeURIComponent(roomName);\n    return this._makeAuthorizedRequest<OccupancyData>(`/chat/v3/rooms/${roomName}/occupancy`, 'GET');\n  }\n\n  private async _makeAuthorizedRequest<RES = undefined>(\n    url: string,\n    method: 'POST' | 'GET' | 'PUT' | 'DELETE' | 'PATCH',\n    body?: unknown,\n    params?: unknown,\n  ): Promise<RES> {\n    const response = await this._realtime.request<RES>(method, url, this._apiProtocolVersion, params, body);\n    if (!response.success) {\n      this._logger.error('ChatApi._makeAuthorizedRequest(); failed to make request', {\n        url,\n        statusCode: response.statusCode,\n        errorCode: response.errorCode,\n        errorMessage: response.errorMessage,\n      });\n      throw new Ably.ErrorInfo(response.errorMessage, response.errorCode, response.statusCode);\n    }\n\n    return response.items[0] as RES;\n  }\n\n  private async _makeAuthorizedPaginatedRequest<RES>(\n    url: string,\n    params?: unknown,\n    body?: unknown,\n  ): Promise<PaginatedResult<RES>> {\n    const response = await this._realtime.request('GET', url, this._apiProtocolVersion, params, body);\n    if (!response.success) {\n      this._logger.error('ChatApi._makeAuthorizedPaginatedRequest(); failed to make request', {\n        url,\n        statusCode: response.statusCode,\n        errorCode: response.errorCode,\n        errorMessage: response.errorMessage,\n      });\n      throw new Ably.ErrorInfo(response.errorMessage, response.errorCode, response.statusCode);\n    }\n    return response;\n  }\n}\n","import * as Ably from 'ably';\n\n/**\n * Error codes for the Chat SDK.\n */\nexport enum ErrorCode {\n  /**\n   * The request was invalid.\n   */\n  BadRequest = 40000,\n\n  /**\n   * The message was rejected before publishing by a rule on the chat room.\n   */\n  MessageRejectedByBeforePublishRule = 42211,\n\n  /**\n   * The message was rejected before publishing by a moderation rule on the chat room.\n   */\n  MessageRejectedByModeration = 42213,\n\n  /**\n   * The room has experienced a discontinuity.\n   */\n  RoomDiscontinuity = 102100,\n\n  // Unable to perform operation;\n\n  /**\n   * Cannot perform operation because the room is in a failed state.\n   */\n  RoomInFailedState = 102101,\n\n  /**\n   * Cannot perform operation because the room is in a releasing state.\n   */\n  RoomIsReleasing = 102102,\n\n  /**\n   * Cannot perform operation because the room is in a released state.\n   */\n  RoomIsReleased = 102103,\n\n  /**\n   * Room was released before the operation could complete.\n   */\n  RoomReleasedBeforeOperationCompleted = 102106,\n}\n\n/**\n * Returns true if the {@link Ably.ErrorInfo} code matches the provided ErrorCode value.\n *\n * @param errorInfo The error info to check.\n * @param error The error code to compare against.\n * @returns true if the error code matches, false otherwise.\n */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\nexport const errorInfoIs = (errorInfo: Ably.ErrorInfo, error: ErrorCode): boolean => errorInfo.code === error;\n","/**\n * Generates a random string that can be used as an identifier, for instance, in identifying specific room\n * objects.\n *\n * @returns A random string that can be used as an identifier.\n */\nexport const randomId = (): string => Math.random().toString(36).slice(2);\n","/**\n * Gets the single main channel for the chat room.\n *\n * @param roomName The room name.\n * @returns  The channel name.\n */\nexport const roomChannelName = (roomName: string): string => `${roomName}::$chat`;\n","import * as Ably from 'ably';\n\n// Update this when you release a new version\nexport const VERSION = '0.10.0';\nexport const CHANNEL_OPTIONS_AGENT_STRING = `chat-js/${VERSION}`;\nexport const CHANNEL_OPTIONS_AGENT_STRING_REACT = `chat-react/${VERSION}`;\n// Modes required for basic message functionality\nexport const DEFAULT_CHANNEL_MODES: Ably.ChannelMode[] = ['PUBLISH', 'SUBSCRIBE'];\nexport const DEFAULT_CHANNEL_OPTIONS: Ably.ChannelOptions = {\n  params: { agent: CHANNEL_OPTIONS_AGENT_STRING },\n  attachOnSubscribe: false,\n  modes: DEFAULT_CHANNEL_MODES,\n};\n\nexport const DEFAULT_CHANNEL_OPTIONS_REACT: Ably.ChannelOptions = {\n  params: { agent: CHANNEL_OPTIONS_AGENT_STRING_REACT },\n  attachOnSubscribe: false,\n  modes: DEFAULT_CHANNEL_MODES,\n};\n","import * as Ably from 'ably';\n\nimport { roomChannelName } from './channel.js';\nimport { Logger } from './logger.js';\nimport { DEFAULT_CHANNEL_OPTIONS, DEFAULT_CHANNEL_OPTIONS_REACT } from './version.js';\n\nexport type ChannelOptionsWithModes = Omit<Ably.ChannelOptions, 'modes'> & Required<Pick<Ably.ChannelOptions, 'modes'>>;\n\nexport type ChannelOptionsMerger = (options: ChannelOptionsWithModes) => ChannelOptionsWithModes;\n\nexport class ChannelManager {\n  private readonly _realtime: Ably.Realtime;\n  private readonly _logger: Logger;\n  private _registeredOptions: ChannelOptionsWithModes;\n  private readonly _isReact: boolean;\n  private _resolvedChannel?: Ably.RealtimeChannel;\n  private readonly _channelId: string;\n\n  constructor(roomName: string, realtime: Ably.Realtime, logger: Logger, isReact: boolean) {\n    logger.trace('ChannelManager();', { isReact });\n    this._realtime = realtime;\n    this._logger = logger;\n    this._isReact = isReact;\n    this._registeredOptions = this._defaultChannelOptions();\n    this._channelId = roomChannelName(roomName);\n  }\n\n  mergeOptions(merger: ChannelOptionsMerger): void {\n    this._logger.trace('ChannelManager.mergeOptions();');\n    if (this._resolvedChannel) {\n      this._logger.error('channel options cannot be modified after the channel has been requested');\n      throw new Ably.ErrorInfo('channel options cannot be modified after the channel has been requested', 40000, 400);\n    }\n\n    this._registeredOptions = merger(this._registeredOptions);\n  }\n\n  get(): Ably.RealtimeChannel {\n    this._logger.trace('ChannelManager.get();');\n\n    this._resolvedChannel ??= this._realtime.channels.get(this._channelId, this._registeredOptions);\n\n    return this._resolvedChannel;\n  }\n\n  release(): void {\n    this._logger.trace('ChannelManager.release();', { channelId: this._channelId });\n    if (!this._resolvedChannel) {\n      return;\n    }\n\n    this._realtime.channels.release(this._channelId);\n  }\n\n  private _defaultChannelOptions(): ChannelOptionsWithModes {\n    this._logger.trace('ChannelManager._defaultChannelOptions();');\n\n    const baseOptions = this._isReact ? DEFAULT_CHANNEL_OPTIONS_REACT : DEFAULT_CHANNEL_OPTIONS;\n    this._logger.trace(this._isReact ? 'using react channel options' : 'using default channel options');\n\n    // Create a deep copy of the options, ensuring modes array is also copied\n    return { ...baseOptions, modes: [...(baseOptions.modes ?? [])] } as ChannelOptionsWithModes;\n  }\n}\n","import * as Ably from 'ably';\n\nimport { ChannelOptionsMerger } from './channel-manager.js';\nimport { ChatApi } from './chat-api.js';\nimport { OccupancyEvent, OccupancyEventType, RealtimeMetaEventType } from './events.js';\nimport { Logger } from './logger.js';\nimport { InternalRoomOptions } from './room-options.js';\nimport { Subscription } from './subscription.js';\nimport EventEmitter, { wrap } from './utils/event-emitter.js';\n\n/**\n * This interface is used to interact with occupancy in a chat room: subscribing to occupancy updates and\n * fetching the current room occupancy metrics.\n *\n * Get an instance via {@link Room.occupancy}.\n */\nexport interface Occupancy {\n  /**\n   * Subscribe a given listener to occupancy updates of the chat room.\n   *\n   * Note: This requires occupancy events to be enabled via the `enableEvents` option in\n   * the {@link OccupancyOptions} options provided to the room. If this is not enabled, an error will be thrown.\n   *\n   * @param listener A listener to be called when the occupancy of the room changes.\n   * @returns A subscription object that can be used to unsubscribe the listener.\n   * @throws {Ably.ErrorInfo} If occupancy events are not enabled for this room.\n   */\n  subscribe(listener: OccupancyListener): Subscription;\n\n  /**\n   * Get the current occupancy of the chat room.\n   *\n   * @returns A promise that resolves to the current occupancy of the chat room.\n   */\n  get(): Promise<OccupancyData>;\n\n  /**\n   * Get the latest occupancy data received from realtime events.\n   *\n   * @returns The latest occupancy data, or undefined if no realtime events have been received yet.\n   * @throws {Ably.ErrorInfo} If occupancy events are not enabled for this room.\n   */\n  current(): OccupancyData | undefined;\n}\n\n/**\n * Represents the occupancy data of a chat room.\n */\nexport interface OccupancyData {\n  /**\n   * The number of connections to the chat room.\n   */\n  connections: number;\n\n  /**\n   * The number of presence members in the chat room - members who have entered presence.\n   */\n  presenceMembers: number;\n}\n\n/**\n * A listener that is called when the occupancy of a chat room changes.\n * @param event The occupancy event.\n */\nexport type OccupancyListener = (event: OccupancyEvent) => void;\n\ninterface OccupancyEventsMap {\n  [OccupancyEventType.Updated]: OccupancyEvent;\n}\n\n/**\n * @inheritDoc\n */\nexport class DefaultOccupancy implements Occupancy {\n  private readonly _roomName: string;\n  private readonly _channel: Ably.RealtimeChannel;\n  private readonly _chatApi: ChatApi;\n  private readonly _logger: Logger;\n  private readonly _emitter = new EventEmitter<OccupancyEventsMap>();\n  private readonly _roomOptions: InternalRoomOptions;\n  private _latestOccupancyData?: OccupancyData;\n\n  /**\n   * Constructs a new `DefaultOccupancy` instance.\n   * @param roomName The unique identifier of the room.\n   * @param channel An instance of the Realtime channel.\n   * @param chatApi An instance of the ChatApi.\n   * @param logger An instance of the Logger.\n   * @param roomOptions The room options.\n   */\n  constructor(\n    roomName: string,\n    channel: Ably.RealtimeChannel,\n    chatApi: ChatApi,\n    logger: Logger,\n    roomOptions: InternalRoomOptions,\n  ) {\n    this._roomName = roomName;\n    this._channel = channel;\n    this._chatApi = chatApi;\n    this._logger = logger;\n    this._roomOptions = roomOptions;\n\n    this._applyChannelSubscriptions();\n  }\n\n  /**\n   * Sets up channel subscriptions for occupancy.\n   */\n  private _applyChannelSubscriptions(): void {\n    // attachOnSubscribe is set to false in the default channel options, so this call cannot fail\n    void this._channel.subscribe([RealtimeMetaEventType.Occupancy], this._internalOccupancyListener.bind(this));\n  }\n\n  /**\n   * @inheritdoc Occupancy\n   */\n  subscribe(listener: OccupancyListener): Subscription {\n    this._logger.trace('Occupancy.subscribe();');\n\n    if (!this._roomOptions.occupancy.enableEvents) {\n      throw new Ably.ErrorInfo(\n        'cannot subscribe to occupancy; occupancy events are not enabled in room options',\n        40000,\n        400,\n      ) as unknown as Error;\n    }\n\n    const wrapped = wrap(listener);\n    this._emitter.on(wrapped);\n\n    return {\n      unsubscribe: () => {\n        this._logger.trace('Occupancy.unsubscribe();');\n        this._emitter.off(wrapped);\n      },\n    };\n  }\n\n  /**\n   * @inheritdoc Occupancy\n   */\n  async get(): Promise<OccupancyData> {\n    this._logger.trace('Occupancy.get();');\n    return this._chatApi.getOccupancy(this._roomName);\n  }\n\n  /**\n   * @inheritdoc Occupancy\n   */\n  current(): OccupancyData | undefined {\n    this._logger.trace('Occupancy.current();');\n\n    // CHA-O7c\n    if (!this._roomOptions.occupancy.enableEvents) {\n      throw new Ably.ErrorInfo(\n        'cannot get current occupancy; occupancy events are not enabled in room options',\n        40000,\n        400,\n      ) as unknown as Error;\n    }\n\n    // CHA-07a\n    // CHA-07b\n    return this._latestOccupancyData;\n  }\n\n  /**\n   * An internal listener that listens for occupancy events from the underlying channel and translates them into\n   * occupancy events for the public API.\n   */\n  private _internalOccupancyListener(message: Ably.InboundMessage): void {\n    this._logger.trace('Occupancy._internalOccupancyListener();', message);\n    if (typeof message.data !== 'object') {\n      this._logger.error(\n        'Occupancy._internalOccupancyListener(); invalid occupancy event received; data is not an object',\n        message,\n      );\n      return;\n    }\n\n    const { metrics } = message.data as { metrics?: { connections?: number; presenceMembers?: number } };\n\n    if (metrics === undefined) {\n      this._logger.error(\n        'Occupancy._internalOccupancyListener(); invalid occupancy event received; metrics is missing',\n        message,\n      );\n      return;\n    }\n\n    const { connections, presenceMembers } = metrics;\n\n    if (connections === undefined) {\n      this._logger.error(\n        'Occupancy._internalOccupancyListener(); invalid occupancy event received; connections is missing',\n        message,\n      );\n      return;\n    }\n\n    if (!Number.isInteger(connections)) {\n      this._logger.error(\n        'Occupancy._internalOccupancyListener(); invalid occupancy event received; connections is not a number',\n        message,\n      );\n      return;\n    }\n\n    if (presenceMembers === undefined) {\n      this._logger.error(\n        'Occupancy._internalOccupancyListener(); invalid occupancy event received; presenceMembers is missing',\n        message,\n      );\n      return;\n    }\n\n    if (!Number.isInteger(presenceMembers)) {\n      this._logger.error(\n        'Occupancy._internalOccupancyListener(); invalid occupancy event received; presenceMembers is not a number',\n        message,\n      );\n      return;\n    }\n\n    this._latestOccupancyData = {\n      connections: connections,\n      presenceMembers: presenceMembers,\n    };\n\n    this._emitter.emit(OccupancyEventType.Updated, {\n      type: OccupancyEventType.Updated,\n      occupancy: this._latestOccupancyData,\n    });\n  }\n\n  /**\n   * Merges the channel options for the room with the ones required for occupancy.\n   *\n   * @returns A function that merges the channel options for the room with the ones required for occupancy.\n   */\n  static channelOptionMerger(roomOptions: InternalRoomOptions): ChannelOptionsMerger {\n    return (options) => {\n      // Occupancy not required, so we can skip this.\n      if (!roomOptions.occupancy.enableEvents) {\n        return options;\n      }\n\n      return { ...options, params: { ...options.params, occupancy: 'metrics' } };\n    };\n  }\n}\n","import * as Ably from 'ably';\n\nimport { ChannelOptionsMerger } from './channel-manager.js';\nimport { PresenceEventType } from './events.js';\nimport { Logger } from './logger.js';\nimport { InternalRoomOptions } from './room-options.js';\nimport { Subscription } from './subscription.js';\nimport EventEmitter, { wrap } from './utils/event-emitter.js';\n\n/**\n * Interface for PresenceEventsMap\n */\ninterface PresenceEventsMap {\n  [PresenceEventType.Enter]: PresenceEvent;\n  [PresenceEventType.Leave]: PresenceEvent;\n  [PresenceEventType.Update]: PresenceEvent;\n  [PresenceEventType.Present]: PresenceEvent;\n}\n\n/**\n * Type for PresenceData. Any JSON serializable data type.\n */\nexport type PresenceData = unknown;\n\n/**\n * Type for AblyPresenceData\n */\ninterface AblyPresenceData {\n  userCustomData: PresenceData;\n\n  [key: string]: unknown;\n}\n\n/**\n * Type for PresenceEvent\n */\nexport interface PresenceEvent {\n  /**\n   * The type of the presence event.\n   */\n  type: PresenceEventType;\n\n  /**\n   * The presence member associated with this event.\n   */\n  member: PresenceMember;\n}\n\n/**\n * Type for PresenceMember\n */\nexport interface PresenceMember {\n  /**\n   * The clientId of the presence member.\n   */\n  clientId: string;\n\n  /**\n   * The data associated with the presence member.\n   */\n  data: PresenceData;\n\n  /**\n   * The extras associated with the presence member.\n   */\n  extras: unknown;\n\n  /**\n   * The timestamp of when the last change in state occurred for this presence member.\n   */\n  updatedAt: number;\n}\n\n/**\n * Type for PresenceListener\n * @param event The presence event that was received.\n */\nexport type PresenceListener = (event: PresenceEvent) => void;\n\n/**\n * This interface is used to interact with presence in a chat room: subscribing to presence events,\n * fetching presence members, or sending presence events (join,update,leave).\n *\n * Get an instance via {@link Room.presence}.\n */\nexport interface Presence {\n  /**\n   * Method to get list of the current online users and returns the latest presence messages associated to it.\n   * @param {Ably.RealtimePresenceParams} params - Parameters that control how the presence set is retrieved.\n   * @throws If the room is not in the `attached` or `attaching` state.\n   * @returns {Promise<PresenceMessage[]>} or upon failure, the promise will be rejected with an {@link Ably.ErrorInfo} object which explains the error.\n   */\n  get(params?: Ably.RealtimePresenceParams): Promise<PresenceMember[]>;\n\n  /**\n   * Method to check if user with supplied clientId is online\n   * @param {string} clientId - The client ID to check if it is present in the room.\n   * @throws If the room is not in the `attached` or `attaching` state.\n   * @returns {Promise<{boolean}>} or upon failure, the promise will be rejected with an {@link Ably.ErrorInfo} object which explains the error.\n   */\n  isUserPresent(clientId: string): Promise<boolean>;\n\n  /**\n   * Method to join room presence, will emit an enter event to all subscribers. Repeat calls will trigger more enter events.\n   * @param {PresenceData} data - The users data, a JSON serializable object that will be sent to all subscribers.\n   * @throws If the room is not in the `attached` or `attaching` state.\n   * @returns {Promise<void>} or upon failure, the promise will be rejected with an {@link Ably.ErrorInfo} object which explains the error.\n   */\n  enter(data?: PresenceData): Promise<void>;\n\n  /**\n   * Method to update room presence, will emit an update event to all subscribers. If the user is not present, it will be treated as a join event.\n   * @param {PresenceData} data - The users data, a JSON serializable object that will be sent to all subscribers.\n   * @throws If the room is not in the `attached` or `attaching` state.\n   * @returns {Promise<void>} or upon failure, the promise will be rejected with an {@link Ably.ErrorInfo} object which explains the error.\n   */\n  update(data?: PresenceData): Promise<void>;\n\n  /**\n   * Method to leave room presence, will emit a leave event to all subscribers. If the user is not present, it will be treated as a no-op.\n   * @param {PresenceData} data - The users data, a JSON serializable object that will be sent to all subscribers.\n   * @throws If the room is not in the `attached` or `attaching` state.\n   * @returns {Promise<void>} or upon failure, the promise will be rejected with an {@link Ably.ErrorInfo} object which explains the error.\n   */\n  leave(data?: PresenceData): Promise<void>;\n\n  /**\n   * Subscribe the given listener from the given list of events.\n   *\n   * Note: This requires presence events to be enabled via the `enableEvents` option in\n   * the {@link PresenceOptions} provided to the room. If this is not enabled, an error will be thrown.\n   *\n   * @param eventOrEvents {'enter' | 'leave' | 'update' | 'present'} single event name or array of events to subscribe to\n   * @param listener listener to subscribe\n   * @throws An {@link Ably.ErrorInfo} with code 40000 if presence events are not enabled\n   */\n  subscribe(eventOrEvents: PresenceEventType | PresenceEventType[], listener?: PresenceListener): Subscription;\n\n  /**\n   * Subscribe the given listener to all presence events.\n   *\n   * Note: This requires presence events to be enabled via the `enableEvents` option in\n   * the {@link PresenceOptions} provided to the room. If this is not enabled, an error will be thrown.\n   *\n   * @param listener listener to subscribe\n   * @throws An {@link Ably.ErrorInfo} with code 40000 if presence events are not enabled\n   */\n  subscribe(listener?: PresenceListener): Subscription;\n}\n\n/**\n * @inheritDoc\n */\nexport class DefaultPresence implements Presence {\n  private readonly _channel: Ably.RealtimeChannel;\n  private readonly _clientId: string;\n  private readonly _logger: Logger;\n  private readonly _emitter = new EventEmitter<PresenceEventsMap>();\n  private readonly _options: InternalRoomOptions;\n\n  /**\n   * Constructs a new `DefaultPresence` instance.\n   * @param channel The Realtime channel instance.\n   * @param clientId The client ID, attached to presences messages as an identifier of the sender.\n   * A channel can have multiple connections using the same clientId.\n   * @param logger An instance of the Logger.\n   * @param options The room options.\n   */\n  constructor(channel: Ably.RealtimeChannel, clientId: string, logger: Logger, options: InternalRoomOptions) {\n    this._channel = channel;\n    this._clientId = clientId;\n    this._logger = logger;\n    this._options = options;\n\n    this._applyChannelSubscriptions();\n  }\n\n  /**\n   * Sets up channel subscriptions for presence.\n   */\n  private _applyChannelSubscriptions(): void {\n    // attachOnSubscribe is set to false in the default channel options, so this call cannot fail\n    void this._channel.presence.subscribe(this.subscribeToEvents.bind(this));\n  }\n\n  /**\n   * @inheritDoc\n   */\n  async get(params?: Ably.RealtimePresenceParams): Promise<PresenceMember[]> {\n    this._logger.trace('Presence.get()', { params });\n    this._assertChannelState();\n    const userOnPresence = await this._channel.presence.get(params);\n\n    // ably-js never emits the 'absent' event, so we can safely ignore it here.\n    return userOnPresence.map((user) => ({\n      clientId: user.clientId,\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      data: user.data?.userCustomData as PresenceData,\n      updatedAt: user.timestamp,\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      extras: user.extras,\n    }));\n  }\n\n  /**\n   * @inheritDoc\n   */\n  async isUserPresent(clientId: string): Promise<boolean> {\n    this._logger.trace(`Presence.isUserPresent()`, { clientId });\n    this._assertChannelState();\n    const presenceSet = await this._channel.presence.get({ clientId: clientId });\n    return presenceSet.length > 0;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  async enter(data?: PresenceData): Promise<void> {\n    this._logger.trace(`Presence.enter()`, { data });\n    this._assertChannelState();\n    const presenceEventToSend: AblyPresenceData = {\n      userCustomData: data,\n    };\n    return this._channel.presence.enterClient(this._clientId, presenceEventToSend);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  async update(data?: PresenceData): Promise<void> {\n    this._logger.trace(`Presence.update()`, { data });\n    this._assertChannelState();\n    const presenceEventToSend: AblyPresenceData = {\n      userCustomData: data,\n    };\n    return this._channel.presence.updateClient(this._clientId, presenceEventToSend);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  async leave(data?: PresenceData): Promise<void> {\n    this._logger.trace(`Presence.leave()`, { data });\n    this._assertChannelState();\n    const presenceEventToSend: AblyPresenceData = {\n      userCustomData: data,\n    };\n    return this._channel.presence.leaveClient(this._clientId, presenceEventToSend);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  subscribe(eventOrEvents: PresenceEventType | PresenceEventType[], listener?: PresenceListener): Subscription;\n  /**\n   * @inheritDoc\n   */\n  subscribe(listener?: PresenceListener): Subscription;\n  subscribe(\n    listenerOrEvents?: PresenceEventType | PresenceEventType[] | PresenceListener,\n    listener?: PresenceListener,\n  ): Subscription {\n    this._logger.trace('Presence.subscribe(); listenerOrEvents', { listenerOrEvents });\n\n    // Check if presence events are enabled\n    if (!this._options.presence.enableEvents) {\n      this._logger.error('could not subscribe to presence; presence events are not enabled');\n      throw new Ably.ErrorInfo('could not subscribe to presence; presence events are not enabled', 40000, 400);\n    }\n\n    if (!listenerOrEvents && !listener) {\n      this._logger.error('could not subscribe to presence; invalid arguments');\n      throw new Ably.ErrorInfo('could not subscribe listener: invalid arguments', 40000, 400);\n    }\n\n    // Add listener to all events\n    if (listener) {\n      const wrapped = wrap(listener);\n      this._emitter.on(listenerOrEvents as PresenceEventType, wrapped);\n      return {\n        unsubscribe: () => {\n          this._logger.trace('Presence.unsubscribe();', { events: listenerOrEvents });\n          this._emitter.off(wrapped);\n        },\n      };\n    } else {\n      const wrapped = wrap(listenerOrEvents as PresenceListener);\n      this._emitter.on(wrapped);\n      return {\n        unsubscribe: () => {\n          this._logger.trace('Presence.unsubscribe();');\n          this._emitter.off(wrapped);\n        },\n      };\n    }\n  }\n\n  /**\n   * Method to handle and emit presence events\n   * @param member - PresenceMessage ably-js object\n   * @returns void - Emits a transformed event to all subscribers, or upon failure,\n   * the promise will be rejected with an {@link ErrorInfo} object which explains the error.\n   */\n  subscribeToEvents = (member: Ably.PresenceMessage) => {\n    try {\n      const presenceData = member.data as AblyPresenceData;\n\n      // Ably-js never emits the 'absent' event, so we can safely ignore it here.\n      this._emitter.emit(member.action as PresenceEventType, {\n        type: member.action as PresenceEventType,\n        member: {\n          clientId: member.clientId,\n          data: presenceData.userCustomData,\n          extras: member.extras,\n          updatedAt: member.timestamp,\n        },\n      });\n    } catch (error) {\n      this._logger.error(`unable to handle presence event: not a valid presence event`, { action: member.action });\n      throw new Ably.ErrorInfo(\n        `unable to handle ${member.action} presence event: not a valid presence event`,\n        50000,\n        500,\n        (error as Error).message,\n      );\n    }\n  };\n\n  /**\n   * Merges the channel options for the room with the ones required for presence.\n   *\n   * @param roomOptions The room options to merge for.\n   * @returns A function that merges the channel options for the room with the ones required for presence.\n   */\n  static channelOptionMerger(roomOptions: InternalRoomOptions): ChannelOptionsMerger {\n    return (options) => {\n      // Presence mode is always required\n      if (!options.modes.includes('PRESENCE')) {\n        options.modes.push('PRESENCE');\n      }\n      // If presence events are enabled, add the PRESENCE_SUBSCRIBE mode\n      if (roomOptions.presence.enableEvents && !options.modes.includes('PRESENCE_SUBSCRIBE')) {\n        options.modes.push('PRESENCE_SUBSCRIBE');\n      }\n      return options;\n    };\n  }\n\n  private _assertChannelState(): void {\n    if (this._channel.state !== 'attaching' && this._channel.state !== 'attached') {\n      this._logger.error('could not perform presence operation; room is not attached');\n      throw new Ably.ErrorInfo('could not perform presence operation; room is not attached', 40000, 400);\n    }\n  }\n}\n","const E_TIMEOUT = new Error('timeout while waiting for mutex to become available');\nconst E_ALREADY_LOCKED = new Error('mutex already locked');\nconst E_CANCELED = new Error('request for lock canceled');\n\nvar __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Semaphore {\n    constructor(_value, _cancelError = E_CANCELED) {\n        this._value = _value;\n        this._cancelError = _cancelError;\n        this._queue = [];\n        this._weightedWaiters = [];\n    }\n    acquire(weight = 1, priority = 0) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        return new Promise((resolve, reject) => {\n            const task = { resolve, reject, weight, priority };\n            const i = findIndexFromEnd(this._queue, (other) => priority <= other.priority);\n            if (i === -1 && weight <= this._value) {\n                // Needs immediate dispatch, skip the queue\n                this._dispatchItem(task);\n            }\n            else {\n                this._queue.splice(i + 1, 0, task);\n            }\n        });\n    }\n    runExclusive(callback_1) {\n        return __awaiter$2(this, arguments, void 0, function* (callback, weight = 1, priority = 0) {\n            const [value, release] = yield this.acquire(weight, priority);\n            try {\n                return yield callback(value);\n            }\n            finally {\n                release();\n            }\n        });\n    }\n    waitForUnlock(weight = 1, priority = 0) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        if (this._couldLockImmediately(weight, priority)) {\n            return Promise.resolve();\n        }\n        else {\n            return new Promise((resolve) => {\n                if (!this._weightedWaiters[weight - 1])\n                    this._weightedWaiters[weight - 1] = [];\n                insertSorted(this._weightedWaiters[weight - 1], { resolve, priority });\n            });\n        }\n    }\n    isLocked() {\n        return this._value <= 0;\n    }\n    getValue() {\n        return this._value;\n    }\n    setValue(value) {\n        this._value = value;\n        this._dispatchQueue();\n    }\n    release(weight = 1) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        this._value += weight;\n        this._dispatchQueue();\n    }\n    cancel() {\n        this._queue.forEach((entry) => entry.reject(this._cancelError));\n        this._queue = [];\n    }\n    _dispatchQueue() {\n        this._drainUnlockWaiters();\n        while (this._queue.length > 0 && this._queue[0].weight <= this._value) {\n            this._dispatchItem(this._queue.shift());\n            this._drainUnlockWaiters();\n        }\n    }\n    _dispatchItem(item) {\n        const previousValue = this._value;\n        this._value -= item.weight;\n        item.resolve([previousValue, this._newReleaser(item.weight)]);\n    }\n    _newReleaser(weight) {\n        let called = false;\n        return () => {\n            if (called)\n                return;\n            called = true;\n            this.release(weight);\n        };\n    }\n    _drainUnlockWaiters() {\n        if (this._queue.length === 0) {\n            for (let weight = this._value; weight > 0; weight--) {\n                const waiters = this._weightedWaiters[weight - 1];\n                if (!waiters)\n                    continue;\n                waiters.forEach((waiter) => waiter.resolve());\n                this._weightedWaiters[weight - 1] = [];\n            }\n        }\n        else {\n            const queuedPriority = this._queue[0].priority;\n            for (let weight = this._value; weight > 0; weight--) {\n                const waiters = this._weightedWaiters[weight - 1];\n                if (!waiters)\n                    continue;\n                const i = waiters.findIndex((waiter) => waiter.priority <= queuedPriority);\n                (i === -1 ? waiters : waiters.splice(0, i))\n                    .forEach((waiter => waiter.resolve()));\n            }\n        }\n    }\n    _couldLockImmediately(weight, priority) {\n        return (this._queue.length === 0 || this._queue[0].priority < priority) &&\n            weight <= this._value;\n    }\n}\nfunction insertSorted(a, v) {\n    const i = findIndexFromEnd(a, (other) => v.priority <= other.priority);\n    a.splice(i + 1, 0, v);\n}\nfunction findIndexFromEnd(a, predicate) {\n    for (let i = a.length - 1; i >= 0; i--) {\n        if (predicate(a[i])) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvar __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Mutex {\n    constructor(cancelError) {\n        this._semaphore = new Semaphore(1, cancelError);\n    }\n    acquire() {\n        return __awaiter$1(this, arguments, void 0, function* (priority = 0) {\n            const [, releaser] = yield this._semaphore.acquire(1, priority);\n            return releaser;\n        });\n    }\n    runExclusive(callback, priority = 0) {\n        return this._semaphore.runExclusive(() => callback(), 1, priority);\n    }\n    isLocked() {\n        return this._semaphore.isLocked();\n    }\n    waitForUnlock(priority = 0) {\n        return this._semaphore.waitForUnlock(1, priority);\n    }\n    release() {\n        if (this._semaphore.isLocked())\n            this._semaphore.release();\n    }\n    cancel() {\n        return this._semaphore.cancel();\n    }\n}\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction withTimeout(sync, timeout, timeoutError = E_TIMEOUT) {\n    return {\n        acquire: (weightOrPriority, priority) => {\n            let weight;\n            if (isSemaphore(sync)) {\n                weight = weightOrPriority;\n            }\n            else {\n                weight = undefined;\n                priority = weightOrPriority;\n            }\n            if (weight !== undefined && weight <= 0) {\n                throw new Error(`invalid weight ${weight}: must be positive`);\n            }\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                let isTimeout = false;\n                const handle = setTimeout(() => {\n                    isTimeout = true;\n                    reject(timeoutError);\n                }, timeout);\n                try {\n                    const ticket = yield (isSemaphore(sync)\n                        ? sync.acquire(weight, priority)\n                        : sync.acquire(priority));\n                    if (isTimeout) {\n                        const release = Array.isArray(ticket) ? ticket[1] : ticket;\n                        release();\n                    }\n                    else {\n                        clearTimeout(handle);\n                        resolve(ticket);\n                    }\n                }\n                catch (e) {\n                    if (!isTimeout) {\n                        clearTimeout(handle);\n                        reject(e);\n                    }\n                }\n            }));\n        },\n        runExclusive(callback, weight, priority) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let release = () => undefined;\n                try {\n                    const ticket = yield this.acquire(weight, priority);\n                    if (Array.isArray(ticket)) {\n                        release = ticket[1];\n                        return yield callback(ticket[0]);\n                    }\n                    else {\n                        release = ticket;\n                        return yield callback();\n                    }\n                }\n                finally {\n                    release();\n                }\n            });\n        },\n        release(weight) {\n            sync.release(weight);\n        },\n        cancel() {\n            return sync.cancel();\n        },\n        waitForUnlock: (weightOrPriority, priority) => {\n            let weight;\n            if (isSemaphore(sync)) {\n                weight = weightOrPriority;\n            }\n            else {\n                weight = undefined;\n                priority = weightOrPriority;\n            }\n            if (weight !== undefined && weight <= 0) {\n                throw new Error(`invalid weight ${weight}: must be positive`);\n            }\n            return new Promise((resolve, reject) => {\n                const handle = setTimeout(() => reject(timeoutError), timeout);\n                (isSemaphore(sync)\n                    ? sync.waitForUnlock(weight, priority)\n                    : sync.waitForUnlock(priority)).then(() => {\n                    clearTimeout(handle);\n                    resolve();\n                });\n            });\n        },\n        isLocked: () => sync.isLocked(),\n        getValue: () => sync.getValue(),\n        setValue: (value) => sync.setValue(value),\n    };\n}\nfunction isSemaphore(sync) {\n    return sync.getValue !== undefined;\n}\n\n// eslint-disable-next-lisne @typescript-eslint/explicit-module-boundary-types\nfunction tryAcquire(sync, alreadyAcquiredError = E_ALREADY_LOCKED) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return withTimeout(sync, 0, alreadyAcquiredError);\n}\n\nexport { E_ALREADY_LOCKED, E_CANCELED, E_TIMEOUT, Mutex, Semaphore, tryAcquire, withTimeout };\n","import * as Ably from 'ably';\n\nimport { Logger } from './logger.js';\nimport { StatusSubscription } from './subscription.js';\nimport EventEmitter, { wrap } from './utils/event-emitter.js';\n\n/**\n * The different states that a room can be in throughout its lifecycle.\n */\nexport enum RoomStatus {\n  /**\n   * The library is currently initializing the room. This state is a temporary state used in React prior\n   * to the room being resolved.\n   */\n  Initializing = 'initializing',\n\n  /**\n   * A temporary state for when the room object is first initialized.\n   */\n  Initialized = 'initialized',\n\n  /**\n   * The library is currently attempting to attach the room.\n   */\n  Attaching = 'attaching',\n\n  /**\n   * The room is currently attached and receiving events.\n   */\n  Attached = 'attached',\n\n  /**\n   * The room is currently detaching and will not receive events.\n   */\n  Detaching = 'detaching',\n\n  /**\n   * The room is currently detached and will not receive events.\n   */\n  Detached = 'detached',\n\n  /**\n   * The room is in an extended state of detachment, but will attempt to re-attach when able.\n   */\n  Suspended = 'suspended',\n\n  /**\n   * The room is currently detached and will not attempt to re-attach. User intervention is required.\n   */\n  Failed = 'failed',\n\n  /**\n   * The room is in the process of releasing. Attempting to use a room in this state may result in undefined behavior.\n   */\n  Releasing = 'releasing',\n\n  /**\n   * The room has been released and is no longer usable.\n   */\n  Released = 'released',\n}\n\n/**\n * Represents a change in the status of the room.\n */\nexport interface RoomStatusChange {\n  /**\n   * The new status of the room.\n   */\n  current: RoomStatus;\n\n  /**\n   * The previous status of the room.\n   */\n  previous: RoomStatus;\n\n  /**\n   * An error that provides a reason why the room has\n   * entered the new status, if applicable.\n   */\n  error?: Ably.ErrorInfo;\n}\n\n/**\n * A function that can be called when the room status changes.\n * @param change The change in status.\n */\nexport type RoomStatusListener = (change: RoomStatusChange) => void;\n\n/**\n * Represents the status of a Room.\n */\nexport interface RoomLifecycle {\n  /**\n   * The current status of the room.\n   */\n  get status(): RoomStatus;\n\n  /**\n   * The current error, if any, that caused the room to enter the current status.\n   */\n  get error(): Ably.ErrorInfo | undefined;\n\n  /**\n   * Registers a listener that will be called whenever the room status changes.\n   * @param listener The function to call when the status changes.\n   * @returns An object that can be used to unregister the listener.\n   */\n  onChange(listener: RoomStatusListener): StatusSubscription;\n}\n\n/**\n * An internal interface for the status of a room, which can be used to separate critical\n * internal functionality from user listeners.\n * @internal\n */\nexport interface InternalRoomLifecycle extends RoomLifecycle {\n  /**\n   * Sets the status of the room.\n   *\n   * @param params The new status of the room.\n   */\n  setStatus(params: NewRoomStatus): void;\n}\n\n/**\n * A new room status that can be set.\n */\nexport interface NewRoomStatus {\n  /**\n   * The new status of the room.\n   */\n  status: RoomStatus;\n\n  /**\n   * An error that provides a reason why the room has\n   * entered the new status, if applicable.\n   */\n  error?: Ably.ErrorInfo;\n}\n\ntype RoomStatusEventsMap = Record<RoomStatus, RoomStatusChange>;\n\n/**\n * An implementation of the `Status` interface.\n * @internal\n */\nexport class DefaultRoomLifecycle implements InternalRoomLifecycle {\n  private _status: RoomStatus = RoomStatus.Initialized;\n  private _error?: Ably.ErrorInfo;\n  private readonly _logger: Logger;\n  private readonly _internalEmitter = new EventEmitter<RoomStatusEventsMap>();\n  private readonly _emitter = new EventEmitter<RoomStatusEventsMap>();\n\n  /**\n   * Constructs a new DefaultRoomLifecycle instance.\n   * @param logger An instance of the Logger.\n   */\n  constructor(logger: Logger) {\n    this._logger = logger;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get status(): RoomStatus {\n    return this._status;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get error(): Ably.ErrorInfo | undefined {\n    return this._error;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  onChange(listener: RoomStatusListener): StatusSubscription {\n    const wrapped = wrap(listener);\n    this._emitter.on(wrapped);\n\n    return {\n      off: () => {\n        this._emitter.off(wrapped);\n      },\n    };\n  }\n\n  setStatus(params: NewRoomStatus): void {\n    const change: RoomStatusChange = {\n      current: params.status,\n      error: params.error,\n      previous: this._status,\n    };\n\n    this._status = change.current;\n    this._error = change.error;\n    this._logger.info(`room status changed`, { ...change });\n    this._internalEmitter.emit(change.current, change);\n    this._emitter.emit(change.current, change);\n  }\n}\n","import * as Ably from 'ably';\nimport { Mutex } from 'async-mutex';\n\nimport { ChannelManager } from './channel-manager.js';\nimport { DiscontinuityListener } from './discontinuity.js';\nimport { ErrorCode } from './errors.js';\nimport { RoomEventType } from './events.js';\nimport { Logger } from './logger.js';\nimport { InternalRoomLifecycle, RoomStatus } from './room-status.js';\nimport { StatusSubscription } from './subscription.js';\nimport EventEmitter, { wrap } from './utils/event-emitter.js';\n\n/**\n * Events that can be emitted by the RoomLifecycleManager\n */\nexport interface RoomLifeCycleEvents {\n  [RoomEventType.Discontinuity]: Ably.ErrorInfo;\n}\n\n/**\n * Priority levels for operations, lower numbers are higher priority\n */\nenum OperationPriority {\n  Release = 0,\n  AttachDetach = 1,\n}\n\n/**\n * Manages the lifecycle of a room's underlying channel, handling attach, detach and release operations\n * while maintaining the room's status.\n */\nexport class RoomLifecycleManager {\n  private readonly _channelManager: ChannelManager;\n  private readonly _roomLifecycle: InternalRoomLifecycle;\n  private readonly _logger: Logger;\n  private readonly _eventEmitter: EventEmitter<RoomLifeCycleEvents>;\n  private _hasAttachedOnce: boolean; // CHA-RL13\n  private _isExplicitlyDetached: boolean; // CHA-RL14\n  private readonly _mutex: Mutex; // CHA-RL7\n\n  constructor(channelManager: ChannelManager, roomLifecycle: InternalRoomLifecycle, logger: Logger) {\n    this._channelManager = channelManager;\n    this._roomLifecycle = roomLifecycle;\n    this._logger = logger;\n    this._eventEmitter = new EventEmitter();\n    this._hasAttachedOnce = false; // CHA-RL13\n    this._isExplicitlyDetached = false; // CHA-RL14\n    this._mutex = new Mutex(); // CHA-RL7\n\n    // Start monitoring channel state changes\n    this._startMonitoringChannelState();\n    this._startMonitoringDiscontinuity();\n  }\n\n  /**\n   * Sets up monitoring of channel state changes to keep room status in sync.\n   * If an operation is in progress (attach/detach/release), state changes are ignored.\n   * @private\n   */\n  private _startMonitoringChannelState(): void {\n    const channel = this._channelManager.get();\n\n    // CHA-RL11a\n    channel.on((stateChange: Ably.ChannelStateChange) => {\n      this._logger.debug('RoomLifecycleManager.channel state changed', {\n        oldState: stateChange.previous,\n        newState: stateChange.current,\n        reason: stateChange.reason,\n        resumed: stateChange.resumed,\n      });\n\n      // CHA-RL11b\n      if (this._operationInProgress()) {\n        this._logger.debug(\n          'RoomLifecycleManager._startMonitoringChannelState(); ignoring channel state change - operation in progress',\n          {\n            status: this._roomLifecycle.status,\n          },\n        );\n        return;\n      }\n\n      // CHA-RL11c\n      const newStatus = this._mapChannelStateToRoomStatus(stateChange.current);\n      this._setStatus(newStatus, stateChange.reason);\n    });\n  }\n\n  /**\n   * Sets up monitoring for channel discontinuities.\n   * A discontinuity exists when an attached or update event comes from the channel with resume=false.\n   * The first time we attach, or if we attach after an explicit detach call are not considered discontinuities.\n   * @private\n   */\n  private _startMonitoringDiscontinuity(): void {\n    const channel = this._channelManager.get();\n\n    // CHA-RL12a, CHA-RL12b\n    channel.on('attached', (stateChange: Ably.ChannelStateChange) => {\n      if (!stateChange.resumed && this._hasAttachedOnce && !this._isExplicitlyDetached) {\n        const error = new Ably.ErrorInfo(\n          'discontinuity detected',\n          ErrorCode.RoomDiscontinuity,\n          stateChange.reason?.statusCode ?? 0,\n          stateChange.reason,\n        );\n\n        this._logger.warn('RoomLifecycleManager._startMonitoringDiscontinuity(); discontinuity detected', {\n          error,\n        });\n        this._eventEmitter.emit(RoomEventType.Discontinuity, error);\n      }\n    });\n\n    // CHA-RL12a, CHA-RL12b\n    channel.on('update', (stateChange: Ably.ChannelStateChange) => {\n      if (\n        !stateChange.resumed &&\n        this._hasAttachedOnce &&\n        !this._isExplicitlyDetached &&\n        stateChange.current === 'attached' &&\n        stateChange.previous === 'attached'\n      ) {\n        const error = new Ably.ErrorInfo(\n          'discontinuity detected',\n          ErrorCode.RoomDiscontinuity,\n          stateChange.reason?.statusCode ?? 0,\n          stateChange.reason,\n        );\n\n        this._logger.warn('RoomLifecycleManager._startMonitoringDiscontinuity(); discontinuity detected', {\n          error,\n        });\n        this._eventEmitter.emit(RoomEventType.Discontinuity, error);\n      }\n    });\n  }\n\n  /**\n   * Registers a handler for discontinuity events.\n   * @param handler The function to be called when a discontinuity is detected\n   * @returns An object with an off() method to deregister the handler\n   */\n  onDiscontinuity(handler: DiscontinuityListener): StatusSubscription {\n    this._logger.trace('RoomLifecycleManager.onDiscontinuity()');\n    const wrapped = wrap(handler);\n    this._eventEmitter.on(RoomEventType.Discontinuity, wrapped);\n    return {\n      off: () => {\n        this._eventEmitter.off(RoomEventType.Discontinuity, wrapped);\n      },\n    };\n  }\n\n  /**\n   * Attaches to the channel and updates room status accordingly.\n   * If the room is released/releasing, this operation fails.\n   * If already attached, this is a no-op.\n   */\n  async attach(): Promise<void> {\n    // CHA-RL1d, CHA-RL7a\n    await this._mutex.runExclusive(async () => {\n      this._logger.trace('RoomLifecycleManager.attach();');\n\n      // CHA-RL1b, CHA-RL1c\n      this._checkRoomNotReleasing('attach');\n\n      // CHA-RL1a\n      if (this._roomStatusIs(RoomStatus.Attached)) {\n        this._logger.debug('RoomLifecycleManager.attach(); room already attached, no-op');\n        return;\n      }\n\n      const channel = this._channelManager.get();\n      this._logger.debug('RoomLifecycleManager.attach(); attaching room', {\n        channelState: channel.state,\n      });\n\n      try {\n        // CHA-RL1e\n        this._setStatus(RoomStatus.Attaching);\n        // CHA-RL1k\n        await channel.attach();\n        this._setStatus(RoomStatus.Attached);\n        this._isExplicitlyDetached = false;\n        this._hasAttachedOnce = true;\n        this._logger.debug('RoomLifecycleManager.attach(); room attached successfully');\n      } catch (error) {\n        const errInfo = error as Ably.ErrorInfo;\n        const attachError = new Ably.ErrorInfo(\n          `failed to attach room: ${errInfo.message}`,\n          errInfo.code,\n          errInfo.statusCode,\n          errInfo,\n        );\n\n        const newStatus = this._mapChannelStateToRoomStatus(channel.state);\n        this._setStatus(newStatus, attachError);\n        throw attachError;\n      }\n    }, OperationPriority.AttachDetach);\n  }\n\n  /**\n   * Detaches from the channel and updates room status accordingly.\n   * If the room is released/releasing, this operation fails.\n   * If already detached, this is a no-op.\n   */\n  async detach(): Promise<void> {\n    // CHA-RL2i, CHA-RL7a\n    await this._mutex.runExclusive(async () => {\n      this._logger.trace('RoomLifecycleManager.detach();');\n\n      // CHA-RL2d\n      if (this._roomStatusIs(RoomStatus.Failed)) {\n        throw new Ably.ErrorInfo('cannot detach room, room is in failed state', ErrorCode.RoomInFailedState, 400);\n      }\n\n      // CHA-RL2b, CHA-RL2c\n      this._checkRoomNotReleasing('detach');\n\n      // CHA-RL2a\n      if (this._roomStatusIs(RoomStatus.Detached)) {\n        this._logger.debug('RoomLifecycleManager.detach(); room already detached, no-op');\n        return;\n      }\n\n      const channel = this._channelManager.get();\n      this._logger.debug('RoomLifecycleManager.detach(); detaching room', {\n        channelState: channel.state,\n      });\n\n      try {\n        // CHA-RL2j\n        this._setStatus(RoomStatus.Detaching);\n        // CHA-RL2k\n        await channel.detach();\n        this._isExplicitlyDetached = true;\n        this._setStatus(RoomStatus.Detached);\n        this._logger.debug('RoomLifecycleManager.detach(); room detached successfully');\n      } catch (error) {\n        const errInfo = error as Ably.ErrorInfo;\n        const detachError = new Ably.ErrorInfo(\n          `failed to detach room: ${errInfo.message}`,\n          errInfo.code,\n          errInfo.statusCode,\n          errInfo,\n        );\n\n        const newStatus = this._mapChannelStateToRoomStatus(channel.state);\n        this._setStatus(newStatus, detachError);\n        throw detachError;\n      }\n    }, OperationPriority.AttachDetach);\n  }\n\n  /**\n   * Releases the room by detaching the channel and releasing it from the channel manager.\n   * If the channel is in a failed state, skips the detach operation.\n   * Will retry detach until successful unless in failed state.\n   */\n  async release(): Promise<void> {\n    // CHA-RL3k, CHA-RL7a\n    await this._mutex.runExclusive(async () => {\n      this._logger.trace('RoomLifecycleManager.release();');\n\n      // CHA-RL3a\n      if (this._roomStatusIs(RoomStatus.Released)) {\n        this._logger.debug('RoomLifecycleManager.release(); room already released, no-op');\n        return;\n      }\n\n      // CHA-RL3b, CHA-RL3j\n      if (this._roomStatusIs(RoomStatus.Initialized) || this._roomStatusIs(RoomStatus.Detached)) {\n        this._logger.debug('RoomLifecycleManager.release(); room is initialized or detached, releasing immediately', {\n          status: this._roomLifecycle.status,\n        });\n        this._releaseChannel();\n        return;\n      }\n\n      // CHA-RL3m\n      this._setStatus(RoomStatus.Releasing);\n      const channel = this._channelManager.get();\n\n      // CHA-RL3n\n      this._logger.debug('RoomLifecycleManager.release(); attempting channel detach before release', {\n        channelState: channel.state,\n      });\n      await this._channelDetachLoop(channel);\n\n      // CHA-RL3o, CHA-RL3h\n      this._releaseChannel();\n    }, OperationPriority.Release);\n  }\n\n  /**\n   * Maps an Ably channel state to a room status\n   */\n  private _mapChannelStateToRoomStatus(channelState: Ably.ChannelState): RoomStatus {\n    switch (channelState) {\n      case 'initialized': {\n        return RoomStatus.Initialized;\n      }\n      case 'attaching': {\n        return RoomStatus.Attaching;\n      }\n      case 'attached': {\n        return RoomStatus.Attached;\n      }\n      case 'detaching': {\n        return RoomStatus.Detaching;\n      }\n      case 'detached': {\n        return RoomStatus.Detached;\n      }\n      case 'suspended': {\n        return RoomStatus.Suspended;\n      }\n      case 'failed': {\n        return RoomStatus.Failed;\n      }\n      default: {\n        this._logger.error('RoomLifecycleManager._mapChannelStateToRoomStatus(); unknown channel state', {\n          channelState,\n        });\n        return RoomStatus.Failed;\n      }\n    }\n  }\n\n  private _checkRoomNotReleasing(op: string) {\n    switch (this._roomLifecycle.status) {\n      case RoomStatus.Released: {\n        throw new Ably.ErrorInfo(`cannot ${op} room, room is released`, ErrorCode.RoomIsReleased, 400);\n      }\n      case RoomStatus.Releasing: {\n        throw new Ably.ErrorInfo(`cannot ${op} room, room is currently releasing`, ErrorCode.RoomIsReleasing, 400);\n      }\n    }\n  }\n\n  private _roomStatusIs(status: RoomStatus) {\n    return this._roomLifecycle.status === status;\n  }\n\n  private async _channelDetachLoop(channel: Ably.RealtimeChannel) {\n    for (;;) {\n      // If channel is now failed, we can stop trying to detach\n      const currentState: Ably.ChannelState = channel.state;\n      if (currentState === 'failed') {\n        this._logger.debug('RoomLifecycleManager._channelDetachLoop(); channel is failed, skipping detach');\n        break;\n      }\n\n      try {\n        await channel.detach();\n        break;\n      } catch (error) {\n        // keep trying\n        this._logger.error('RoomLifecycleManager._channelDetachLoop(); failed to detach channel during release', {\n          error,\n        });\n        await new Promise((resolve) => setTimeout(resolve, 250)); // Wait 250ms before retry\n      }\n    }\n  }\n\n  private _setStatus(status: RoomStatus, error?: Ably.ErrorInfo) {\n    this._logger.debug('RoomLifecycleManager._setStatus(); updating room status', {\n      oldStatus: this._roomLifecycle.status,\n      newStatus: status,\n      hasError: !!error,\n    });\n    this._roomLifecycle.setStatus({ status, error });\n  }\n\n  private _releaseChannel() {\n    this._channelManager.release();\n    this._setStatus(RoomStatus.Released);\n    this._logger.debug('RoomLifecycleManager._releaseChannel(); room released successfully');\n  }\n\n  /**\n   * Returns whether there is currently an operation (attach/detach/release) in progress\n   * @private\n   */\n  private _operationInProgress(): boolean {\n    return this._mutex.isLocked();\n  }\n\n  testForceHasAttachedOnce(firstAttach: boolean) {\n    this._hasAttachedOnce = firstAttach;\n  }\n}\n","import * as Ably from 'ably';\n\nimport { MessageReactionType } from './events.js';\n\n/**\n * The default values for RoomOptions.\n */\nconst DefaultRoomOptions: Omit<InternalRoomOptions, 'isReactClient'> = {\n  /**\n   * The default typing options for a chat room.\n   */\n  typing: {\n    /**\n     * The default time that a client will wait between sending one typing heartbeat and the next.\n     *\n     * Spec: CHA-T10.\n     */\n    heartbeatThrottleMs: 10000,\n  },\n\n  /**\n   * The default occupancy options for a chat room.\n   */\n  occupancy: {\n    /**\n     * Whether to enable occupancy events.\n     */\n    enableEvents: false,\n  },\n\n  /**\n   * The default presence options for the room.\n   */\n  presence: {\n    enableEvents: true,\n  },\n\n  /**\n   * The default options for messages.\n   */\n  messages: {\n    rawMessageReactions: false,\n    defaultMessageReactionType: MessageReactionType.Distinct,\n  },\n};\n\n/**\n * Represents the message options for a chat room.\n */\nexport interface MessageOptions {\n  /**\n   * Whether to enable receiving raw individual message reactions from the\n   * realtime channel. Set to true if subscribing to raw message reactions.\n   *\n   * Note reaction summaries (aggregates) are always available regardless of\n   * this setting.\n   *\n   * @defaultValue false\n   */\n  rawMessageReactions?: boolean;\n\n  /**\n   * The default message reaction type to use for sending message reactions.\n   *\n   * Any message reaction type can be sent regardless of this setting by specifying the `type` parameter\n   * in the {@link MessagesReactions.send} method.\n   *\n   * @defaultValue {@link MessageReactionType.Distinct}\n   */\n  defaultMessageReactionType?: MessageReactionType;\n}\n\n/**\n * Represents the typing options for a chat room.\n */\nexport interface TypingOptions {\n  /**\n   * A throttle, in milliseconds, that enforces the minimum time interval between consecutive `typing.started`\n   * events sent by the client to the server.\n   * If typing.start() is called, the first call will emit an event immediately.\n   * Later calls will no-op until the time has elapsed.\n   * Calling typing.stop() will immediately send a `typing.stopped` event to the server and reset the interval,\n   * allowing the client to send another `typing.started` event immediately.\n   * @defaultValue 10000\n   */\n  heartbeatThrottleMs?: number;\n}\n\n/**\n * Represents the occupancy options for a chat room.\n */\nexport interface OccupancyOptions {\n  /**\n   * Whether to enable occupancy events.\n   *\n   * Note that enabling this feature will increase the number of messages received by the client as additional\n   * messages will be sent by the server to indicate occupancy changes.\n   *\n   * @defaultValue false\n   */\n  enableEvents?: boolean;\n}\n\n/**\n * Represents the presence options for a chat room.\n */\nexport interface PresenceOptions {\n  /**\n   * Whether or not the client should receive presence events from the server. This setting\n   * can be disabled if you are using presence in your Chat Room, but this particular client does not\n   * need to receive the messages.\n   *\n   * @defaultValue true\n   */\n  enableEvents?: boolean;\n}\n\n/**\n * Represents the options for a given chat room.\n */\nexport interface RoomOptions {\n  /**\n   * The typing options for the room.\n   */\n  typing?: TypingOptions;\n\n  /**\n   * The occupancy options for the room.\n   */\n  occupancy?: OccupancyOptions;\n\n  /**\n   * The presence options for the room.\n   */\n  presence?: PresenceOptions;\n\n  /**\n   * The message options for the room.\n   */\n  messages?: MessageOptions;\n}\n\n/**\n * Represents the normalized typing options for a chat room, which makes every property required.\n */\nexport type InternalTypingOptions = Required<TypingOptions>;\n\n/**\n * Represents the normalized occupancy options for a chat room. Everything becomes required.\n */\nexport type InternalOccupancyOptions = Required<OccupancyOptions>;\n\n/**\n * Represents the normalized presence options for a chat room. Everything becomes required.\n */\nexport type InternalPresenceOptions = Required<PresenceOptions>;\n\n/**\n * Represents the normalized message options for a chat room. Everything becomes required.\n */\nexport type InternalMessageOptions = Required<MessageOptions>;\n\n/**\n * Represents the normalized options for a chat room.\n */\nexport interface InternalRoomOptions {\n  /**\n   * Are we running the client in a React environment?\n   */\n  isReactClient: boolean;\n\n  /**\n   * Typing options with everything made mandatory.\n   */\n  typing: InternalTypingOptions;\n\n  /**\n   * Occupancy options with everything made mandatory.\n   */\n  occupancy: InternalOccupancyOptions;\n\n  /**\n   * Presence options with everything made mandatory.\n   */\n  presence: InternalPresenceOptions;\n\n  /**\n   * Message options with everything made mandatory.\n   */\n  messages: InternalMessageOptions;\n}\n\n/**\n * Creates an {@link ErrorInfo} for invalid room configuration.\n *\n * @param reason The reason for the invalid room configuration.\n * @returns An ErrorInfo.\n */\nconst invalidRoomConfiguration = (reason: string): Error =>\n  new Ably.ErrorInfo(`invalid room configuration: ${reason}`, 40001, 400);\n\nexport const validateRoomOptions = (options: InternalRoomOptions): void => {\n  validateTypingOptions(options.typing);\n};\n\nconst validateTypingOptions = (options: InternalTypingOptions): void => {\n  if (options.heartbeatThrottleMs <= 0) {\n    throw invalidRoomConfiguration('typing heartbeat interval must be greater than 0');\n  }\n};\n\nconst normalizeTypingOptions = (options: RoomOptions | undefined): InternalTypingOptions => {\n  return {\n    ...DefaultRoomOptions.typing,\n    ...options?.typing,\n  };\n};\n\nconst normalizeOccupancyOptions = (options: RoomOptions | undefined): InternalOccupancyOptions => {\n  return {\n    ...DefaultRoomOptions.occupancy,\n    ...options?.occupancy,\n  };\n};\n\nconst normalizePresenceOptions = (options: RoomOptions | undefined): InternalPresenceOptions => {\n  return {\n    ...DefaultRoomOptions.presence,\n    ...options?.presence,\n  };\n};\n\nconst normalizeMessageOptions = (options: RoomOptions | undefined): InternalMessageOptions => {\n  return {\n    ...DefaultRoomOptions.messages,\n    ...options?.messages,\n  };\n};\n\nexport const normalizeRoomOptions = (options: RoomOptions | undefined, react: boolean): InternalRoomOptions => {\n  return {\n    typing: normalizeTypingOptions(options),\n    occupancy: normalizeOccupancyOptions(options),\n    presence: normalizePresenceOptions(options),\n    messages: normalizeMessageOptions(options),\n    isReactClient: react,\n  };\n};\n","import * as Ably from 'ably';\n\n/**\n * Convenience function that takes an event name and optional data and turns it into a\n * message that the server will recognize as ephemeral.\n *\n * @param name The name of the event.\n * @param data Optional data to send with the event.\n * @returns An Ably message.\n */\nexport const ephemeralMessage = (name: string, data?: unknown): Ably.Message => {\n  return {\n    name: name,\n    data: data,\n    extras: {\n      ephemeral: true,\n    },\n  };\n};\n\n/**\n * Takes an existing Ably message and converts it to an ephemeral message by adding\n * the ephemeral flag in the extras field.\n *\n * @param message The Ably message to convert.\n * @returns A new Ably message with the ephemeral flag set.\n */\nexport const messageToEphemeral = (message: Ably.Message): Ably.Message => {\n  const extras = message.extras ? (message.extras as object) : {};\n\n  return {\n    ...message,\n    extras: {\n      ...extras,\n      ephemeral: true,\n    },\n  };\n};\n","import { Headers } from './headers.js';\nimport { Metadata } from './metadata.js';\n\n/**\n * {@link Headers} type for chat messages.\n */\nexport type RoomReactionHeaders = Headers;\n\n/**\n * {@link Metadata} type for chat messages.\n */\nexport type RoomReactionMetadata = Metadata;\n\n/**\n * Represents a room-level reaction.\n */\nexport interface RoomReaction {\n  /**\n   * The name of the reaction, for example \"like\" or \"love\".\n   */\n  readonly name: string;\n\n  /**\n   * Metadata of the reaction. If no metadata was set this is an empty object.\n   */\n  readonly metadata: RoomReactionMetadata;\n\n  /**\n   * Headers of the reaction. If no headers were set this is an empty object.\n   */\n  readonly headers: RoomReactionHeaders;\n\n  /**\n   * The timestamp at which the reaction was sent.\n   */\n  readonly createdAt: Date;\n\n  /**\n   * The clientId of the user who sent the reaction.\n   */\n  readonly clientId: string;\n\n  /**\n   * Whether the reaction was sent by the current user.\n   */\n  readonly isSelf: boolean;\n}\n\n/**\n * An implementation of the RoomReaction interface for room-level reactions.\n */\nexport class DefaultRoomReaction implements RoomReaction {\n  constructor(\n    public readonly name: string,\n    public readonly clientId: string,\n    public readonly createdAt: Date,\n    public readonly isSelf: boolean,\n    public readonly metadata: RoomReactionMetadata,\n    public readonly headers: RoomReactionHeaders,\n  ) {\n    // The object is frozen after constructing to enforce readonly at runtime too\n    Object.freeze(this);\n  }\n}\n","import * as Ably from 'ably';\n\nimport { DefaultRoomReaction, RoomReaction, RoomReactionHeaders, RoomReactionMetadata } from './room-reaction.js';\n\ninterface ReactionPayload {\n  data?: {\n    name?: string;\n    metadata?: RoomReactionMetadata;\n  };\n  clientId?: string;\n  timestamp: number;\n  extras?: {\n    headers?: RoomReactionHeaders;\n  };\n}\n\nexport function parseRoomReaction(message: Ably.InboundMessage, clientId?: string): RoomReaction {\n  const reactionCreatedMessage = message as ReactionPayload;\n  if (!reactionCreatedMessage.data) {\n    throw new Ably.ErrorInfo(`received incoming room reaction message without data`, 50000, 500);\n  }\n\n  if (!reactionCreatedMessage.data.name || typeof reactionCreatedMessage.data.name !== 'string') {\n    throw new Ably.ErrorInfo('invalid room reaction message with no name', 50000, 500);\n  }\n\n  if (!reactionCreatedMessage.clientId) {\n    throw new Ably.ErrorInfo(`received incoming room reaction message without clientId`, 50000, 500);\n  }\n\n  if (!reactionCreatedMessage.timestamp) {\n    throw new Ably.ErrorInfo(`received incoming room reaction message without timestamp`, 50000, 500);\n  }\n\n  return new DefaultRoomReaction(\n    reactionCreatedMessage.data.name,\n    reactionCreatedMessage.clientId,\n    new Date(reactionCreatedMessage.timestamp),\n    clientId ? clientId === reactionCreatedMessage.clientId : false,\n    reactionCreatedMessage.data.metadata ?? {},\n    reactionCreatedMessage.extras?.headers ?? {},\n  );\n}\n","import * as Ably from 'ably';\n\nimport { RoomReactionEvent, RoomReactionEventType, RoomReactionRealtimeEventType } from './events.js';\nimport { Logger } from './logger.js';\nimport { messageToEphemeral } from './realtime.js';\nimport { RoomReaction, RoomReactionHeaders, RoomReactionMetadata } from './room-reaction.js';\nimport { parseRoomReaction } from './room-reaction-parser.js';\nimport { Subscription } from './subscription.js';\nimport EventEmitter, { wrap } from './utils/event-emitter.js';\n\n/**\n * Params for sending a room-level reactions. Only `name` is mandatory.\n */\nexport interface SendReactionParams {\n  /**\n   * The name of the reaction, for example an emoji or a short string such as\n   * \"like\".\n   *\n   * It is the only mandatory parameter to send a room-level reaction.\n   */\n  name: string;\n\n  /**\n   * Optional metadata of the reaction.\n   *\n   * The metadata is a map of extra information that can be attached to the\n   * room reaction. It is not used by Ably and is sent as part of the realtime\n   * message payload. Example use cases are custom animations or other effects.\n   *\n   * Do not use metadata for authoritative information. There is no server-side\n   * validation. When reading the metadata treat it like user input.\n   *\n   */\n  metadata?: RoomReactionMetadata;\n\n  /**\n   * Optional headers of the room reaction.\n   *\n   * The headers are a flat key-value map and are sent as part of the realtime\n   * message's `extras` inside the `headers` property. They can serve similar\n   * purposes as the metadata but they are read by Ably and can be used for\n   * features such as\n   * [subscription filters](https://faqs.ably.com/subscription-filters).\n   *\n   * Do not use the headers for authoritative information. There is no\n   * server-side validation. When reading the headers treat them like user\n   * input.\n   *\n   */\n  headers?: RoomReactionHeaders;\n}\n\n/**\n * The listener function type for room-level reactions.\n *\n * @param event The reaction event that was received.\n */\nexport type RoomReactionListener = (event: RoomReactionEvent) => void;\n\n/**\n * This interface is used to interact with room-level reactions in a chat room: subscribing to reactions and sending them.\n *\n * Get an instance via {@link Room.reactions}.\n */\nexport interface RoomReactions {\n  /**\n   * Send a reaction to the room including some metadata.\n   *\n   * This method accepts parameters for a room-level reaction. It accepts an object\n   *\n   * @param params an object containing {name, headers, metadata} for the room\n   * reaction to be sent. Name is required, metadata and headers are optional.\n   * @throws If the `Connection` is not in the `Connected` state.\n   * @returns The returned promise resolves when the reaction was sent. Note\n   * that it is possible to receive your own reaction via the reactions\n   * listener before this promise resolves.\n   */\n  send(params: SendReactionParams): Promise<void>;\n\n  /**\n   * Subscribe to receive room-level reactions.\n   *\n   * @param listener The listener function to be called when a reaction is received.\n   * @returns A response object that allows you to control the subscription.\n   */\n  subscribe(listener: RoomReactionListener): Subscription;\n}\n\ninterface RoomReactionEventsMap {\n  [RoomReactionEventType.Reaction]: RoomReactionEvent;\n}\n\ninterface ReactionPayload {\n  name: string;\n  metadata?: RoomReactionMetadata;\n}\n\n/**\n * @inheritDoc\n */\nexport class DefaultRoomReactions implements RoomReactions {\n  private readonly _channel: Ably.RealtimeChannel;\n  private readonly _connection: Ably.Connection;\n  private readonly _clientId: string;\n  private readonly _logger: Logger;\n  private readonly _emitter = new EventEmitter<RoomReactionEventsMap>();\n\n  /**\n   * Constructs a new `DefaultRoomReactions` instance.\n   * @param channel The Realtime channel instance.\n   * @param connection The connection instance.\n   * @param clientId The client ID of the user.\n   * @param logger An instance of the Logger.\n   */\n  constructor(channel: Ably.RealtimeChannel, connection: Ably.Connection, clientId: string, logger: Logger) {\n    this._channel = channel;\n    this._connection = connection;\n    this._clientId = clientId;\n    this._logger = logger;\n\n    this._applyChannelSubscriptions();\n  }\n\n  /**\n   * Sets up channel subscriptions for room reactions.\n   */\n  private _applyChannelSubscriptions(): void {\n    // attachOnSubscribe is set to false in the default channel options, so this call cannot fail\n    void this._channel.subscribe([RoomReactionRealtimeEventType.Reaction], this._forwarder.bind(this));\n  }\n\n  /**\n   * @inheritDoc Reactions\n   */\n  send(params: SendReactionParams): Promise<void> {\n    this._logger.trace('RoomReactions.send();', params);\n\n    const { name, metadata, headers } = params;\n\n    if (!name) {\n      return Promise.reject(new Ably.ErrorInfo('unable to send reaction; name not set and it is required', 40001, 400));\n    }\n\n    // CHA-ER3f\n    if (this._connection.state !== 'connected') {\n      return Promise.reject(new Ably.ErrorInfo('unable to send reaction; not connected to Ably', 40000, 400));\n    }\n\n    const payload: ReactionPayload = {\n      name: name,\n      metadata: metadata ?? {},\n    };\n\n    const realtimeMessage: Ably.Message = {\n      name: RoomReactionRealtimeEventType.Reaction,\n      data: payload,\n      extras: {\n        headers: headers ?? {},\n      },\n    };\n\n    return this._channel.publish(messageToEphemeral(realtimeMessage));\n  }\n\n  /**\n   * @inheritDoc Reactions\n   */\n  subscribe(listener: RoomReactionListener): Subscription {\n    this._logger.trace(`RoomReactions.subscribe();`);\n    const wrapped = wrap(listener);\n    this._emitter.on(wrapped);\n\n    return {\n      unsubscribe: () => {\n        this._logger.trace('RoomReactions.unsubscribe();');\n        this._emitter.off(wrapped);\n      },\n    };\n  }\n\n  // parses reactions from realtime channel into Reaction objects and forwards them to the EventEmitter\n  private _forwarder = (inbound: Ably.InboundMessage) => {\n    const reaction = this._parseNewReaction(inbound, this._clientId);\n    if (!reaction) {\n      // ignore non-reactions\n      return;\n    }\n    this._emitter.emit(RoomReactionEventType.Reaction, {\n      type: RoomReactionEventType.Reaction,\n      reaction,\n    });\n  };\n\n  private _parseNewReaction(inbound: Ably.InboundMessage, clientId: string): RoomReaction | undefined {\n    try {\n      return parseRoomReaction(inbound, clientId);\n    } catch (error: unknown) {\n      this._logger.error(`failed to parse incoming reaction;`, {\n        inbound,\n        error: error as Ably.ErrorInfo,\n      });\n    }\n  }\n}\n","import * as Ably from 'ably';\nimport { E_CANCELED, Mutex } from 'async-mutex';\n\nimport { TypingEventType, TypingSetEvent, TypingSetEventType } from './events.js';\nimport { Logger } from './logger.js';\nimport { ephemeralMessage } from './realtime.js';\nimport { InternalTypingOptions } from './room-options.js';\nimport { Subscription } from './subscription.js';\nimport EventEmitter, { wrap } from './utils/event-emitter.js';\n\n/**\n * This interface is used to interact with typing in a chat room including subscribing to typing events and\n * fetching the current set of typing clients.\n *\n * Get an instance via {@link Room.typing}.\n */\nexport interface Typing {\n  /**\n   * Subscribe a given listener to all typing events from users in the chat room.\n   *\n   * @param listener A listener to be called when the typing state of a user in the room changes.\n   * @returns A response object that allows you to control the subscription to typing events.\n   */\n  subscribe(listener: TypingListener): Subscription;\n\n  /**\n   * Get the current typers, a set of clientIds.\n   * @returns The set of clientIds that are currently typing.\n   */\n  current(): Set<string>;\n\n  /**\n   * This will send a `typing.started` event to the server.\n   * Events are throttled according to the `heartbeatThrottleMs` room option.\n   * If an event has been sent within the interval, this operation is no-op.\n   *\n   *\n   * Calls to `keystroke()` and `stop()` are serialized and will always resolve in the correct order.\n   * - For example, if multiple `keystroke()` calls are made in quick succession before the first `keystroke()` call has\n   *   sent a `typing.started` event to the server, followed by one `stop()` call, the `stop()` call will execute\n   *   as soon as the first `keystroke()` call completes.\n   *   All intermediate `keystroke()` calls will be treated as no-ops.\n   * - The most recent operation (`keystroke()` or `stop()`) will always determine the final state, ensuring operations\n   *   resolve to a consistent and correct state.\n   *\n   * @returns A promise which resolves upon success of the operation and rejects with an {@link Ably.ErrorInfo} object upon its failure.\n   * @throws If the `Connection` is not in the `Connected` state.\n   * @throws If the operation fails to send the event to the server.\n   * @throws If there is a problem acquiring the mutex that controls serialization.\n   */\n  keystroke(): Promise<void>;\n\n  /**\n   * This will send a `typing.stopped` event to the server.\n   * If the user was not currently typing, this operation is no-op.\n   *\n   * Calls to `keystroke()` and `stop()` are serialized and will always resolve in the correct order.\n   * - For example, if multiple `keystroke()` calls are made in quick succession before the first `keystroke()` call has\n   *   sent a `typing.started` event to the server, followed by one `stop()` call, the `stop()` call will execute\n   *   as soon as the first `keystroke()` call completes.\n   *   All intermediate `keystroke()` calls will be treated as no-ops.\n   * - The most recent operation (`keystroke()` or `stop()`) will always determine the final state, ensuring operations\n   *   resolve to a consistent and correct state.\n   *\n   * @returns A promise which resolves upon success of the operation and rejects with an {@link Ably.ErrorInfo} object upon its failure.\n   * @throws If the `Connection` is not in the `Connected` state.\n   * @throws If the operation fails to send the event to the server.\n   * @throws If there is a problem acquiring the mutex that controls serialization.\n   */\n  stop(): Promise<void>;\n}\n\n/**\n * A listener which listens for typing events.\n * @param event The typing event.\n */\nexport type TypingListener = (event: TypingSetEvent) => void;\n\n/**\n * Represents the typing events mapped to their respective event payloads.\n */\ninterface TypingEventsMap {\n  [TypingSetEventType.SetChanged]: TypingSetEvent;\n}\n\n/**\n * Represents a timer handle that can be undefined.\n */\ntype TypingTimerHandle = ReturnType<typeof setTimeout> | undefined;\n\n/**\n * @inheritDoc\n */\nexport class DefaultTyping extends EventEmitter<TypingEventsMap> implements Typing {\n  private readonly _clientId: string;\n  private readonly _channel: Ably.RealtimeChannel;\n  private readonly _connection: Ably.Connection;\n  private readonly _logger: Logger;\n\n  // Throttle for the heartbeat, how often we should emit a typing event with repeated calls to keystroke()\n  // CHA-T10\n  private readonly _heartbeatThrottleMs: number;\n\n  // Grace period for inactivity before another user is considered to have stopped typing\n  // CHA-T10a\n  private readonly _timeoutMs = 2000;\n  private _heartbeatTimerId: TypingTimerHandle;\n  private readonly _currentlyTyping: Map<string, TypingTimerHandle>;\n\n  // Mutex for controlling `keystroke` and `stop` operations\n  private readonly _mutex = new Mutex();\n\n  /**\n   * Constructs a new `DefaultTyping` instance.\n   * @param options The options for typing in the room.\n   * @param connection The connection instance.\n   * @param channel The channel for the room.\n   * @param clientId The client ID of the user.\n   * @param logger An instance of the Logger.\n   */\n  constructor(\n    options: InternalTypingOptions,\n    connection: Ably.Connection,\n    channel: Ably.RealtimeChannel,\n    clientId: string,\n    logger: Logger,\n  ) {\n    super();\n    this._clientId = clientId;\n    this._channel = channel;\n    this._connection = connection;\n\n    // Interval for the heartbeat, how often we should emit a typing event with repeated calls to start()\n    this._heartbeatThrottleMs = options.heartbeatThrottleMs;\n\n    // Map of clientIds to their typing timers, used to track typing state\n    this._currentlyTyping = new Map<string, TypingTimerHandle>();\n    this._logger = logger;\n\n    this._applyChannelSubscriptions();\n  }\n\n  /**\n   * Sets up channel subscriptions for typing indicators.\n   */\n  private _applyChannelSubscriptions(): void {\n    // CHA-T8\n    // attachOnSubscribe is set to false in the default channel options, so this call cannot fail\n    void this._channel.subscribe(\n      [TypingEventType.Start, TypingEventType.Stop],\n      this._internalSubscribeToEvents.bind(this),\n    );\n  }\n\n  /**\n   * Clears all typing states.\n   * This includes clearing all timeouts and the currently typing map.\n   * @private\n   */\n  private _clearAllTypingStates(): void {\n    this._logger.debug(`DefaultTyping._clearAllTypingStates(); clearing all typing states`);\n    this._clearHeartbeatTimer();\n    this._clearCurrentlyTyping();\n  }\n\n  /**\n   * Clears the heartbeat timer.\n   * @private\n   */\n  private _clearHeartbeatTimer(): void {\n    this._logger.trace(`DefaultTyping._clearHeartbeatTimer(); clearing heartbeat timer`);\n    if (this._heartbeatTimerId) {\n      clearTimeout(this._heartbeatTimerId);\n      this._heartbeatTimerId = undefined;\n    }\n  }\n\n  /**\n   * Clears the currently typing store and removes all timeouts for associated clients.\n   * @private\n   */\n  private _clearCurrentlyTyping(): void {\n    this._logger.trace('DefaultTyping._clearCurrentlyTyping(); clearing current store and timeouts');\n    // Clear all client typing timeouts\n    for (const [, timeoutId] of this._currentlyTyping.entries()) {\n      clearTimeout(timeoutId);\n    }\n    // Clear the currently typing map\n    this._currentlyTyping.clear();\n  }\n\n  /**\n   * CHA-T16\n   *\n   * @inheritDoc\n   */\n  current(): Set<string> {\n    this._logger.trace(`DefaultTyping.current();`);\n    return new Set<string>(this._currentlyTyping.keys());\n  }\n\n  /**\n   * @inheritDoc\n   */\n  get channel(): Ably.RealtimeChannel {\n    return this._channel;\n  }\n\n  /**\n   * Start the heartbeat timer. This will expire after the configured interval.\n   */\n  private _startHeartbeatTimer(): void {\n    if (!this._heartbeatTimerId) {\n      this._logger.trace(`DefaultTyping.startHeartbeatTimer();`);\n      const timer = (this._heartbeatTimerId = setTimeout(() => {\n        this._logger.debug(`DefaultTyping.startHeartbeatTimer(); heartbeat timer expired`);\n        // CHA-T2a\n        if (timer === this._heartbeatTimerId) {\n          this._heartbeatTimerId = undefined;\n        }\n      }, this._heartbeatThrottleMs));\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  async keystroke(): Promise<void> {\n    this._logger.trace(`DefaultTyping.keystroke();`);\n    this._mutex.cancel();\n\n    // Acquire a mutex\n    try {\n      await this._mutex.acquire();\n    } catch (error: unknown) {\n      if (error === E_CANCELED) {\n        this._logger.debug(`DefaultTyping.keystroke(); mutex was canceled by a later operation`);\n        return;\n      }\n      throw new Ably.ErrorInfo('mutex acquisition failed', 50000, 500);\n    }\n    try {\n      // Check if connection is connected\n      // CHA-T4e\n      if (this._connection.state !== 'connected') {\n        this._logger.error(`DefaultTyping.keystroke(); connection is not connected`, {\n          status: this._connection.state,\n        });\n        throw new Ably.ErrorInfo('cannot type, connection is not connected', 40000, 400);\n      }\n\n      // Check whether user is already typing before publishing again\n      // CHA-T4c1, CHA-T4c2\n      if (this._heartbeatTimerId) {\n        this._logger.debug(`DefaultTyping.keystroke(); no-op, already typing and heartbeat timer has not expired`);\n        return;\n      }\n\n      // Perform the publish\n      // CHA-T4a3\n      await this._channel.publish(ephemeralMessage(TypingEventType.Start));\n\n      // Start the timer after publishing\n      // CHA-T4a5\n      this._startHeartbeatTimer();\n      this._logger.trace(`DefaultTyping.keystroke(); starting timers`);\n    } finally {\n      this._logger.trace(`DefaultTyping.keystroke(); releasing mutex`);\n      this._mutex.release();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  async stop(): Promise<void> {\n    this._logger.trace(`DefaultTyping.stop();`);\n\n    this._mutex.cancel();\n    // Acquire a mutex\n    try {\n      await this._mutex.acquire();\n    } catch (error: unknown) {\n      if (error === E_CANCELED) {\n        this._logger.debug(`DefaultTyping.stop(); mutex was canceled by a later operation`);\n        return;\n      }\n      throw new Ably.ErrorInfo('mutex acquisition failed', 50000, 500);\n    }\n    try {\n      // Check if connection is connected\n      if (this._connection.state !== 'connected') {\n        this._logger.error(`DefaultTyping.stop(); connection is not connected`, {\n          status: this._connection.state,\n        });\n        throw new Ably.ErrorInfo('cannot stop typing, connection is not connected', 40000, 400);\n      }\n\n      // If the user is not typing, do nothing.\n      // CHA-T5f\n      if (!this._heartbeatTimerId) {\n        this._logger.debug(`DefaultTyping.stop(); no-op, not currently typing`);\n        return;\n      }\n\n      // CHA-T5d\n      await this._channel.publish(ephemeralMessage(TypingEventType.Stop));\n      this._logger.trace(`DefaultTyping.stop(); clearing timers`);\n\n      // CHA-T5e\n      // Clear the heartbeat timer\n      clearTimeout(this._heartbeatTimerId);\n      this._heartbeatTimerId = undefined;\n    } finally {\n      this._logger.trace(`DefaultTyping.stop(); releasing mutex`);\n      this._mutex.release();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  subscribe(listener: TypingListener): Subscription {\n    this._logger.trace(`DefaultTyping.subscribe();`);\n    const wrapped = wrap(listener);\n    this.on(wrapped);\n\n    return {\n      unsubscribe: () => {\n        this._logger.trace('DefaultTyping.unsubscribe();');\n        this.off(wrapped);\n      },\n    };\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // CHA-RL3h\n  async dispose(): Promise<void> {\n    this._logger.trace(`DefaultTyping.dispose();`);\n\n    // Keep trying to acquire the mutex; wait 200 ms between attempts.\n    for (;;) {\n      try {\n        this._mutex.cancel();\n        await this._mutex.acquire();\n        break; // success – exit the loop\n      } catch (error: unknown) {\n        if (error === E_CANCELED) {\n          // In this case, the mutex was canceled by a later operation,\n          // but we are trying to release, so we should always take precedence here.\n          // Let's continue trying to acquire it until we win the acquisition lock.\n          this._logger.debug(`DefaultTyping.dispose(); mutex was canceled`);\n          await new Promise((resolve) => setTimeout(resolve, 200));\n          this._logger.debug(`DefaultTyping.dispose(); retrying mutex acquisition`);\n        } else {\n          // If we encounter any other error, we log it and exit the loop.\n          // This is to ensure that we don't get stuck in an infinite loop\n          // if the mutex acquisition fails for some other non-retryable reason.\n          this._logger.error(`DefaultTyping.dispose(); failed to acquire mutex; could not complete resource disposal`, {\n            error,\n          });\n          return;\n        }\n      }\n    }\n    this._clearAllTypingStates();\n    this._mutex.release();\n  }\n\n  /**\n   * Update the currently typing users. This method is called when a typing event is received.\n   * It will also acquire a mutex to ensure that the currentlyTyping state is updated safely.\n   * @param clientId The client ID of the user.\n   * @param event The typing event.\n   */\n  private _updateCurrentlyTyping(clientId: string, event: TypingEventType): void {\n    this._logger.trace(`DefaultTyping._updateCurrentlyTyping();`, { clientId, event });\n\n    if (event === TypingEventType.Start) {\n      this._handleTypingStart(clientId);\n    } else {\n      this._handleTypingStop(clientId);\n    }\n  }\n\n  /**\n   * Starts a new inactivity timer for the client.\n   * This timer will expire after the configured timeout,\n   * which is the sum of the heartbeat interval and the inactivity timeout.\n   * @param clientId\n   */\n  private _startNewClientInactivityTimer(clientId: string): ReturnType<typeof setTimeout> {\n    this._logger.trace(`DefaultTyping._startNewClientInactivityTimer(); starting new inactivity timer`, {\n      clientId,\n    });\n    // Set or reset the typing timeout for this client\n    const timeoutId = setTimeout(() => {\n      this._logger.trace(`DefaultTyping._startNewClientInactivityTimer(); client typing timeout expired`, {\n        clientId,\n      });\n      // Verify the timer is still valid (it might have been reset)\n      if (this._currentlyTyping.get(clientId) !== timeoutId) {\n        this._logger.debug(`DefaultTyping._startNewClientInactivityTimer(); timeout already cleared; ignoring`, {\n          clientId,\n        });\n        return;\n      }\n\n      // Remove client whose timeout has expired\n      this._currentlyTyping.delete(clientId);\n      this.emit(TypingSetEventType.SetChanged, {\n        type: TypingSetEventType.SetChanged,\n        currentlyTyping: new Set<string>(this._currentlyTyping.keys()),\n        change: {\n          clientId,\n          type: TypingEventType.Stop,\n        },\n      });\n    }, this._heartbeatThrottleMs + this._timeoutMs);\n    return timeoutId;\n  }\n\n  /**\n   * Handles logic for TypingEventType.Start, including starting a new timeout or resetting an existing one.\n   * @param clientId\n   */\n  private _handleTypingStart(clientId: string): void {\n    this._logger.debug(`DefaultTyping._handleTypingStart();`, { clientId });\n    // Start a new timeout for the client\n    const timeoutId = this._startNewClientInactivityTimer(clientId);\n\n    const existingTimeout = this._currentlyTyping.get(clientId);\n\n    // Set the new timeout for the client\n    this._currentlyTyping.set(clientId, timeoutId);\n\n    if (existingTimeout) {\n      // Heartbeat - User is already typing, we just need to clear the existing timeout\n      this._logger.debug(`DefaultTyping._handleTypingStart(); received heartbeat for currently typing client`, {\n        clientId,\n      });\n      clearTimeout(existingTimeout);\n    } else {\n      // Otherwise, we need to emit a new typing event\n      this._logger.debug(`DefaultTyping._handleTypingStart(); new client started typing`, {\n        clientId,\n      });\n      this.emit(TypingSetEventType.SetChanged, {\n        type: TypingSetEventType.SetChanged,\n        currentlyTyping: new Set<string>(this._currentlyTyping.keys()),\n        change: {\n          clientId,\n          type: TypingEventType.Start,\n        },\n      });\n    }\n  }\n\n  /**\n   * Handles logic for TypingEventType.Stop, including clearing the timeout for the client.\n   * @param clientId\n   * @private\n   */\n  private _handleTypingStop(clientId: string): void {\n    const existingTimeout = this._currentlyTyping.get(clientId);\n    if (!existingTimeout) {\n      // Stop requested for a client that isn't currently typing\n      this._logger.trace(\n        `DefaultTyping._handleTypingStop(); received \"Stop\" event for client not in currentlyTyping list`,\n        { clientId },\n      );\n      return;\n    }\n\n    // Stop typing: clear their timeout and remove from the currently typing set\n    this._logger.debug(`DefaultTyping._handleTypingStop(); client stopped typing`, { clientId });\n    clearTimeout(existingTimeout);\n    this._currentlyTyping.delete(clientId);\n    // Emit stop event only when the client is removed\n    this.emit(TypingSetEventType.SetChanged, {\n      type: TypingSetEventType.SetChanged,\n      currentlyTyping: new Set<string>(this._currentlyTyping.keys()),\n      change: {\n        clientId,\n        type: TypingEventType.Stop,\n      },\n    });\n  }\n\n  /**\n   * Subscribe to internal events. This listens to events and converts them into typing updates, with validation.\n   */\n  private _internalSubscribeToEvents = (inbound: Ably.InboundMessage): void => {\n    const { name, clientId } = inbound;\n    this._logger.trace(`DefaultTyping._internalSubscribeToEvents(); received event`, {\n      name,\n      clientId,\n    });\n\n    if (!clientId) {\n      this._logger.error(`DefaultTyping._internalSubscribeToEvents(); invalid clientId in received event`, {\n        inbound,\n      });\n      return;\n    }\n\n    // Safety check to ensure we are handling only typing events\n    if (name === TypingEventType.Start || name === TypingEventType.Stop) {\n      this._updateCurrentlyTyping(clientId, name);\n    } else {\n      this._logger.warn(`DefaultTyping._internalSubscribeToEvents(); unrecognized event`, {\n        name,\n      });\n    }\n  };\n\n  get heartbeatThrottleMs(): number {\n    return this._heartbeatThrottleMs;\n  }\n\n  get hasHeartbeatTimer(): boolean {\n    return !!this._heartbeatTimerId;\n  }\n}\n","import * as Ably from 'ably';\nimport cloneDeep from 'lodash.clonedeep';\n\nimport { ChannelManager } from './channel-manager.js';\nimport { ChatApi } from './chat-api.js';\nimport { DiscontinuityListener } from './discontinuity.js';\nimport { Logger } from './logger.js';\nimport { DefaultMessages, Messages } from './messages.js';\nimport { DefaultMessageReactions } from './messages-reactions.js';\nimport { DefaultOccupancy, Occupancy } from './occupancy.js';\nimport { DefaultPresence, Presence } from './presence.js';\nimport { RoomLifecycleManager } from './room-lifecycle-manager.js';\nimport { InternalRoomOptions, RoomOptions, validateRoomOptions } from './room-options.js';\nimport { DefaultRoomReactions, RoomReactions } from './room-reactions.js';\nimport { DefaultRoomLifecycle, InternalRoomLifecycle, RoomStatus, RoomStatusListener } from './room-status.js';\nimport { StatusSubscription } from './subscription.js';\nimport { DefaultTyping, Typing } from './typing.js';\n\n/**\n * Represents a chat room.\n */\nexport interface Room {\n  /**\n   * The unique identifier of the room.\n   *\n   * @returns The room name.\n   */\n  get name(): string;\n\n  /**\n   * Allows you to send, subscribe-to and query messages in the room.\n   *\n   * @returns The messages instance for the room.\n   */\n  get messages(): Messages;\n\n  /**\n   * Allows you to subscribe to presence events in the room.\n   *\n   * @returns The presence instance for the room.\n   */\n  get presence(): Presence;\n\n  /**\n   * Allows you to interact with room-level reactions.\n   *\n   * @returns The room reactions instance for the room.\n   */\n  get reactions(): RoomReactions;\n\n  /**\n   * Allows you to interact with typing events in the room.\n   *\n   * @returns The typing instance for the room.\n   */\n  get typing(): Typing;\n\n  /**\n   * Allows you to interact with occupancy metrics for the room.\n   *\n   * @returns The occupancy instance for the room.\n   */\n  get occupancy(): Occupancy;\n\n  /**\n   * The current status of the room.\n   *\n   * @returns The current status.\n   */\n  get status(): RoomStatus;\n\n  /**\n   * The current error, if any, that caused the room to enter the current status.\n   */\n  get error(): Ably.ErrorInfo | undefined;\n\n  /**\n   * Registers a listener that will be called whenever the room status changes.\n   * @param listener The function to call when the status changes.\n   * @returns An object that can be used to unregister the listener.\n   */\n  onStatusChange(listener: RoomStatusListener): StatusSubscription;\n\n  /**\n   * Attaches to the room to receive events in realtime.\n   *\n   * If a room fails to attach, it will enter either the {@link RoomStatus.Suspended} or {@link RoomStatus.Failed} state.\n   *\n   * If the room enters the failed state, then it will not automatically retry attaching and intervention is required.\n   *\n   * If the room enters the suspended state, then the call to attach will reject with the {@link ErrorInfo} that caused the suspension. However,\n   * the room will automatically retry attaching after a delay.\n   *\n   * @returns A promise that resolves when the room is attached.\n   */\n  attach(): Promise<void>;\n\n  /**\n   * Detaches from the room to stop receiving events in realtime.\n   *\n   * @returns A promise that resolves when the room is detached.\n   */\n  detach(): Promise<void>;\n\n  /**\n   * Returns the room options.\n   *\n   * @returns A copy of the options used to create the room.\n   */\n  options(): RoomOptions;\n\n  /**\n   * Registers a handler that will be called whenever a discontinuity is detected in the room's connection.\n   * A discontinuity occurs when the room's connection is interrupted and cannot be resumed from its previous state.\n   *\n   * @param handler The function to call when a discontinuity is detected.\n   * @returns An object that can be used to unregister the handler.\n   */\n  onDiscontinuity(handler: DiscontinuityListener): StatusSubscription;\n\n  /**\n   * Get the underlying Ably realtime channel used for the room.\n   * @returns The realtime channel.\n   */\n  get channel(): Ably.RealtimeChannel;\n}\n\nexport class DefaultRoom implements Room {\n  private readonly _name: string;\n  private readonly _options: RoomOptions;\n  private readonly _chatApi: ChatApi;\n  private readonly _messages: DefaultMessages;\n  private readonly _typing: DefaultTyping;\n  private readonly _presence: DefaultPresence;\n  private readonly _reactions: DefaultRoomReactions;\n  private readonly _occupancy: DefaultOccupancy;\n  private readonly _logger: Logger;\n  private readonly _lifecycle: DefaultRoomLifecycle;\n  private readonly _lifecycleManager: RoomLifecycleManager;\n  private readonly _finalizer: () => Promise<void>;\n  private readonly _channelManager: ChannelManager;\n\n  /**\n   * A random identifier for the room instance, useful in debugging and logging.\n   */\n  private readonly _nonce: string;\n\n  /**\n   * Constructs a new Room instance.\n   *\n   * @param name The unique identifier of the room.\n   * @param nonce A random identifier for the room instance, useful in debugging and logging.\n   * @param options The options for the room.\n   * @param realtime An instance of the Ably Realtime client.\n   * @param chatApi An instance of the ChatApi.\n   * @param logger An instance of the Logger.\n   * @param connection An instance of the Connection.\n   */\n  constructor(\n    name: string,\n    nonce: string,\n    options: InternalRoomOptions,\n    realtime: Ably.Realtime,\n    chatApi: ChatApi,\n    logger: Logger,\n  ) {\n    validateRoomOptions(options);\n    this._nonce = nonce;\n\n    // Create a logger with room context\n    this._logger = logger.withContext({ roomName: name, roomNonce: nonce });\n    this._logger.debug('Room();', { options });\n\n    this._name = name;\n    this._options = options;\n    this._chatApi = chatApi;\n    this._lifecycle = new DefaultRoomLifecycle(this._logger);\n\n    const channelManager = (this._channelManager = this._getChannelManager(options, realtime, this._logger));\n    const channel = channelManager.get();\n\n    // Setup features\n    this._messages = new DefaultMessages(\n      name,\n      options.messages,\n      channel,\n      this._chatApi,\n      realtime.auth.clientId,\n      this._logger,\n    );\n    this._presence = new DefaultPresence(channel, realtime.auth.clientId, this._logger, options);\n    this._typing = new DefaultTyping(\n      options.typing,\n      realtime.connection,\n      channel,\n      realtime.auth.clientId,\n      this._logger,\n    );\n    this._reactions = new DefaultRoomReactions(channel, realtime.connection, realtime.auth.clientId, this._logger);\n    this._occupancy = new DefaultOccupancy(name, channel, this._chatApi, this._logger, options);\n\n    // Set the lifecycle manager last, so it becomes the last thing to find out about channel state changes\n    // This is to allow Messages to reset subscription points before users get told of a discontinuity\n    this._lifecycleManager = new RoomLifecycleManager(channelManager, this._lifecycle, this._logger);\n\n    // Setup a finalization function to clean up resources\n    let finalized = false;\n    this._finalizer = async () => {\n      // Cycle the channels in the feature and release them from the realtime client\n      if (finalized) {\n        this._logger.debug('Room.finalizer(); already finalized');\n        return;\n      }\n\n      // Release via the lifecycle manager\n      await this._lifecycleManager.release();\n\n      // Dispose of all remaining resources only once we have fully released the room\n      await this._typing.dispose();\n\n      finalized = true;\n    };\n  }\n\n  /**\n   * Gets the channel manager for the room, which handles merging channel options together and creating channels.\n   *\n   * @param options The room options.\n   * @param realtime  An instance of the Ably Realtime client.\n   * @param logger An instance of the Logger.\n   */\n  private _getChannelManager(options: InternalRoomOptions, realtime: Ably.Realtime, logger: Logger): ChannelManager {\n    const manager = new ChannelManager(this._name, realtime, logger, options.isReactClient);\n\n    manager.mergeOptions(DefaultOccupancy.channelOptionMerger(options));\n    manager.mergeOptions(DefaultPresence.channelOptionMerger(options));\n    manager.mergeOptions(DefaultMessageReactions.channelOptionMerger(options));\n    return manager;\n  }\n\n  /**\n   * @inheritdoc Room\n   */\n  get name(): string {\n    return this._name;\n  }\n\n  /**\n   * @inheritDoc Room\n   */\n  options(): RoomOptions {\n    return cloneDeep(this._options);\n  }\n\n  /**\n   * @inheritdoc Room\n   */\n  get messages(): Messages {\n    return this._messages;\n  }\n\n  /**\n   * @inheritdoc Room\n   */\n  get presence(): Presence {\n    return this._presence;\n  }\n\n  /**\n   * @inheritdoc Room\n   */\n  get reactions(): RoomReactions {\n    return this._reactions;\n  }\n\n  /**\n   * @inheritdoc Room\n   */\n  get typing(): Typing {\n    return this._typing;\n  }\n\n  /**\n   * @inheritdoc Room\n   */\n  get occupancy(): Occupancy {\n    return this._occupancy;\n  }\n\n  /**\n   * @inheritdoc Room\n   */\n  get status(): RoomStatus {\n    return this._lifecycle.status;\n  }\n\n  /**\n   * @inheritdoc Room\n   */\n  get error(): Ably.ErrorInfo | undefined {\n    return this._lifecycle.error;\n  }\n\n  /**\n   * @inheritdoc Room\n   */\n  onStatusChange(listener: RoomStatusListener): StatusSubscription {\n    return this._lifecycle.onChange(listener);\n  }\n\n  /**\n   * @inheritdoc Room\n   */\n  async attach() {\n    this._logger.trace('Room.attach();');\n    return this._lifecycleManager.attach();\n  }\n\n  /**\n   * @inheritdoc Room\n   */\n  async detach(): Promise<void> {\n    this._logger.trace('Room.detach();');\n    return this._lifecycleManager.detach();\n  }\n\n  /**\n   * Releases resources associated with the room.\n   * We guarantee that this does not throw an error.\n   */\n  release(): Promise<void> {\n    this._logger.trace('Room.release();');\n    return this._finalizer();\n  }\n\n  /**\n   * A random identifier for the room instance, useful in debugging and logging.\n   *\n   * @returns The nonce.\n   */\n  get nonce(): string {\n    return this._nonce;\n  }\n\n  /**\n   * @internal\n   *\n   * Returns the rooms lifecycle.\n   */\n  get lifecycle(): InternalRoomLifecycle {\n    return this._lifecycle;\n  }\n\n  /**\n   * @internal\n   */\n  get lifecycleManager(): RoomLifecycleManager {\n    return this._lifecycleManager;\n  }\n\n  /**\n   * @inheritdoc Room\n   */\n  onDiscontinuity(handler: DiscontinuityListener): StatusSubscription {\n    this._logger.trace('Room.onDiscontinuity();');\n    return this._lifecycleManager.onDiscontinuity(handler);\n  }\n\n  /**\n   * @inheritdoc Room\n   */\n  get channel(): Ably.RealtimeChannel {\n    return this._channelManager.get();\n  }\n}\n","import * as Ably from 'ably';\nimport { dequal } from 'dequal';\n\nimport { ChatApi } from './chat-api.js';\nimport { ChatClientOptions, NormalizedChatClientOptions } from './config.js';\nimport { ErrorCode } from './errors.js';\nimport { randomId } from './id.js';\nimport { Logger } from './logger.js';\nimport { DefaultRoom, Room } from './room.js';\nimport { normalizeRoomOptions, RoomOptions } from './room-options.js';\n\n/**\n * Manages the lifecycle of chat rooms.\n */\nexport interface Rooms {\n  /**\n   * Gets a room reference by its unique identifier. The Rooms class ensures that only one reference\n   * exists for each room. A new reference object is created if it doesn't already\n   * exist, or if the one used previously was released using release(name).\n   *\n   * Always call `release(name)` after the Room object is no longer needed.\n   *\n   * If a call to `get` is made for a room that is currently being released, then the promise will resolve only when\n   * the release operation is complete.\n   *\n   * If a call to `get` is made, followed by a subsequent call to `release` before the promise resolves, then the\n   * promise will reject with an error.\n   *\n   * @param name The unique identifier of the room.\n   * @param options The options for the room.\n   * @throws {@link ErrorInfo} if a room with the same name but different options already exists.\n   * @returns Room A promise to a new or existing Room object.\n   */\n  get(name: string, options?: RoomOptions): Promise<Room>;\n\n  /**\n   * Release the Room object if it exists. This method only releases the reference\n   * to the Room object from the Rooms instance and detaches the room from Ably. It does not unsubscribe to any\n   * events.\n   *\n   * After calling this function, the room object is no-longer usable. If you wish to get the room object again,\n   * you must call {@link Rooms.get}.\n   *\n   * Calling this function will abort any in-progress `get` calls for the same room.\n   *\n   * @param name The unique identifier of the room.\n   */\n  release(name: string): Promise<void>;\n\n  /**\n   * Get the client options used to create the Chat instance.\n   * @returns ChatClientOptions\n   */\n  get clientOptions(): ChatClientOptions;\n}\n\n/**\n * Represents an entry in the chat room map.\n */\ninterface RoomMapEntry {\n  /**\n   * The promise that will eventually resolve to the room.\n   */\n  promise: Promise<DefaultRoom>;\n\n  /**\n   * A random, internal identifier useful for debugging and logging.\n   */\n  nonce: string;\n\n  /**\n   * The options for the room.\n   */\n  options: RoomOptions | undefined;\n\n  /**\n   * An abort controller to abort the get operation if the room is released before the get operation completes.\n   */\n  abort?: AbortController;\n}\n\n/**\n * Manages the chat rooms.\n */\nexport class DefaultRooms implements Rooms {\n  private readonly _realtime: Ably.Realtime;\n  private readonly _chatApi: ChatApi;\n  private readonly _clientOptions: NormalizedChatClientOptions;\n  private readonly _rooms: Map<string, RoomMapEntry> = new Map<string, RoomMapEntry>();\n  private readonly _releasing = new Map<string, Promise<void>>();\n  private readonly _logger: Logger;\n  private _isReact = false;\n\n  /**\n   * Constructs a new Rooms instance.\n   *\n   * @param realtime An instance of the Ably Realtime client.\n   * @param clientOptions The client options from the chat instance.\n   * @param logger An instance of the Logger.\n   */\n  constructor(realtime: Ably.Realtime, clientOptions: NormalizedChatClientOptions, logger: Logger) {\n    this._realtime = realtime;\n    this._chatApi = new ChatApi(realtime, logger);\n    this._clientOptions = clientOptions;\n    this._logger = logger;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  get(name: string, options?: RoomOptions): Promise<Room> {\n    this._logger.trace('Rooms.get();', { roomName: name });\n\n    const existing = this._rooms.get(name);\n    if (existing) {\n      if (!dequal(existing.options, options)) {\n        return Promise.reject(new Ably.ErrorInfo('room already exists with different options', 40000, 400));\n      }\n\n      this._logger.debug('Rooms.get(); returning existing room', { roomName: name, nonce: existing.nonce });\n      return existing.promise;\n    }\n\n    const releasing = this._releasing.get(name);\n    const nonce = randomId();\n\n    // We're not currently releasing the room, so we just make a new one\n    if (!releasing) {\n      const room = this._makeRoom(name, nonce, options);\n      const entry = {\n        promise: Promise.resolve(room),\n        nonce: nonce,\n        options: options,\n      };\n\n      this._rooms.set(name, entry);\n      this._logger.debug('Rooms.get(); returning new room', { roomName: name, nonce: room.nonce });\n      return entry.promise;\n    }\n\n    // The room is currently in the process of being released so, we wait for it to finish\n    // we add an abort controller so that if the room is released again whilst we're waiting, we abort the process\n    const abortController = new AbortController();\n    const roomPromise = new Promise<DefaultRoom>((resolve, reject) => {\n      const abortListener = () => {\n        this._logger.debug('Rooms.get(); aborted before init', { roomName: name });\n        reject(\n          new Ably.ErrorInfo(\n            'room released before get operation could complete',\n            ErrorCode.RoomReleasedBeforeOperationCompleted,\n            400,\n          ),\n        );\n      };\n\n      abortController.signal.addEventListener('abort', abortListener);\n\n      releasing\n        .then(() => {\n          // We aborted before resolution\n          if (abortController.signal.aborted) {\n            this._logger.debug('Rooms.get(); aborted before releasing promise resolved', { roomName: name });\n            return;\n          }\n\n          this._logger.debug('Rooms.get(); releasing finished', { roomName: name });\n          const room = this._makeRoom(name, nonce, options);\n          abortController.signal.removeEventListener('abort', abortListener);\n          resolve(room);\n        })\n        .catch((error: unknown) => {\n          reject(error as Error);\n        });\n    });\n\n    this._rooms.set(name, {\n      promise: roomPromise,\n      options: options,\n      nonce: nonce,\n      abort: abortController,\n    });\n\n    this._logger.debug('Rooms.get(); creating new promise dependent on previous release', { roomName: name });\n    return roomPromise;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  get clientOptions(): ChatClientOptions {\n    return this._clientOptions;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  release(name: string): Promise<void> {\n    this._logger.trace('Rooms.release();', { roomName: name });\n\n    const existing = this._rooms.get(name);\n    const releasing = this._releasing.get(name);\n\n    // If the room doesn't currently exist\n    if (!existing) {\n      // There's no existing room, but there is a release in progress, so forward that releasing promise\n      // to the caller so they can watch that.\n      if (releasing) {\n        this._logger.debug('Rooms.release(); waiting for previous release call', {\n          roomName: name,\n        });\n        return releasing;\n      }\n\n      // If the room is not releasing, there is nothing else to do\n      this._logger.debug('Rooms.release(); room does not exist', { roomName: name });\n      return Promise.resolve();\n    }\n\n    // A release is in progress, but its not for the currently requested room instance\n    // ie we called release, then get, then release again\n    // so instead of doing another release process, we just abort the current get\n    if (releasing) {\n      if (existing.abort) {\n        this._logger.debug('Rooms.release(); aborting get call', { roomName: name, existingNonce: existing.nonce });\n        existing.abort.abort();\n        this._rooms.delete(name);\n      }\n\n      return releasing;\n    }\n\n    // Room doesn't exist and we're not releasing, so its just a regular release operation\n    this._rooms.delete(name);\n    const releasePromise = existing.promise.then((room) => {\n      this._logger.debug('Rooms.release(); releasing room', { roomName: name, nonce: existing.nonce });\n      return room.release().then(() => {\n        this._logger.debug('Rooms.release(); room released', { roomName: name, nonce: existing.nonce });\n        this._releasing.delete(name);\n      });\n    });\n\n    this._logger.debug('Rooms.release(); creating new release promise', { roomName: name, nonce: existing.nonce });\n    this._releasing.set(name, releasePromise);\n\n    return releasePromise;\n  }\n\n  /**\n   * makes a new room object\n   *\n   * @param name The unique identifier of the room.\n   * @param nonce A random, internal identifier useful for debugging and logging.\n   * @param options The options for the room.\n   *\n   * @returns DefaultRoom A new room object.\n   */\n  private _makeRoom(name: string, nonce: string, options: RoomOptions | undefined): DefaultRoom {\n    return new DefaultRoom(\n      name,\n      nonce,\n      normalizeRoomOptions(options, this._isReact),\n      this._realtime,\n      this._chatApi,\n      this._logger,\n    );\n  }\n\n  /**\n   * Sets react JS mode.\n   */\n  useReact(): void {\n    this._logger.trace('Rooms.useReact();');\n    this._isReact = true;\n  }\n}\n","import * as Ably from 'ably';\n\nimport { ChatClientOptions, normalizeClientOptions, NormalizedChatClientOptions } from './config.js';\nimport { Connection, DefaultConnection } from './connection.js';\nimport { Logger, makeLogger } from './logger.js';\nimport { RealtimeWithOptions } from './realtime-extensions.js';\nimport { DefaultRooms, Rooms } from './rooms.js';\nimport { VERSION } from './version.js';\n\n/**\n * This is the core client for Ably chat. It provides access to chat rooms.\n */\nexport class ChatClient {\n  /**\n   * @internal\n   */\n  private readonly _realtime: Ably.Realtime;\n\n  /**\n   * @internal\n   */\n  private readonly _rooms: DefaultRooms;\n\n  /**\n   * @internal\n   */\n  private readonly _clientOptions: NormalizedChatClientOptions;\n\n  /**\n   * @internal\n   */\n  private readonly _connection: Connection;\n\n  /**\n   * @internal\n   */\n  private readonly _logger: Logger;\n\n  /**\n   * Constructor for Chat\n   * @param realtime - The Ably Realtime client.\n   * @param clientOptions - The client options.\n   */\n  constructor(realtime: Ably.Realtime, clientOptions?: ChatClientOptions) {\n    this._realtime = realtime;\n    this._clientOptions = normalizeClientOptions(clientOptions);\n    this._logger = makeLogger(this._clientOptions);\n    this._connection = new DefaultConnection(realtime, this._logger);\n    this._rooms = new DefaultRooms(realtime, this._clientOptions, this._logger);\n    this._addAgent('chat-js');\n    this._logger.trace(`ably chat client version ${VERSION}; initialized`);\n  }\n\n  /**\n   * Returns the rooms object, which provides access to chat rooms.\n   *\n   * @returns The rooms object.\n   */\n  get rooms(): Rooms {\n    return this._rooms;\n  }\n\n  /**\n   * Returns the underlying connection to Ably, which can be used to monitor the client's\n   * connection to Ably servers.\n   *\n   * @returns The connection object.\n   */\n  get connection(): Connection {\n    return this._connection;\n  }\n\n  /**\n   * Returns the clientId of the current client.\n   *\n   * @returns The clientId.\n   */\n  get clientId(): string {\n    return this._realtime.auth.clientId;\n  }\n\n  /**\n   * Returns the underlying Ably Realtime client.\n   * @returns The Ably Realtime client.\n   */\n  get realtime(): Ably.Realtime {\n    return this._realtime;\n  }\n\n  /**\n   * Returns the resolved client options for the client, including any defaults that have been set.\n   * @returns The client options.\n   */\n  get clientOptions(): ChatClientOptions {\n    return this._clientOptions;\n  }\n\n  /**\n   * Returns the logger instance for the client.\n   * @internal\n   * @returns The logger instance.\n   */\n  get logger(): Logger {\n    return this._logger;\n  }\n\n  /**\n   * Adds additional agent information to the client.\n   * Used internally to add React-specific agent information.\n   * @internal\n   */\n  public addReactAgent(): void {\n    this._addAgent('chat-react');\n    this._rooms.useReact();\n  }\n\n  /**\n   * Adds additional agent information to the client.\n   * This is used internally to add a specific agent with a version.\n   * @param agent - The agent to add.\n   * @param version - The version of the agent, defaults to the current client version.\n   * @internal\n   */\n  public addAgentWithVersion(agent: string, version: string): void {\n    this._addAgent(agent, version);\n    this._logger.trace(`Added agent ${agent} with version ${version}`);\n  }\n  /**\n   * Sets the agent string for the client.\n   * @param agent - The agent to add.\n   * @param version - The version of the agent, defaults to the current client version.\n   * @internal\n   */\n  private _addAgent(agent: string, version?: string): void {\n    const realtime = this._realtime as RealtimeWithOptions;\n    realtime.options.agents = { ...(realtime.options.agents ?? realtime.options.agents), [agent]: version ?? VERSION };\n  }\n}\n"],"names":["LogLevel","consoleLogger","message","level","context","contextString","formattedMessage","makeLogger","options","logHandler","DefaultLogger","logLevelNumberMap","handler","levelNumber","Ably","originalLevel","value","defaultClientOptions","normalizeClientOptions","InternalEventEmitter","EventEmitter","wrap","fn","args","ConnectionStatus","DefaultConnection","ably","logger","change","chatState","stateChange","listener","wrapped","status","has","find","iter","tar","key","dequal","foo","bar","ctor","len","tmp","ChatMessageEventType","RealtimeMessageName","RealtimeMetaEventType","ChatMessageAction","PresenceEventType","TypingEventType","TypingSetEventType","RoomReactionRealtimeEventType","RoomReactionEventType","MessageReactionType","ReactionAnnotationType","AnnotationTypeToReactionType","MessageReactionEventType","OccupancyEventType","RoomEventType","LARGE_ARRAY_SIZE","HASH_UNDEFINED","MAX_SAFE_INTEGER","argsTag","arrayTag","boolTag","dateTag","errorTag","funcTag","genTag","mapTag","numberTag","objectTag","promiseTag","regexpTag","setTag","stringTag","symbolTag","weakMapTag","arrayBufferTag","dataViewTag","float32Tag","float64Tag","int8Tag","int16Tag","int32Tag","uint8Tag","uint8ClampedTag","uint16Tag","uint32Tag","reRegExpChar","reFlags","reIsHostCtor","reIsUint","cloneableTags","freeGlobal","global","freeSelf","root","freeExports","exports","freeModule","module","moduleExports","addMapEntry","map","pair","addSetEntry","set","arrayEach","array","iteratee","index","length","arrayPush","values","offset","arrayReduce","accumulator","initAccum","baseTimes","n","result","getValue","object","isHostObject","mapToArray","overArg","func","transform","arg","setToArray","arrayProto","funcProto","objectProto","coreJsData","maskSrcKey","uid","funcToString","hasOwnProperty","objectToString","reIsNative","Buffer","Symbol","Uint8Array","getPrototype","objectCreate","propertyIsEnumerable","splice","nativeGetSymbols","nativeIsBuffer","nativeKeys","DataView","getNative","Map","Promise","Set","WeakMap","nativeCreate","dataViewCtorString","toSource","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","symbolProto","symbolValueOf","Hash","entries","entry","hashClear","hashDelete","hashGet","data","hashHas","hashSet","ListCache","listCacheClear","listCacheDelete","assocIndexOf","lastIndex","listCacheGet","listCacheHas","listCacheSet","MapCache","mapCacheClear","mapCacheDelete","getMapData","mapCacheGet","mapCacheHas","mapCacheSet","Stack","stackClear","stackDelete","stackGet","stackHas","stackSet","cache","pairs","arrayLikeKeys","inherited","isArray","isArguments","skipIndexes","isIndex","assignValue","objValue","eq","baseAssign","source","copyObject","keys","baseClone","isDeep","isFull","customizer","stack","isObject","isArr","initCloneArray","copyArray","tag","getTag","isFunc","isBuffer","cloneBuffer","initCloneObject","copySymbols","initCloneByTag","stacked","props","getAllKeys","subValue","baseCreate","proto","baseGetAllKeys","keysFunc","symbolsFunc","baseGetTag","baseIsNative","isMasked","pattern","isFunction","baseKeys","isPrototype","buffer","cloneArrayBuffer","arrayBuffer","cloneDataView","dataView","cloneMap","cloneFunc","cloneRegExp","regexp","cloneSet","cloneSymbol","symbol","cloneTypedArray","typedArray","newValue","getSymbols","isKeyable","stubArray","Ctor","ctorString","type","cloneDeep","other","isArrayLikeObject","isArrayLike","isLength","isObjectLike","stubFalse","DefaultMessage","serial","clientId","text","metadata","headers","action","version","createdAt","timestamp","reactions","operation","event","newReactions","replace","params","emptyMessageReactions","parseMessage","inboundMessage","extras","serialToString","serialString","eventTypeMap","DefaultMessageReactions","_logger","_options","_api","_roomName","_channel","reactionType","eventType","name","reactionEvent","unique","distinct","multiple","messageSerial","count","apiParams","roomOptions","messageFromRest","MessageActionsToEventsMap","OrderBy","DefaultMessages","roomName","channel","chatApi","subscriptionPoint","subscriptionPointParams","fromResume","newSubscriptionStartResolver","channelWithProperties","resolve","reject","response","updateParams","details","resolvedSubscriptionStart","channelEventMessage","error","ChatApi","realtime","paginatedResult","payload","nextData","firstData","currentData","body","encodedSerial","url","method","ErrorCode","errorInfoIs","errorInfo","randomId","roomChannelName","VERSION","CHANNEL_OPTIONS_AGENT_STRING","CHANNEL_OPTIONS_AGENT_STRING_REACT","DEFAULT_CHANNEL_MODES","DEFAULT_CHANNEL_OPTIONS","DEFAULT_CHANNEL_OPTIONS_REACT","ChannelManager","isReact","merger","baseOptions","DefaultOccupancy","metrics","connections","presenceMembers","DefaultPresence","member","presenceData","user","presenceEventToSend","listenerOrEvents","E_CANCELED","__awaiter$2","thisArg","_arguments","P","generator","adopt","fulfilled","step","e","rejected","Semaphore","_value","_cancelError","weight","priority","task","i","findIndexFromEnd","callback_1","callback","release","insertSorted","item","previousValue","called","waiters","waiter","queuedPriority","a","v","predicate","__awaiter$1","Mutex","cancelError","releaser","RoomStatus","DefaultRoomLifecycle","RoomLifecycleManager","channelManager","roomLifecycle","newStatus","errInfo","attachError","detachError","channelState","op","firstAttach","DefaultRoomOptions","invalidRoomConfiguration","reason","validateRoomOptions","validateTypingOptions","normalizeTypingOptions","normalizeOccupancyOptions","normalizePresenceOptions","normalizeMessageOptions","normalizeRoomOptions","react","ephemeralMessage","messageToEphemeral","DefaultRoomReaction","isSelf","parseRoomReaction","reactionCreatedMessage","DefaultRoomReactions","connection","inbound","reaction","realtimeMessage","DefaultTyping","timeoutId","timer","existingTimeout","DefaultRoom","nonce","finalized","manager","DefaultRooms","clientOptions","existing","releasing","room","abortController","roomPromise","abortListener","releasePromise","ChatClient","agent"],"mappings":"4hBAuDY,IAAAA,IAAAA,IAKVA,EAAA,MAAQ,QAMRA,EAAA,MAAQ,QAKRA,EAAA,KAAO,OAMPA,EAAA,KAAO,OAMPA,EAAA,MAAQ,QAKRA,EAAA,OAAS,SAjCCA,IAAAA,IAAA,CAAA,CAAA,EA0DL,MAAMC,GAAgB,CAACC,EAAiBC,EAAiBC,IAAyB,CACvF,MAAMC,EAAgBD,EAAU,cAAc,KAAK,UAAUA,CAAO,CAAC,GAAK,GACpEE,EAAmB,IAAI,IAAI,KAAK,EAAE,aAAa,KAAKH,EAAM,UAAU,YAAa,CAAA,eAAeD,CAAO,GAAGG,CAAa,GAE7H,OAAQF,EAAO,CACb,IAAK,QACL,IAAK,QAAgB,CACnB,QAAQ,IAAIG,CAAgB,EAC5B,KAAA,CAEF,IAAK,OAAe,CAClB,QAAQ,KAAKA,CAAgB,EAC7B,KAAA,CAEF,IAAK,OAAe,CAClB,QAAQ,KAAKA,CAAgB,EAC7B,KAAA,CAEF,IAAK,QAAgB,CACnB,QAAQ,MAAMA,CAAgB,EAC9B,KAAA,CAIF,CAEJ,EAEaC,GAAcC,GAAiD,CACpE,MAAAC,EAAaD,EAAQ,YAAcP,GAEzC,OAAO,IAAIS,GAAcD,EAAYD,EAAQ,QAAQ,CACvD,EAiBMG,OAAwB,IAA8B,CAC1D,CAAC,QAAgB,CAAoB,EACrC,CAAC,QAAgB,CAAoB,EACrC,CAAC,OAAe,CAAmB,EACnC,CAAC,OAAe,CAAmB,EACnC,CAAC,QAAgB,CAAoB,EACrC,CAAC,SAAiB,CAAqB,CACzC,CAAC,EAKD,MAAMD,EAAgC,CAKpC,YAAYE,EAAqBT,EAAiBC,EAAsB,CACtE,KAAK,SAAWQ,EAChB,KAAK,SAAWR,EAEV,MAAAS,EAAcF,GAAkB,IAAIR,CAAK,EAC/C,GAAIU,IAAgB,OAClB,MAAM,IAAIC,EAAK,UAAU,sBAAsBX,CAAK,GAAI,IAAO,GAAG,EAGpE,KAAK,aAAeU,CAAA,CAGtB,MAAMX,EAAiBE,EAA4B,CACjD,KAAK,OAAOF,EAAS,QAAgB,EAAsBE,CAAO,CAAA,CAGpE,MAAMF,EAAiBE,EAA4B,CACjD,KAAK,OAAOF,EAAS,QAAgB,EAAsBE,CAAO,CAAA,CAGpE,KAAKF,EAAiBE,EAA4B,CAChD,KAAK,OAAOF,EAAS,OAAe,EAAqBE,CAAO,CAAA,CAGlE,KAAKF,EAAiBE,EAA4B,CAChD,KAAK,OAAOF,EAAS,OAAe,EAAqBE,CAAO,CAAA,CAGlE,MAAMF,EAAiBE,EAA4B,CACjD,KAAK,OAAOF,EAAS,QAAgB,EAAsBE,CAAO,CAAA,CAGpE,YAAYA,EAA6B,CAEvC,MAAMW,EACJ,CAAC,GAAGJ,GAAkB,QAAS,CAAA,EAAE,KAAK,CAAC,CAAG,CAAAK,CAAK,IAAMA,IAAU,KAAK,YAAY,IAAI,CAAC,GAAK,QAErF,OAAA,IAAIN,GAAc,KAAK,SAAUK,EAAe,KAAK,cAAcX,CAAO,CAAC,CAAA,CAG5E,OAAOF,EAAiBC,EAAiBU,EAA6BT,EAA4B,CACpGS,GAAe,KAAK,cACtB,KAAK,SAASX,EAASC,EAAO,KAAK,cAAcC,CAAO,CAAC,CAC3D,CAGM,cAAcA,EAA8C,CAC9D,OAAC,KAAK,SAIHA,EAAU,CAAE,GAAG,KAAK,SAAU,GAAGA,CAAA,EAAY,KAAK,SAHhDA,GAAW,MAGqC,CAE7D,CClNA,MAAMa,GAAuB,CAC3B,SAAUjB,GAAS,KACrB,EAkBakB,GAA0BV,IACrCA,EAAUA,GAAW,CAAC,EAEf,CACL,GAAGA,EACH,SAAUA,EAAQ,UAAYS,GAAqB,QACrD,GCKIE,GACJL,EAAK,SACL,aAqBF,MAAMM,UAAgCD,EAAgC,CAAC,CAS1D,MAAAE,EAAwCC,GAC5C,IAAIC,IAAeD,EAAG,GAAGC,CAAI,EC7E1B,IAAAC,IAAAA,IAIVA,EAAA,YAAc,cAKdA,EAAA,WAAa,aAKbA,EAAA,UAAY,YAKZA,EAAA,aAAe,eAKfA,EAAA,UAAY,YAKZA,EAAA,OAAS,SA7BCA,IAAAA,IAAA,CAAA,CAAA,EA4FL,MAAMC,EAAwC,CAYnD,YAAYC,EAAqBC,EAAgB,CAXjD,KAAQ,QAA4B,cAI5B,KAAA,SAAW,IAAIP,EAQrB,KAAK,QAAUO,EAIf,KAAK,QAAU,KAAK,qBAAqBD,EAAK,WAAW,KAAK,EACzD,KAAA,OAASA,EAAK,WAAW,YAG9B,KAAK,YAAcA,EAAK,WACnB,KAAA,YAAY,GAAIE,GAAuC,CAC1D,MAAMC,EAAY,KAAK,qBAAqBD,EAAO,OAAO,EACtD,GAAAC,IAAc,KAAK,QACrB,OAGF,MAAMC,EAAsC,CAC1C,QAASD,EACT,SAAU,KAAK,QACf,MAAOD,EAAO,OACd,QAASA,EAAO,OAClB,EAEA,KAAK,mBAAmBE,CAAW,CAAA,CACpC,CAAA,CAMH,IAAI,QAA2B,CAC7B,OAAO,KAAK,OAAA,CAMd,IAAI,OAAoC,CACtC,OAAO,KAAK,MAAA,CAMd,eAAeC,EAAwD,CAC/D,MAAAC,EAAUX,EAAKU,CAAQ,EACxB,YAAA,SAAS,GAAGC,CAAO,EAEjB,CACL,IAAK,IAAM,CACJ,KAAA,SAAS,IAAIA,CAAO,CAAA,CAE7B,CAAA,CAGM,mBAAmBJ,EAAsC,CAC/D,KAAK,QAAUA,EAAO,QACtB,KAAK,OAASA,EAAO,MAChB,KAAA,QAAQ,KAAK,2BAA4BA,CAAM,EACpD,KAAK,SAAS,KAAKA,EAAO,QAASA,CAAM,CAAA,CAGnC,qBAAqBK,EAAgD,CAC3E,OAAQA,EAAQ,CACd,IAAK,UACL,IAAK,SACI,MAAA,SAET,QACS,OAAAA,CACT,CACF,CAEJ,CC1LA,IAAIC,GAAM,OAAO,UAAU,eAE3B,SAASC,GAAKC,EAAMC,EAAKC,EAAK,CAC7B,IAAKA,KAAOF,EAAK,OAChB,GAAIG,EAAOD,EAAKD,CAAG,EAAG,OAAOC,CAE/B,CAEO,SAASC,EAAOC,EAAKC,EAAK,CAChC,IAAIC,EAAMC,EAAKC,EACf,GAAIJ,IAAQC,EAAK,MAAO,GAExB,GAAID,GAAOC,IAAQC,EAAKF,EAAI,eAAiBC,EAAI,YAAa,CAC7D,GAAIC,IAAS,KAAM,OAAOF,EAAI,QAAS,IAAKC,EAAI,QAAS,EACzD,GAAIC,IAAS,OAAQ,OAAOF,EAAI,SAAU,IAAKC,EAAI,SAAU,EAE7D,GAAIC,IAAS,MAAO,CACnB,IAAKC,EAAIH,EAAI,UAAYC,EAAI,OAC5B,KAAOE,KAASJ,EAAOC,EAAIG,CAAG,EAAGF,EAAIE,CAAG,CAAC,GAAE,CAE5C,OAAOA,IAAQ,EAClB,CAEE,GAAID,IAAS,IAAK,CACjB,GAAIF,EAAI,OAASC,EAAI,KACpB,MAAO,GAER,IAAKE,KAAOH,EAMX,GALAI,EAAMD,EACFC,GAAO,OAAOA,GAAQ,WACzBA,EAAMT,GAAKM,EAAKG,CAAG,EACf,CAACA,IAEF,CAACH,EAAI,IAAIG,CAAG,EAAG,MAAO,GAE3B,MAAO,EACV,CAEE,GAAIF,IAAS,IAAK,CACjB,GAAIF,EAAI,OAASC,EAAI,KACpB,MAAO,GAER,IAAKE,KAAOH,EAMX,GALAI,EAAMD,EAAI,CAAC,EACPC,GAAO,OAAOA,GAAQ,WACzBA,EAAMT,GAAKM,EAAKG,CAAG,EACf,CAACA,IAEF,CAACL,EAAOI,EAAI,CAAC,EAAGF,EAAI,IAAIG,CAAG,CAAC,EAC/B,MAAO,GAGT,MAAO,EACV,CAEE,GAAIF,IAAS,YACZF,EAAM,IAAI,WAAWA,CAAG,EACxBC,EAAM,IAAI,WAAWA,CAAG,UACdC,IAAS,SAAU,CAC7B,IAAKC,EAAIH,EAAI,cAAgBC,EAAI,WAChC,KAAOE,KAASH,EAAI,QAAQG,CAAG,IAAMF,EAAI,QAAQE,CAAG,GAAE,CAEvD,OAAOA,IAAQ,EAClB,CAEE,GAAI,YAAY,OAAOH,CAAG,EAAG,CAC5B,IAAKG,EAAIH,EAAI,cAAgBC,EAAI,WAChC,KAAOE,KAASH,EAAIG,CAAG,IAAMF,EAAIE,CAAG,GAAE,CAEvC,OAAOA,IAAQ,EAClB,CAEE,GAAI,CAACD,GAAQ,OAAOF,GAAQ,SAAU,CACrCG,EAAM,EACN,IAAKD,KAAQF,EAEZ,GADIN,GAAI,KAAKM,EAAKE,CAAI,GAAK,EAAEC,GAAO,CAACT,GAAI,KAAKO,EAAKC,CAAI,GACnD,EAAEA,KAAQD,IAAQ,CAACF,EAAOC,EAAIE,CAAI,EAAGD,EAAIC,CAAI,CAAC,EAAG,MAAO,GAE7D,OAAO,OAAO,KAAKD,CAAG,EAAE,SAAWE,CACtC,CACA,CAEC,OAAOH,IAAQA,GAAOC,IAAQA,CAC/B,CC3EY,IAAAI,GAAAA,IAEVA,EAAA,QAAU,kBAGVA,EAAA,QAAU,kBAGVA,EAAA,QAAU,kBARAA,IAAAA,GAAA,CAAA,CAAA,EAcAC,IAAAA,IAEVA,EAAA,YAAc,eAFJA,IAAAA,IAAA,CAAA,CAAA,EAQAC,IAAAA,IAEVA,EAAA,UAAY,kBAFFA,IAAAA,IAAA,CAAA,CAAA,EAQAC,GAAAA,IAEVA,EAAA,cAAgB,iBAGhBA,EAAA,cAAgB,iBAGhBA,EAAA,cAAgB,iBAGhBA,EAAA,yBAA2B,kBAG3BA,EAAA,qBAAuB,iBAdbA,IAAAA,GAAA,CAAA,CAAA,EAoBAC,IAAAA,IAIVA,EAAA,MAAQ,QAKRA,EAAA,MAAQ,QAKRA,EAAA,OAAS,SAITA,EAAA,QAAU,UAlBAA,IAAAA,IAAA,CAAA,CAAA,EAwBAC,GAAAA,IAIVA,EAAA,MAAQ,iBAKRA,EAAA,KAAO,iBATGA,IAAAA,GAAA,CAAA,CAAA,EAeAC,GAAAA,IAIVA,EAAA,WAAa,qBAJHA,IAAAA,GAAA,CAAA,CAAA,EAyCAC,IAAAA,IAIVA,EAAA,SAAW,eAJDA,IAAAA,IAAA,CAAA,CAAA,EAUAC,IAAAA,IAIVA,EAAA,SAAW,WAJDA,IAAAA,IAAA,CAAA,CAAA,EAwCAC,GAAAA,IAQVA,EAAA,OAAS,SAUTA,EAAA,SAAW,WASXA,EAAA,SAAW,WA3BDA,IAAAA,GAAA,CAAA,CAAA,EAiCAC,GAAAA,IACVA,EAAA,OAAS,qBACTA,EAAA,SAAW,uBACXA,EAAA,SAAW,uBAHDA,IAAAA,GAAA,CAAA,CAAA,EAWL,MAAMC,GAAoE,CAC9E,qBAAgC,SAChC,uBAAkC,WAClC,uBAAkC,UACrC,EAMY,IAAAC,GAAAA,IAIVA,EAAA,OAAS,kBAITA,EAAA,OAAS,kBAITA,EAAA,QAAU,mBAZAA,IAAAA,GAAA,CAAA,CAAA,EAuEAC,GAAAA,IAIVA,EAAA,QAAU,oBAJAA,IAAAA,GAAA,CAAA,CAAA,EAmCAC,GAAAA,IAMVA,EAAA,cAAgB,qBANNA,IAAAA,GAAA,CAAA,CAAA,qSClVZ,IAAIC,EAAmB,IAGnBC,EAAiB,4BAGjBC,EAAmB,iBAGnBC,EAAU,qBACVC,EAAW,iBACXC,EAAU,mBACVC,EAAU,gBACVC,EAAW,iBACXC,EAAU,oBACVC,EAAS,6BACTC,GAAS,eACTC,GAAY,kBACZC,GAAY,kBACZC,GAAa,mBACbC,GAAY,kBACZC,GAAS,eACTC,GAAY,kBACZC,GAAY,kBACZC,GAAa,mBAEbC,GAAiB,uBACjBC,GAAc,oBACdC,GAAa,wBACbC,GAAa,wBACbC,GAAU,qBACVC,GAAW,sBACXC,GAAW,sBACXC,GAAW,sBACXC,GAAkB,6BAClBC,GAAY,uBACZC,GAAY,uBAMZC,GAAe,sBAGfC,GAAU,OAGVC,GAAe,8BAGfC,GAAW,mBAGXC,EAAgB,CAAE,EACtBA,EAAc/B,CAAO,EAAI+B,EAAc9B,CAAQ,EAC/C8B,EAAcf,EAAc,EAAIe,EAAcd,EAAW,EACzDc,EAAc7B,CAAO,EAAI6B,EAAc5B,CAAO,EAC9C4B,EAAcb,EAAU,EAAIa,EAAcZ,EAAU,EACpDY,EAAcX,EAAO,EAAIW,EAAcV,EAAQ,EAC/CU,EAAcT,EAAQ,EAAIS,EAAcxB,EAAM,EAC9CwB,EAAcvB,EAAS,EAAIuB,EAActB,EAAS,EAClDsB,EAAcpB,EAAS,EAAIoB,EAAcnB,EAAM,EAC/CmB,EAAclB,EAAS,EAAIkB,EAAcjB,EAAS,EAClDiB,EAAcR,EAAQ,EAAIQ,EAAcP,EAAe,EACvDO,EAAcN,EAAS,EAAIM,EAAcL,EAAS,EAAI,GACtDK,EAAc3B,CAAQ,EAAI2B,EAAc1B,CAAO,EAC/C0B,EAAchB,EAAU,EAAI,GAG5B,IAAIiB,GAAa,OAAOC,GAAU,UAAYA,GAAUA,EAAO,SAAW,QAAUA,EAGhFC,GAAW,OAAO,MAAQ,UAAY,MAAQ,KAAK,SAAW,QAAU,KAGxEC,EAAOH,IAAcE,IAAY,SAAS,aAAa,EAAG,EAG1DE,GAA4CC,GAAW,CAACA,EAAQ,UAAYA,EAG5EC,GAAaF,IAAe,IAA6BG,GAAU,CAACA,EAAO,UAAYA,EAGvFC,GAAgBF,IAAcA,GAAW,UAAYF,GAUzD,SAASK,GAAYC,EAAKC,EAAM,CAE9B,OAAAD,EAAI,IAAIC,EAAK,CAAC,EAAGA,EAAK,CAAC,CAAC,EACjBD,CACT,CAUA,SAASE,GAAYC,EAAK5F,EAAO,CAE/B,OAAA4F,EAAI,IAAI5F,CAAK,EACN4F,CACT,CAWA,SAASC,GAAUC,EAAOC,EAAU,CAIlC,QAHIC,EAAQ,GACRC,EAASH,EAAQA,EAAM,OAAS,EAE7B,EAAEE,EAAQC,GACXF,EAASD,EAAME,CAAK,EAAGA,EAAOF,CAAK,IAAM,IAA7C,CAIF,OAAOA,CACT,CAUA,SAASI,GAAUJ,EAAOK,EAAQ,CAKhC,QAJIH,EAAQ,GACRC,EAASE,EAAO,OAChBC,EAASN,EAAM,OAEZ,EAAEE,EAAQC,GACfH,EAAMM,EAASJ,CAAK,EAAIG,EAAOH,CAAK,EAEtC,OAAOF,CACT,CAcA,SAASO,GAAYP,EAAOC,EAAUO,EAAaC,EAAW,CAO5D,QANIP,EAAQ,GACRC,EAASH,EAAQA,EAAM,OAAS,EAK7B,EAAEE,EAAQC,GACfK,EAAcP,EAASO,EAAaR,EAAME,CAAK,EAAGA,EAAOF,CAAK,EAEhE,OAAOQ,CACT,CAWA,SAASE,GAAUC,EAAGV,EAAU,CAI9B,QAHIC,EAAQ,GACRU,EAAS,MAAMD,CAAC,EAEb,EAAET,EAAQS,GACfC,EAAOV,CAAK,EAAID,EAASC,CAAK,EAEhC,OAAOU,CACT,CAUA,SAASC,GAASC,EAAQtF,EAAK,CAC7B,OAAoCsF,IAAOtF,CAAG,CAChD,CASA,SAASuF,GAAa7G,EAAO,CAG3B,IAAI0G,EAAS,GACb,GAAI1G,GAAS,MAAQ,OAAOA,EAAM,UAAY,WAC5C,GAAI,CACF0G,EAAS,CAAC,EAAE1G,EAAQ,GACrB,MAAW,CAAA,CAEd,OAAO0G,CACT,CASA,SAASI,GAAWrB,EAAK,CACvB,IAAIO,EAAQ,GACRU,EAAS,MAAMjB,EAAI,IAAI,EAE3B,OAAAA,EAAI,QAAQ,SAASzF,EAAOsB,EAAK,CAC/BoF,EAAO,EAAEV,CAAK,EAAI,CAAC1E,EAAKtB,CAAK,CACjC,CAAG,EACM0G,CACT,CAUA,SAASK,GAAQC,EAAMC,EAAW,CAChC,OAAO,SAASC,EAAK,CACnB,OAAOF,EAAKC,EAAUC,CAAG,CAAC,CAC3B,CACH,CASA,SAASC,GAAWvB,EAAK,CACvB,IAAII,EAAQ,GACRU,EAAS,MAAMd,EAAI,IAAI,EAE3B,OAAAA,EAAI,QAAQ,SAAS5F,EAAO,CAC1B0G,EAAO,EAAEV,CAAK,EAAIhG,CACtB,CAAG,EACM0G,CACT,CAGA,IAAIU,GAAa,MAAM,UACnBC,GAAY,SAAS,UACrBC,GAAc,OAAO,UAGrBC,GAAarC,EAAK,oBAAoB,EAGtCsC,GAAc,UAAW,CAC3B,IAAIC,EAAM,SAAS,KAAKF,IAAcA,GAAW,MAAQA,GAAW,KAAK,UAAY,EAAE,EACvF,OAAOE,EAAO,iBAAmBA,EAAO,EAC1C,IAGIC,GAAeL,GAAU,SAGzBM,EAAiBL,GAAY,eAO7BM,GAAiBN,GAAY,SAG7BO,GAAa,OAAO,IACtBH,GAAa,KAAKC,CAAc,EAAE,QAAQjD,GAAc,MAAM,EAC7D,QAAQ,yDAA0D,OAAO,EAAI,GAC/E,EAGGoD,GAASvC,GAAgBL,EAAK,OAAS,OACvC6C,GAAS7C,EAAK,OACd8C,GAAa9C,EAAK,WAClB+C,GAAelB,GAAQ,OAAO,eAAgB,MAAM,EACpDmB,GAAe,OAAO,OACtBC,GAAuBb,GAAY,qBACnCc,GAAShB,GAAW,OAGpBiB,GAAmB,OAAO,sBAC1BC,GAAiBR,GAASA,GAAO,SAAW,OAC5CS,GAAaxB,GAAQ,OAAO,KAAM,MAAM,EAGxCyB,GAAWC,EAAUvD,EAAM,UAAU,EACrCwD,EAAMD,EAAUvD,EAAM,KAAK,EAC3ByD,GAAUF,EAAUvD,EAAM,SAAS,EACnC0D,GAAMH,EAAUvD,EAAM,KAAK,EAC3B2D,GAAUJ,EAAUvD,EAAM,SAAS,EACnC4D,EAAeL,EAAU,OAAQ,QAAQ,EAGzCM,GAAqBC,EAASR,EAAQ,EACtCS,GAAgBD,EAASN,CAAG,EAC5BQ,GAAoBF,EAASL,EAAO,EACpCQ,GAAgBH,EAASJ,EAAG,EAC5BQ,GAAoBJ,EAASH,EAAO,EAGpCQ,GAActB,GAASA,GAAO,UAAY,OAC1CuB,GAAgBD,GAAcA,GAAY,QAAU,OASxD,SAASE,EAAKC,EAAS,CACrB,IAAIxD,EAAQ,GACRC,EAASuD,EAAUA,EAAQ,OAAS,EAGxC,IADA,KAAK,MAAO,EACL,EAAExD,EAAQC,GAAQ,CACvB,IAAIwD,EAAQD,EAAQxD,CAAK,EACzB,KAAK,IAAIyD,EAAM,CAAC,EAAGA,EAAM,CAAC,CAAC,CAC/B,CACA,CASA,SAASC,IAAY,CACnB,KAAK,SAAWZ,EAAeA,EAAa,IAAI,EAAI,CAAE,CACxD,CAYA,SAASa,GAAWrI,EAAK,CACvB,OAAO,KAAK,IAAIA,CAAG,GAAK,OAAO,KAAK,SAASA,CAAG,CAClD,CAWA,SAASsI,GAAQtI,EAAK,CACpB,IAAIuI,EAAO,KAAK,SAChB,GAAIf,EAAc,CAChB,IAAIpC,EAASmD,EAAKvI,CAAG,EACrB,OAAOoF,IAAW7D,EAAiB,OAAY6D,CACnD,CACE,OAAOiB,EAAe,KAAKkC,EAAMvI,CAAG,EAAIuI,EAAKvI,CAAG,EAAI,MACtD,CAWA,SAASwI,GAAQxI,EAAK,CACpB,IAAIuI,EAAO,KAAK,SAChB,OAAOf,EAAee,EAAKvI,CAAG,IAAM,OAAYqG,EAAe,KAAKkC,EAAMvI,CAAG,CAC/E,CAYA,SAASyI,GAAQzI,EAAKtB,EAAO,CAC3B,IAAI6J,EAAO,KAAK,SAChB,OAAAA,EAAKvI,CAAG,EAAKwH,GAAgB9I,IAAU,OAAa6C,EAAiB7C,EAC9D,IACT,CAGAuJ,EAAK,UAAU,MAAQG,GACvBH,EAAK,UAAU,OAAYI,GAC3BJ,EAAK,UAAU,IAAMK,GACrBL,EAAK,UAAU,IAAMO,GACrBP,EAAK,UAAU,IAAMQ,GASrB,SAASC,EAAUR,EAAS,CAC1B,IAAIxD,EAAQ,GACRC,EAASuD,EAAUA,EAAQ,OAAS,EAGxC,IADA,KAAK,MAAO,EACL,EAAExD,EAAQC,GAAQ,CACvB,IAAIwD,EAAQD,EAAQxD,CAAK,EACzB,KAAK,IAAIyD,EAAM,CAAC,EAAGA,EAAM,CAAC,CAAC,CAC/B,CACA,CASA,SAASQ,IAAiB,CACxB,KAAK,SAAW,CAAE,CACpB,CAWA,SAASC,GAAgB5I,EAAK,CAC5B,IAAIuI,EAAO,KAAK,SACZ7D,EAAQmE,GAAaN,EAAMvI,CAAG,EAElC,GAAI0E,EAAQ,EACV,MAAO,GAET,IAAIoE,EAAYP,EAAK,OAAS,EAC9B,OAAI7D,GAASoE,EACXP,EAAK,IAAK,EAEVzB,GAAO,KAAKyB,EAAM7D,EAAO,CAAC,EAErB,EACT,CAWA,SAASqE,GAAa/I,EAAK,CACzB,IAAIuI,EAAO,KAAK,SACZ7D,EAAQmE,GAAaN,EAAMvI,CAAG,EAElC,OAAO0E,EAAQ,EAAI,OAAY6D,EAAK7D,CAAK,EAAE,CAAC,CAC9C,CAWA,SAASsE,GAAahJ,EAAK,CACzB,OAAO6I,GAAa,KAAK,SAAU7I,CAAG,EAAI,EAC5C,CAYA,SAASiJ,GAAajJ,EAAKtB,EAAO,CAChC,IAAI6J,EAAO,KAAK,SACZ7D,EAAQmE,GAAaN,EAAMvI,CAAG,EAElC,OAAI0E,EAAQ,EACV6D,EAAK,KAAK,CAACvI,EAAKtB,CAAK,CAAC,EAEtB6J,EAAK7D,CAAK,EAAE,CAAC,EAAIhG,EAEZ,IACT,CAGAgK,EAAU,UAAU,MAAQC,GAC5BD,EAAU,UAAU,OAAYE,GAChCF,EAAU,UAAU,IAAMK,GAC1BL,EAAU,UAAU,IAAMM,GAC1BN,EAAU,UAAU,IAAMO,GAS1B,SAASC,EAAShB,EAAS,CACzB,IAAIxD,EAAQ,GACRC,EAASuD,EAAUA,EAAQ,OAAS,EAGxC,IADA,KAAK,MAAO,EACL,EAAExD,EAAQC,GAAQ,CACvB,IAAIwD,EAAQD,EAAQxD,CAAK,EACzB,KAAK,IAAIyD,EAAM,CAAC,EAAGA,EAAM,CAAC,CAAC,CAC/B,CACA,CASA,SAASgB,IAAgB,CACvB,KAAK,SAAW,CACd,KAAQ,IAAIlB,EACZ,IAAO,IAAKb,GAAOsB,GACnB,OAAU,IAAIT,CACf,CACH,CAWA,SAASmB,GAAepJ,EAAK,CAC3B,OAAOqJ,GAAW,KAAMrJ,CAAG,EAAE,OAAUA,CAAG,CAC5C,CAWA,SAASsJ,GAAYtJ,EAAK,CACxB,OAAOqJ,GAAW,KAAMrJ,CAAG,EAAE,IAAIA,CAAG,CACtC,CAWA,SAASuJ,GAAYvJ,EAAK,CACxB,OAAOqJ,GAAW,KAAMrJ,CAAG,EAAE,IAAIA,CAAG,CACtC,CAYA,SAASwJ,GAAYxJ,EAAKtB,EAAO,CAC/B,OAAA2K,GAAW,KAAMrJ,CAAG,EAAE,IAAIA,EAAKtB,CAAK,EAC7B,IACT,CAGAwK,EAAS,UAAU,MAAQC,GAC3BD,EAAS,UAAU,OAAYE,GAC/BF,EAAS,UAAU,IAAMI,GACzBJ,EAAS,UAAU,IAAMK,GACzBL,EAAS,UAAU,IAAMM,GASzB,SAASC,EAAMvB,EAAS,CACtB,KAAK,SAAW,IAAIQ,EAAUR,CAAO,CACvC,CASA,SAASwB,IAAa,CACpB,KAAK,SAAW,IAAIhB,CACtB,CAWA,SAASiB,GAAY3J,EAAK,CACxB,OAAO,KAAK,SAAS,OAAUA,CAAG,CACpC,CAWA,SAAS4J,GAAS5J,EAAK,CACrB,OAAO,KAAK,SAAS,IAAIA,CAAG,CAC9B,CAWA,SAAS6J,GAAS7J,EAAK,CACrB,OAAO,KAAK,SAAS,IAAIA,CAAG,CAC9B,CAYA,SAAS8J,GAAS9J,EAAKtB,EAAO,CAC5B,IAAIqL,EAAQ,KAAK,SACjB,GAAIA,aAAiBrB,EAAW,CAC9B,IAAIsB,EAAQD,EAAM,SAClB,GAAI,CAAC3C,GAAQ4C,EAAM,OAAS1I,EAAmB,EAC7C,OAAA0I,EAAM,KAAK,CAAChK,EAAKtB,CAAK,CAAC,EAChB,KAETqL,EAAQ,KAAK,SAAW,IAAIb,EAASc,CAAK,CAC9C,CACE,OAAAD,EAAM,IAAI/J,EAAKtB,CAAK,EACb,IACT,CAGA+K,EAAM,UAAU,MAAQC,GACxBD,EAAM,UAAU,OAAYE,GAC5BF,EAAM,UAAU,IAAMG,GACtBH,EAAM,UAAU,IAAMI,GACtBJ,EAAM,UAAU,IAAMK,GAUtB,SAASG,GAAcvL,EAAOwL,EAAW,CAGvC,IAAI9E,EAAU+E,GAAQzL,CAAK,GAAK0L,GAAY1L,CAAK,EAC7CwG,GAAUxG,EAAM,OAAQ,MAAM,EAC9B,CAAE,EAEFiG,EAASS,EAAO,OAChBiF,EAAc,CAAC,CAAC1F,EAEpB,QAAS3E,KAAOtB,EACI2H,EAAe,KAAK3H,EAAOsB,CAAG,GAC5C,EAAEqK,IAAgBrK,GAAO,UAAYsK,GAAQtK,EAAK2E,CAAM,KAC1DS,EAAO,KAAKpF,CAAG,EAGnB,OAAOoF,CACT,CAYA,SAASmF,GAAYjF,EAAQtF,EAAKtB,EAAO,CACvC,IAAI8L,EAAWlF,EAAOtF,CAAG,GACrB,EAAEqG,EAAe,KAAKf,EAAQtF,CAAG,GAAKyK,GAAGD,EAAU9L,CAAK,IACvDA,IAAU,QAAa,EAAEsB,KAAOsF,MACnCA,EAAOtF,CAAG,EAAItB,EAElB,CAUA,SAASmK,GAAarE,EAAOxE,EAAK,CAEhC,QADI2E,EAASH,EAAM,OACZG,KACL,GAAI8F,GAAGjG,EAAMG,CAAM,EAAE,CAAC,EAAG3E,CAAG,EAC1B,OAAO2E,EAGX,MAAO,EACT,CAWA,SAAS+F,GAAWpF,EAAQqF,EAAQ,CAClC,OAAOrF,GAAUsF,GAAWD,EAAQE,GAAKF,CAAM,EAAGrF,CAAM,CAC1D,CAgBA,SAASwF,GAAUpM,EAAOqM,EAAQC,EAAQC,EAAYjL,EAAKsF,EAAQ4F,EAAO,CACxE,IAAI9F,EAIJ,GAHI6F,IACF7F,EAASE,EAAS2F,EAAWvM,EAAOsB,EAAKsF,EAAQ4F,CAAK,EAAID,EAAWvM,CAAK,GAExE0G,IAAW,OACb,OAAOA,EAET,GAAI,CAAC+F,GAASzM,CAAK,EACjB,OAAOA,EAET,IAAI0M,GAAQjB,GAAQzL,CAAK,EACzB,GAAI0M,IAEF,GADAhG,EAASiG,GAAe3M,CAAK,EACzB,CAACqM,EACH,OAAOO,GAAU5M,EAAO0G,CAAM,MAE3B,CACL,IAAImG,EAAMC,EAAO9M,CAAK,EAClB+M,GAASF,GAAOzJ,GAAWyJ,GAAOxJ,EAEtC,GAAI2J,GAAShN,CAAK,EAChB,OAAOiN,GAAYjN,EAAOqM,CAAM,EAElC,GAAIQ,GAAOrJ,IAAaqJ,GAAO9J,GAAYgK,IAAU,CAACnG,EAAS,CAC7D,GAAIC,GAAa7G,CAAK,EACpB,OAAO4G,EAAS5G,EAAQ,CAAE,EAG5B,GADA0G,EAASwG,GAAgBH,GAAS,CAAA,EAAK/M,CAAK,EACxC,CAACqM,EACH,OAAOc,GAAYnN,EAAOgM,GAAWtF,EAAQ1G,CAAK,CAAC,CAE3D,KAAW,CACL,GAAI,CAAC8E,EAAc+H,CAAG,EACpB,OAAOjG,EAAS5G,EAAQ,CAAE,EAE5B0G,EAAS0G,GAAepN,EAAO6M,EAAKT,GAAWC,CAAM,CAC3D,CACA,CAEEG,IAAUA,EAAQ,IAAIzB,GACtB,IAAIsC,GAAUb,EAAM,IAAIxM,CAAK,EAC7B,GAAIqN,GACF,OAAOA,GAIT,GAFAb,EAAM,IAAIxM,EAAO0G,CAAM,EAEnB,CAACgG,GACH,IAAIY,GAAQhB,EAASiB,GAAWvN,CAAK,EAAImM,GAAKnM,CAAK,EAErD,OAAA6F,GAAUyH,IAAStN,EAAO,SAASwN,GAAUlM,GAAK,CAC5CgM,KACFhM,GAAMkM,GACNA,GAAWxN,EAAMsB,EAAG,GAGtBuK,GAAYnF,EAAQpF,GAAK8K,GAAUoB,GAAUnB,EAAQC,EAAQC,EAAYjL,GAAKtB,EAAOwM,CAAK,CAAC,CAC/F,CAAG,EACM9F,CACT,CAUA,SAAS+G,GAAWC,EAAO,CACzB,OAAOjB,GAASiB,CAAK,EAAIxF,GAAawF,CAAK,EAAI,CAAE,CACnD,CAaA,SAASC,GAAe/G,EAAQgH,EAAUC,EAAa,CACrD,IAAInH,EAASkH,EAAShH,CAAM,EAC5B,OAAO6E,GAAQ7E,CAAM,EAAIF,EAASR,GAAUQ,EAAQmH,EAAYjH,CAAM,CAAC,CACzE,CASA,SAASkH,GAAW9N,EAAO,CACzB,OAAO4H,GAAe,KAAK5H,CAAK,CAClC,CAUA,SAAS+N,GAAa/N,EAAO,CAC3B,GAAI,CAACyM,GAASzM,CAAK,GAAKgO,GAAShO,CAAK,EACpC,MAAO,GAET,IAAIiO,EAAWC,GAAWlO,CAAK,GAAK6G,GAAa7G,CAAK,EAAK6H,GAAajD,GACxE,OAAOqJ,EAAQ,KAAKjF,EAAShJ,CAAK,CAAC,CACrC,CASA,SAASmO,GAASvH,EAAQ,CACxB,GAAI,CAACwH,GAAYxH,CAAM,EACrB,OAAO2B,GAAW3B,CAAM,EAE1B,IAAIF,EAAS,CAAE,EACf,QAASpF,KAAO,OAAOsF,CAAM,EACvBe,EAAe,KAAKf,EAAQtF,CAAG,GAAKA,GAAO,eAC7CoF,EAAO,KAAKpF,CAAG,EAGnB,OAAOoF,CACT,CAUA,SAASuG,GAAYoB,EAAQhC,EAAQ,CACnC,GAAIA,EACF,OAAOgC,EAAO,MAAO,EAEvB,IAAI3H,EAAS,IAAI2H,EAAO,YAAYA,EAAO,MAAM,EACjD,OAAAA,EAAO,KAAK3H,CAAM,EACXA,CACT,CASA,SAAS4H,GAAiBC,EAAa,CACrC,IAAI7H,EAAS,IAAI6H,EAAY,YAAYA,EAAY,UAAU,EAC/D,WAAIvG,GAAWtB,CAAM,EAAE,IAAI,IAAIsB,GAAWuG,CAAW,CAAC,EAC/C7H,CACT,CAUA,SAAS8H,GAAcC,EAAUpC,EAAQ,CACvC,IAAIgC,EAAShC,EAASiC,GAAiBG,EAAS,MAAM,EAAIA,EAAS,OACnE,OAAO,IAAIA,EAAS,YAAYJ,EAAQI,EAAS,WAAYA,EAAS,UAAU,CAClF,CAWA,SAASC,GAASjJ,EAAK4G,EAAQsC,EAAW,CACxC,IAAI7I,EAAQuG,EAASsC,EAAU7H,GAAWrB,CAAG,EAAG,EAAI,EAAIqB,GAAWrB,CAAG,EACtE,OAAOY,GAAYP,EAAON,GAAa,IAAIC,EAAI,WAAW,CAC5D,CASA,SAASmJ,GAAYC,EAAQ,CAC3B,IAAInI,EAAS,IAAImI,EAAO,YAAYA,EAAO,OAAQlK,GAAQ,KAAKkK,CAAM,CAAC,EACvE,OAAAnI,EAAO,UAAYmI,EAAO,UACnBnI,CACT,CAWA,SAASoI,GAASlJ,EAAKyG,EAAQsC,EAAW,CACxC,IAAI7I,EAAQuG,EAASsC,EAAUxH,GAAWvB,CAAG,EAAG,EAAI,EAAIuB,GAAWvB,CAAG,EACtE,OAAOS,GAAYP,EAAOH,GAAa,IAAIC,EAAI,WAAW,CAC5D,CASA,SAASmJ,GAAYC,EAAQ,CAC3B,OAAO1F,GAAgB,OAAOA,GAAc,KAAK0F,CAAM,CAAC,EAAI,CAAE,CAChE,CAUA,SAASC,GAAgBC,EAAY7C,EAAQ,CAC3C,IAAIgC,EAAShC,EAASiC,GAAiBY,EAAW,MAAM,EAAIA,EAAW,OACvE,OAAO,IAAIA,EAAW,YAAYb,EAAQa,EAAW,WAAYA,EAAW,MAAM,CACpF,CAUA,SAAStC,GAAUX,EAAQnG,EAAO,CAChC,IAAIE,EAAQ,GACRC,EAASgG,EAAO,OAGpB,IADAnG,IAAUA,EAAQ,MAAMG,CAAM,GACvB,EAAED,EAAQC,GACfH,EAAME,CAAK,EAAIiG,EAAOjG,CAAK,EAE7B,OAAOF,CACT,CAYA,SAASoG,GAAWD,EAAQqB,EAAO1G,EAAQ2F,EAAY,CACrD3F,IAAWA,EAAS,IAKpB,QAHIZ,EAAQ,GACRC,EAASqH,EAAM,OAEZ,EAAEtH,EAAQC,GAAQ,CACvB,IAAI3E,EAAMgM,EAAMtH,CAAK,EAEjBmJ,EAEA,OAEJtD,GAAYjF,EAAQtF,EAAK6N,IAAa,OAAYlD,EAAO3K,CAAG,EAAI6N,CAAQ,CAC5E,CACE,OAAOvI,CACT,CAUA,SAASuG,GAAYlB,EAAQrF,EAAQ,CACnC,OAAOsF,GAAWD,EAAQmD,GAAWnD,CAAM,EAAGrF,CAAM,CACtD,CASA,SAAS2G,GAAW3G,EAAQ,CAC1B,OAAO+G,GAAe/G,EAAQuF,GAAMiD,EAAU,CAChD,CAUA,SAASzE,GAAWlF,EAAKnE,EAAK,CAC5B,IAAIuI,EAAOpE,EAAI,SACf,OAAO4J,GAAU/N,CAAG,EAChBuI,EAAK,OAAOvI,GAAO,SAAW,SAAW,MAAM,EAC/CuI,EAAK,GACX,CAUA,SAASpB,EAAU7B,EAAQtF,EAAK,CAC9B,IAAItB,EAAQ2G,GAASC,EAAQtF,CAAG,EAChC,OAAOyM,GAAa/N,CAAK,EAAIA,EAAQ,MACvC,CASA,IAAIoP,GAAa/G,GAAmBtB,GAAQsB,GAAkB,MAAM,EAAIiH,GASpExC,EAASgB,IAIRtF,IAAYsE,EAAO,IAAItE,GAAS,IAAI,YAAY,CAAC,CAAC,CAAC,GAAKxE,IACxD0E,GAAOoE,EAAO,IAAIpE,CAAG,GAAKpF,IAC1BqF,IAAWmE,EAAOnE,GAAQ,QAAS,CAAA,GAAKlF,IACxCmF,IAAOkE,EAAO,IAAIlE,EAAG,GAAKjF,IAC1BkF,IAAWiE,EAAO,IAAIjE,EAAO,GAAK/E,MACrCgJ,EAAS,SAAS9M,EAAO,CACvB,IAAI0G,EAASkB,GAAe,KAAK5H,CAAK,EAClCuP,EAAO7I,GAAUlD,GAAYxD,EAAM,YAAc,OACjDwP,EAAaD,EAAOvG,EAASuG,CAAI,EAAI,OAEzC,GAAIC,EACF,OAAQA,EAAU,CAChB,KAAKzG,GAAoB,OAAO/E,GAChC,KAAKiF,GAAe,OAAO3F,GAC3B,KAAK4F,GAAmB,OAAOzF,GAC/B,KAAK0F,GAAe,OAAOxF,GAC3B,KAAKyF,GAAmB,OAAOtF,EACvC,CAEI,OAAO4C,CACR,GAUH,SAASiG,GAAe7G,EAAO,CAC7B,IAAIG,EAASH,EAAM,OACfY,EAASZ,EAAM,YAAYG,CAAM,EAGrC,OAAIA,GAAU,OAAOH,EAAM,CAAC,GAAK,UAAY6B,EAAe,KAAK7B,EAAO,OAAO,IAC7EY,EAAO,MAAQZ,EAAM,MACrBY,EAAO,MAAQZ,EAAM,OAEhBY,CACT,CASA,SAASwG,GAAgBtG,EAAQ,CAC/B,OAAQ,OAAOA,EAAO,aAAe,YAAc,CAACwH,GAAYxH,CAAM,EAClE6G,GAAWxF,GAAarB,CAAM,CAAC,EAC/B,CAAE,CACR,CAeA,SAASwG,GAAexG,EAAQiG,EAAK8B,EAAWtC,EAAQ,CACtD,IAAIkD,EAAO3I,EAAO,YAClB,OAAQiG,EAAG,CACT,KAAK9I,GACH,OAAOuK,GAAiB1H,CAAM,EAEhC,KAAK3D,EACL,KAAKC,EACH,OAAO,IAAIqM,EAAK,CAAC3I,CAAM,EAEzB,KAAK5C,GACH,OAAOwK,GAAc5H,EAAQyF,CAAM,EAErC,KAAKpI,GAAY,KAAKC,GACtB,KAAKC,GAAS,KAAKC,GAAU,KAAKC,GAClC,KAAKC,GAAU,KAAKC,GAAiB,KAAKC,GAAW,KAAKC,GACxD,OAAOwK,GAAgBrI,EAAQyF,CAAM,EAEvC,KAAK/I,GACH,OAAOoL,GAAS9H,EAAQyF,EAAQsC,CAAS,EAE3C,KAAKpL,GACL,KAAKK,GACH,OAAO,IAAI2L,EAAK3I,CAAM,EAExB,KAAKlD,GACH,OAAOkL,GAAYhI,CAAM,EAE3B,KAAKjD,GACH,OAAOmL,GAASlI,EAAQyF,EAAQsC,CAAS,EAE3C,KAAK9K,GACH,OAAOkL,GAAYnI,CAAM,CAC/B,CACA,CAUA,SAASgF,GAAQ5L,EAAOiG,EAAQ,CAC9B,OAAAA,EAASA,GAAiBnD,EACnB,CAAC,CAACmD,IACN,OAAOjG,GAAS,UAAY6E,GAAS,KAAK7E,CAAK,IAC/CA,EAAQ,IAAMA,EAAQ,GAAK,GAAKA,EAAQiG,CAC7C,CASA,SAASoJ,GAAUrP,EAAO,CACxB,IAAIyP,EAAO,OAAOzP,EAClB,OAAQyP,GAAQ,UAAYA,GAAQ,UAAYA,GAAQ,UAAYA,GAAQ,UACvEzP,IAAU,YACVA,IAAU,IACjB,CASA,SAASgO,GAAShH,EAAM,CACtB,MAAO,CAAC,CAACQ,IAAeA,MAAcR,CACxC,CASA,SAASoH,GAAYpO,EAAO,CAC1B,IAAIuP,EAAOvP,GAASA,EAAM,YACtB0N,EAAS,OAAO6B,GAAQ,YAAcA,EAAK,WAAcjI,GAE7D,OAAOtH,IAAU0N,CACnB,CASA,SAAS1E,EAAShC,EAAM,CACtB,GAAIA,GAAQ,KAAM,CAChB,GAAI,CACF,OAAOU,GAAa,KAAKV,CAAI,CAC9B,MAAW,CAAA,CACZ,GAAI,CACF,OAAQA,EAAO,EAChB,MAAW,CAAA,CAChB,CACE,MAAO,EACT,CAoBA,SAAS0I,GAAU1P,EAAO,CACxB,OAAOoM,GAAUpM,EAAO,GAAM,EAAI,CACpC,CAkCA,SAAS+L,GAAG/L,EAAO2P,EAAO,CACxB,OAAO3P,IAAU2P,GAAU3P,IAAUA,GAAS2P,IAAUA,CAC1D,CAoBA,SAASjE,GAAY1L,EAAO,CAE1B,OAAO4P,GAAkB5P,CAAK,GAAK2H,EAAe,KAAK3H,EAAO,QAAQ,IACnE,CAACmI,GAAqB,KAAKnI,EAAO,QAAQ,GAAK4H,GAAe,KAAK5H,CAAK,GAAK+C,EAClF,CAyBA,IAAI0I,GAAU,MAAM,QA2BpB,SAASoE,GAAY7P,EAAO,CAC1B,OAAOA,GAAS,MAAQ8P,GAAS9P,EAAM,MAAM,GAAK,CAACkO,GAAWlO,CAAK,CACrE,CA2BA,SAAS4P,GAAkB5P,EAAO,CAChC,OAAO+P,GAAa/P,CAAK,GAAK6P,GAAY7P,CAAK,CACjD,CAmBA,IAAIgN,GAAW1E,IAAkB0H,GAmBjC,SAAS9B,GAAWlO,EAAO,CAGzB,IAAI6M,EAAMJ,GAASzM,CAAK,EAAI4H,GAAe,KAAK5H,CAAK,EAAI,GACzD,OAAO6M,GAAOzJ,GAAWyJ,GAAOxJ,CAClC,CA4BA,SAASyM,GAAS9P,EAAO,CACvB,OAAO,OAAOA,GAAS,UACrBA,EAAQ,IAAMA,EAAQ,GAAK,GAAKA,GAAS8C,CAC7C,CA2BA,SAAS2J,GAASzM,EAAO,CACvB,IAAIyP,EAAO,OAAOzP,EAClB,MAAO,CAAC,CAACA,IAAUyP,GAAQ,UAAYA,GAAQ,WACjD,CA0BA,SAASM,GAAa/P,EAAO,CAC3B,MAAO,CAAC,CAACA,GAAS,OAAOA,GAAS,QACpC,CA8BA,SAASmM,GAAKvF,EAAQ,CACpB,OAAOiJ,GAAYjJ,CAAM,EAAI2E,GAAc3E,CAAM,EAAIuH,GAASvH,CAAM,CACtE,CAoBA,SAAS0I,IAAY,CACnB,MAAO,CAAE,CACX,CAeA,SAASU,IAAY,CACnB,MAAO,EACT,CAEA1K,EAAA,QAAiBoK,uDC15CV,MAAMO,CAAkC,CAa7C,YAAY,CACV,OAAAC,EACA,SAAAC,EACA,KAAAC,EACA,SAAAC,EACA,QAAAC,EACA,OAAAC,EACA,QAAAC,EACA,UAAAC,EACA,UAAAC,EACA,UAAAC,EACA,UAAAC,CAAA,EACuB,CACvB,KAAK,OAASV,EACd,KAAK,SAAWC,EAChB,KAAK,KAAOC,EACZ,KAAK,SAAWC,EAChB,KAAK,QAAUC,EACf,KAAK,OAASC,EACd,KAAK,QAAUC,EACf,KAAK,UAAYC,EACjB,KAAK,UAAYC,EACjB,KAAK,UAAYC,EACjB,KAAK,UAAYC,EAEV,OAAA,OAAO,KAAK,SAAS,EACrB,OAAA,OAAO,KAAK,UAAU,QAAQ,EAC9B,OAAA,OAAO,KAAK,UAAU,QAAQ,EAC9B,OAAA,OAAO,KAAK,UAAU,MAAM,EACnC,OAAO,OAAO,IAAI,CAAA,CAGpB,IAAI,WAAqB,CAChB,OAAA,KAAK,SAAW5O,EAAkB,aAAA,CAG3C,IAAI,WAAqB,CAChB,OAAA,KAAK,SAAWA,EAAkB,aAAA,CAG3C,IAAI,WAAgC,CAClC,OAAO,KAAK,UAAY,KAAK,WAAW,SAAW,MAAA,CAGrD,IAAI,WAAgC,CAClC,OAAO,KAAK,UAAY,KAAK,WAAW,SAAW,MAAA,CAGrD,IAAI,WAA8B,CACzB,OAAA,KAAK,UAAY,KAAK,UAAY,MAAA,CAG3C,IAAI,WAA8B,CACzB,OAAA,KAAK,UAAY,KAAK,UAAY,MAAA,CAG3C,iBAAiB9C,EAA2B,CAC1C,OAAK,KAAK,MAAMA,CAAO,EAIhB,KAAK,QAAUA,EAAQ,QAHrB,EAGqB,CAGhC,iBAAiBA,EAA2B,CAC1C,OAAK,KAAK,MAAMA,CAAO,EAIhB,KAAK,QAAUA,EAAQ,QAHrB,EAGqB,CAGhC,gBAAgBA,EAA2B,CACzC,OAAK,KAAK,MAAMA,CAAO,EAIhB,KAAK,UAAYA,EAAQ,QAHvB,EAGuB,CAGlC,OAAOA,EAA2B,CACzB,OAAA,KAAK,OAASA,EAAQ,MAAA,CAG/B,MAAMA,EAA2B,CACxB,OAAA,KAAK,OAASA,EAAQ,MAAA,CAG/B,MAAMA,EAA2B,CACxB,OAAA,KAAK,SAAWA,EAAQ,MAAA,CAGjC,SAASA,EAA2B,CAC3B,OAAA,KAAK,MAAMA,CAAO,CAAA,CAG3B,KAAK2R,EAA0E,CAE7E,GAAI,WAAYA,EACP,OAAA,KAAK,yBAAyBA,CAAK,EAIxC,GAAAA,EAAM,OAAShP,EAAqB,QACtC,MAAM,IAAI/B,EAAK,UAAU,4CAA6C,IAAO,GAAG,EAI9E,GAAA+Q,EAAM,OAASpO,EAAyB,QAAS,CACnD,GAAIoO,EAAM,QAAQ,gBAAkB,KAAK,OACvC,MAAM,IAAI/Q,EAAK,UAAU,6CAA8C,IAAO,GAAG,EAGnF,MAAMgR,EAAiC,CACrC,OAAQpB,EAAUmB,EAAM,QAAQ,MAAM,EACtC,SAAUnB,EAAUmB,EAAM,QAAQ,QAAQ,EAC1C,SAAUnB,EAAUmB,EAAM,QAAQ,QAAQ,CAC5C,EAEA,OAAOZ,EAAe,OAAO,KAAM,CAAE,UAAWa,EAAc,CAAA,CAIzD,OAAA,KAAK,yBAAyBD,EAAM,OAAO,CAAA,CAU5C,yBAAyB3R,EAA2B,CAEtD,GAAAA,EAAQ,SAAW,KAAK,OAC1B,MAAM,IAAIY,EAAK,UAAU,6CAA8C,IAAO,GAAG,EAI/E,OAAA,KAAK,SAAWZ,EAAQ,QACnB,KAKF+Q,EAAe,OAAO/Q,EAAS,CAAE,UAAW,KAAK,UAAW,CAAA,CAIrE,OAAe,OAAO+M,EAAiB8E,EAA4C,CACjF,OAAO,IAAId,EAAe,CACxB,OAAQc,GAAS,QAAU9E,EAAO,OAClC,SAAU8E,GAAS,UAAY9E,EAAO,SACtC,KAAM8E,GAAS,MAAQ9E,EAAO,KAC9B,SAAU8E,GAAS,UAAYrB,EAAUzD,EAAO,QAAQ,EACxD,QAAS8E,GAAS,SAAWrB,EAAUzD,EAAO,OAAO,EACrD,OAAQ8E,GAAS,QAAU9E,EAAO,OAClC,QAAS8E,GAAS,SAAW9E,EAAO,QACpC,UAAW8E,GAAS,WAAa9E,EAAO,UACxC,UAAW8E,GAAS,WAAa9E,EAAO,UACxC,UAAW8E,GAAS,WAAarB,EAAUzD,EAAO,SAAS,EAC3D,UAAW8E,GAAS,WAAarB,EAAUzD,EAAO,SAAS,CAAA,CAC5D,CAAA,CAGH,KAAK+E,EAA4B,GAAa,CACrC,OAAAf,EAAe,OAAO,KAAMe,CAAM,CAAA,CAE7C,CAEO,SAASC,IAA0C,CACjD,MAAA,CACL,OAAQ,CAAC,EACT,SAAU,CAAC,EACX,SAAU,CAAA,CACZ,CACF,CCxda,MAAAC,GAAgBC,GAAiD,CAC5E,MAAMjS,EAAUiS,EAEZ,GAAA,CAACjS,EAAQ,KACX,MAAM,IAAIY,EAAK,UAAU,yCAA0C,IAAO,GAAG,EAG3E,GAAA,CAACZ,EAAQ,SACX,MAAM,IAAIY,EAAK,UAAU,6CAA8C,IAAO,GAAG,EAG/E,GAAA,CAACZ,EAAQ,OACX,MAAM,IAAIY,EAAK,UAAU,2CAA4C,IAAO,GAAG,EAIjF,GAAIZ,EAAQ,SAAW8C,EAAkB,eAAiB9C,EAAQ,KAAK,OAAS,OAC9E,MAAM,IAAIY,EAAK,UAAU,yCAA0C,IAAO,GAAG,EAI/E,GAAIZ,EAAQ,SAAW8C,EAAkB,eAAiB,CAAC9C,EAAQ,OAAO,QACxE,MAAM,IAAIY,EAAK,UAAU,4CAA6C,IAAO,GAAG,EAIlF,GAAIZ,EAAQ,SAAW8C,EAAkB,eAAiB,CAAC9C,EAAQ,KAAK,SACtE,MAAM,IAAIY,EAAK,UAAU,6CAA8C,IAAO,GAAG,EAG/E,GAAA,CAACZ,EAAQ,OACX,MAAM,IAAIY,EAAK,UAAU,2CAA4C,IAAO,GAAG,EAG7E,GAAA,CAACZ,EAAQ,QACX,MAAM,IAAIY,EAAK,UAAU,4CAA6C,IAAO,GAAG,EAG9E,GAAA,CAACZ,EAAQ,UACX,MAAM,IAAIY,EAAK,UAAU,8CAA+C,IAAO,GAAG,EAGhF,GAAA,CAACZ,EAAQ,UACX,MAAM,IAAIY,EAAK,UAAU,8CAA+C,IAAO,GAAG,EAGpF,OAAQZ,EAAQ,OAAQ,CACtB,KAAK8C,EAAkB,cACvB,KAAKA,EAAkB,cACvB,KAAKA,EAAkB,cACrB,MAEF,QACQ,MAAA,IAAIlC,EAAK,UAAU,oDAAoDZ,EAAQ,MAAM,GAAI,IAAO,GAAG,CAC3G,CAIF,MAAM2K,EAAO3K,EAAQ,SAAW8C,EAAkB,cAAgB,CAAA,EAAK9C,EAAQ,KACzEkS,EAASlS,EAAQ,SAAW8C,EAAkB,cAAgB,CAAA,EAAK9C,EAAQ,OAEjF,OAAO,IAAI+Q,EAAe,CACxB,OAAQ/Q,EAAQ,OAChB,SAAUA,EAAQ,SAClB,KAAM2K,EAAK,MAAQ,GACnB,SAAUA,EAAK,UAAY,CAAC,EAC5B,QAASuH,EAAO,SAAW,CAAC,EAC5B,OAAQlS,EAAQ,OAChB,QAASA,EAAQ,QACjB,UAAW,IAAI,KAAKA,EAAQ,SAAS,EACrC,UAAW,IAAI,KAAKA,EAAQ,SAAS,EACrC,UAAW+R,GAAsB,EACjC,UAAW/R,EAAQ,SAAA,CACpB,CACH,EC3EamS,GAAkBnB,GAA2B,CACxD,IAAIoB,EAAe,GACf,GAAA,OAAOpB,GAAW,SACLoB,EAAApB,MAEX,IAAA,CACE,WAAYA,IACdoB,EAAepB,EAAO,OACxB,MACM,CAAA,CAKV,GAAIoB,IAAiB,GACnB,MAAM,IAAIxR,EAAK,UAAU,gEAAiE,IAAO,GAAG,EAG/F,OAAAwR,CACT,ECoEMC,GAAkG,CACtG,oBAAqB9O,EAAyB,OAC9C,oBAAqBA,EAAyB,MAChD,EAKO,MAAM+O,EAAqD,CAShE,YACmBC,EACAC,EACAC,EACAC,EACAC,EACjB,CALiB,KAAA,QAAAJ,EACA,KAAA,SAAAC,EACA,KAAA,KAAAC,EACA,KAAA,UAAAC,EACA,KAAA,SAAAC,EAbX,KAAA,SAAW,IAAIzR,EAehByR,EAAS,UAAU,KAAK,qBAAqB,KAAK,IAAI,CAAC,EACxD,KAAK,UAAU,qBACZA,EAAS,YAAY,UAAU,KAAK,wBAAwB,KAAK,IAAI,CAAC,EAE7E,KAAK,aAAe,KAAK,UAAU,4BAA8BvP,EAAoB,QAAA,CAG/E,wBAAwBuO,EAAwB,CAGlD,GAFJ,KAAK,QAAQ,MAAM,+CAAgD,CAAE,MAAAA,EAAO,EAExE,CAACA,EAAM,cAAe,CACxB,KAAK,QAAQ,KACX,+FACA,CACE,MAAAA,CAAA,CAEJ,EACA,MAAA,CAGI,MAAAiB,EAAetP,GAA6BqO,EAAM,IAAI,EAG5D,GAAI,CAACiB,EAAc,CACZ,KAAA,QAAQ,MAAM,sFAAuF,CACxG,MAAAjB,CAAA,CACD,EACD,MAAA,CAGI,MAAAkB,EAAYR,GAAaV,EAAM,MAAM,EAC3C,GAAI,CAACkB,EAAW,CAET,KAAA,QAAQ,KAAK,wFAAyF,CACzG,MAAAlB,CAAA,CACD,EACD,MAAA,CAGF,IAAImB,EAAOnB,EAAM,KACjB,GAAI,CAACmB,EACH,GAAID,IAActP,EAAyB,QAAUqP,IAAiBxP,EAAoB,OAEjF0P,EAAA,OAEP,QAIJ,MAAMC,EAAyC,CAC7C,KAAMF,EACN,UAAW,IAAI,KAAKlB,EAAM,SAAS,EACnC,SAAU,CACR,cAAeA,EAAM,cACrB,KAAMiB,EACN,KAAAE,EACA,SAAUnB,EAAM,UAAY,EAAA,CAEhC,EACIA,EAAM,MACMoB,EAAA,SAAS,MAAQpB,EAAM,MAC5BkB,IAActP,EAAyB,QAAUqP,IAAiBxP,EAAoB,WAC/F2P,EAAc,SAAS,MAAQ,GAE5B,KAAA,SAAS,KAAKF,EAAWE,CAAa,CAAA,CAGrC,qBAAqBpB,EAA4B,CAInD,GAHJ,KAAK,QAAQ,MAAM,4CAA6C,CAAE,MAAAA,EAAO,EAGrEA,EAAM,SAAW7O,EAAkB,yBACrC,OASE,GAPC6O,EAAM,UAGTA,EAAM,QAAU,CAAC,GAIf,CAACA,EAAM,OAAQ,CACZ,KAAA,QAAQ,KAAK,kFAAmF,CACnG,MAAAA,CAAA,CACD,EACD,MAAA,CAGF,MAAMqB,EAAUrB,EAAM,QAAQtO,EAAuB,MAAM,GAAK,CAAC,EAC3D4P,EAAYtB,EAAM,QAAQtO,EAAuB,QAAQ,GAAK,CAAC,EAC/D6P,EAAYvB,EAAM,QAAQtO,EAAuB,QAAQ,GAAK,CAAC,EAEhE,KAAA,SAAS,KAAKE,EAAyB,QAAS,CACnD,KAAMA,EAAyB,QAC/B,QAAS,CACP,cAAeoO,EAAM,OACrB,OAAAqB,EACA,SAAAC,EACA,SAAAC,CAAA,CACF,CACD,CAAA,CAMH,KAAKC,EAAuBrB,EAAiD,CAC3E,KAAK,QAAQ,MAAM,2BAA4B,CAAE,cAAAqB,EAAe,OAAArB,EAAQ,EAClE,MAAAd,EAASmB,GAAegB,CAAa,EAEvC,GAAA,CAAE,KAAA5C,EAAM,MAAA6C,CAAA,EAAUtB,EACjBvB,IACHA,EAAO,KAAK,cAEVA,IAASnN,EAAoB,UAAY,CAACgQ,IACpCA,EAAA,GAEV,MAAMC,EAAyC,CAAE,KAAA9C,EAAM,KAAMuB,EAAO,IAAK,EACzE,OAAIsB,IACFC,EAAU,MAAQD,GAEb,KAAK,KAAK,mBAAmB,KAAK,UAAWpC,EAAQqC,CAAS,CAAA,CAMvE,OAAOF,EAAuBrB,EAAqD,CACjF,KAAK,QAAQ,MAAM,8BAA+B,CAAE,cAAAqB,EAAe,OAAArB,EAAQ,EACrE,MAAAd,EAASmB,GAAegB,CAAa,EAE3C,IAAI5C,EAAOuB,GAAQ,KAInB,GAHKvB,IACHA,EAAO,KAAK,cAEVA,IAASnN,EAAoB,QAAU,CAAC0O,GAAQ,KAClD,MAAM,IAAIlR,EAAK,UAAU,kCAAkC2P,CAAI,kBAAmB,MAAO,GAAG,EAExF,MAAA8C,EAA4C,CAAE,KAAA9C,CAAK,EACrD,OAAAA,IAASnN,EAAoB,SAC/BiQ,EAAU,KAAOvB,GAAQ,MAEpB,KAAK,KAAK,sBAAsB,KAAK,UAAWd,EAAQqC,CAAS,CAAA,CAM1E,UAAUxR,EAAiD,CACpD,KAAA,QAAQ,MAAM,gCAAgC,EAE7C,MAAAC,EAAUX,EAAKU,CAAQ,EAC7B,YAAK,SAAS,GAAG0B,EAAyB,QAASzB,CAAO,EACnD,CACL,YAAa,IAAM,CACZ,KAAA,SAAS,IAAIA,CAAO,CAAA,CAE7B,CAAA,CAMF,aAAaD,EAAoD,CAG3D,GAFC,KAAA,QAAQ,MAAM,mCAAmC,EAElD,CAAC,KAAK,UAAU,oBAClB,MAAM,IAAIjB,EAAK,UAAU,wCAAyC,MAAO,GAAG,EAExE,MAAAkB,EAAUX,EAAKU,CAAQ,EACxB,YAAA,SAAS,GAAG,CAAC0B,EAAyB,OAAQA,EAAyB,MAAM,EAAGzB,CAAO,EACrF,CACL,YAAa,IAAM,CACZ,KAAA,SAAS,IAAIA,CAAO,CAAA,CAE7B,CAAA,CASF,OAAO,oBAAoBwR,EAAwD,CACjF,OAAQhT,IAEDA,EAAQ,MAAM,SAAS,oBAAoB,GACtCA,EAAA,MAAM,KAAK,oBAAoB,EAGrCgT,EAAY,SAAS,qBAAuB,CAAChT,EAAQ,MAAM,SAAS,sBAAsB,GACpFA,EAAA,MAAM,KAAK,sBAAsB,EAEpCA,EACT,CAEJ,CC/Ra,MAAAiT,GAAmBvT,GAAkC,CAChE,MAAMyR,EAAY,CAChB,GAAGM,GAAsB,EACzB,GAAG/R,EAAQ,SACb,EAGMqR,EAAS,OAAO,OAAOvO,CAAiB,EAAE,SAAS9C,EAAQ,MAA2B,EACvFA,EAAQ,OACT8C,EAAkB,cAEtB,OAAO,IAAIiO,EAAe,CACxB,GAAG/Q,EACH,OAAAqR,EACA,UAAW,IAAI,KAAKrR,EAAQ,SAAS,EACrC,UAAW,IAAI,KAAKA,EAAQ,SAAS,EACrC,UAAAyR,CAAA,CACD,CACH,ECnCM+B,OAA8E,IAGlF,CACA,CAAC1Q,EAAkB,cAAeH,EAAqB,OAAO,EAC9D,CAACG,EAAkB,cAAeH,EAAqB,OAAO,EAC9D,CAACG,EAAkB,cAAeH,EAAqB,OAAO,CAChE,CAAC,EAKW,IAAA8Q,IAAAA,IAIVA,EAAA,YAAc,cAKdA,EAAA,YAAc,cATJA,IAAAA,IAAA,CAAA,CAAA,EAqQL,MAAMC,EAAoC,CAyB/C,YACEC,EACArT,EACAsT,EACAC,EACA5C,EACAxP,EACA,CAnBe,KAAA,SAAW,IAAIP,EAoB9B,KAAK,UAAYyS,EACjB,KAAK,SAAWrT,EAChB,KAAK,SAAWsT,EAChB,KAAK,SAAWC,EAChB,KAAK,UAAY5C,EACjB,KAAK,QAAUxP,EACV,KAAA,gCAAkC,IAElC,KAAA,UAAY,IAAI6Q,GAAwB,KAAK,QAAShS,EAAS,KAAK,SAAU,KAAK,UAAW,KAAK,QAAQ,EAChH,KAAK,2BAA2B,CAAA,CAM1B,4BAAmC,CAEpC,KAAK,SAAS,UAAU,CAACsC,GAAoB,WAAW,EAAG,KAAK,cAAc,KAAK,IAAI,CAAC,EAI7F,KAAK,SAAS,GAAG,WAAa5C,GAAY,CACnC,KAAA,cAAcA,EAAQ,OAAO,CAAA,CACnC,EAGD,KAAK,SAAS,GAAG,SAAWA,GAAY,CAClCA,EAAQ,UAAY,YAAcA,EAAQ,WAAa,YACpD,KAAA,cAAcA,EAAQ,OAAO,CACpC,CACD,CAAA,CAMH,MAAc,4BACZ6B,EACAiQ,EACmC,CAC9B,KAAA,QAAQ,MAAM,0DAA0D,EAE7E,MAAMgC,EAAoB,KAAK,4BAA4B,IAAIjS,CAAQ,EAEvE,GAAIiS,IAAsB,OACxB,WAAK,QAAQ,MACX,+FACF,EACM,IAAIlT,EAAK,UACb,6DACA,IACA,GACF,EAIF,MAAMmT,EAA0B,MAAMD,EAGtC,OAAO,KAAK,SAAS,YAAY,KAAK,UAAW,CAC/C,GAAGhC,EACH,QAAS,cACT,GAAGiC,CAAA,CACJ,CAAA,CAMK,cAAcC,EAAqB,CAIzC,GAHK,KAAA,QAAQ,MAAM,4CAA4C,EAG3DA,EAAY,OAGV,MAAAC,EAA+B,KAAK,0BAA0B,EACpE,SAAW,CAACpS,CAAQ,IAAK,KAAK,4BAA4B,UACnD,KAAA,4BAA4B,IAAIA,EAAUoS,CAA4B,CAC7E,CAMF,MAAc,2BAEX,CACK,MAAAC,EAAwB,KAAK,sBAAsB,EAGrD,GAAAA,EAAsB,QAAU,WAAY,CAC1C,GAAAA,EAAsB,WAAW,cACnC,MAAO,CAAE,WAAYA,EAAsB,WAAW,aAAc,EAEjE,WAAA,QAAQ,MAAM,uEAAuE,EACpF,IAAItT,EAAK,UAAU,wDAAyD,IAAO,GAAG,CAAA,CAG9F,OAAO,KAAK,0BAA0B,CAAA,CAGhC,uBAEN,CAEA,OAAO,KAAK,QAAA,CAQd,MAAc,2BAA6D,CACnE,MAAAsT,EAAwB,KAAK,sBAAsB,EACzD,OAAO,IAAI,QAAQ,CAACC,EAASC,IAAW,CAElCF,EAAsB,QAAU,aAG7B,KAAA,QAAQ,MAAM,wFAAyF,CAC1G,aAAcA,EAAsB,WAAW,YAAA,CAChD,EACGA,EAAsB,WAAW,aACnCC,EAAQ,CAAE,WAAYD,EAAsB,WAAW,aAAc,GAEhE,KAAA,QAAQ,MAAM,sEAAsE,EACzFE,EACE,IAAIxT,EAAK,UAAU,uDAAwD,IAAO,GAAG,CACvF,IAIkBsT,EAAA,KAAK,WAAY,IAAM,CAGtC,KAAA,QAAQ,MAAM,oFAAqF,CACtG,aAAcA,EAAsB,WAAW,YAAA,CAChD,EACGA,EAAsB,WAAW,aACnCC,EAAQ,CAAE,WAAYD,EAAsB,WAAW,aAAc,GAEhE,KAAA,QAAQ,MAAM,sEAAsE,EACzFE,EACE,IAAIxT,EAAK,UAAU,uDAAwD,IAAO,GAAG,CACvF,EACF,CACD,CAAA,CACF,CAAA,CAMH,MAAM,QAAQN,EAA0D,CACjE,YAAA,QAAQ,MAAM,mBAAmB,EAC/B,KAAK,SAAS,YAAY,KAAK,UAAWA,CAAO,CAAA,CAM1D,MAAM,KAAKwR,EAA6C,CACtD,KAAK,QAAQ,MAAM,mBAAoB,CAAE,OAAAA,EAAQ,EAEjD,KAAM,CAAE,KAAAZ,EAAM,SAAAC,EAAU,QAAAC,CAAY,EAAAU,EAE9BuC,EAAW,MAAM,KAAK,SAAS,YAAY,KAAK,UAAW,CAAE,KAAAnD,EAAM,QAAAE,EAAS,SAAAD,CAAA,CAAU,EAC5F,OAAO,IAAIJ,EAAe,CACxB,OAAQsD,EAAS,OACjB,SAAU,KAAK,UACf,KAAAnD,EACA,SAAUC,GAAY,CAAC,EACvB,QAASC,GAAW,CAAC,EACrB,OAAQtO,EAAkB,cAC1B,QAASuR,EAAS,OAClB,UAAW,IAAI,KAAKA,EAAS,SAAS,EACtC,UAAW,IAAI,KAAKA,EAAS,SAAS,EACtC,UAAWtC,GAAsB,CAAA,CAClC,CAAA,CAMH,MAAM,OAAOf,EAAgBc,EAAgD,CAC3E,KAAK,QAAQ,MAAM,qBAAsB,CAAE,OAAAA,EAAQ,EAEnDd,EAASmB,GAAenB,CAAM,EAC9B,KAAK,QAAQ,MAAM,4BAA6B,CAAE,OAAAA,EAAQ,EACpD,MAAAqD,EAAW,MAAM,KAAK,SAAS,cAAc,KAAK,UAAWrD,EAAQc,CAAM,EAE1E,OAAAyB,GAAgBc,EAAS,OAAO,CAAA,CAMzC,MAAM,OAAOrD,EAAgBsD,EAAmCC,EAA8C,CAC5G,KAAK,QAAQ,MAAM,qBAAsB,CAAE,aAAAD,EAAc,QAAAC,EAAS,EAElEvD,EAASmB,GAAenB,CAAM,EAC9B,KAAK,QAAQ,MAAM,4BAA6B,CAAE,OAAAA,EAAQ,EAC1D,MAAMqD,EAAW,MAAM,KAAK,SAAS,cAAc,KAAK,UAAWrD,EAAQ,CACzE,QAAS,CACP,KAAMsD,EAAa,KACnB,SAAUA,EAAa,SACvB,QAASA,EAAa,OACxB,EACA,GAAGC,CAAA,CACJ,EAED,YAAK,QAAQ,MAAM,iDAAkD,CAAE,aAAAD,EAAc,EAC9Ef,GAAgBc,EAAS,OAAO,CAAA,CAMzC,UAAUxS,EAAwD,CAC3D,KAAA,QAAQ,MAAM,uBAAuB,EACpC,MAAAC,EAAUX,EAAKU,CAAQ,EAC7B,KAAK,SAAS,GACZ,CAACc,EAAqB,QAASA,EAAqB,QAASA,EAAqB,OAAO,EACzFb,CACF,EAGM,MAAA0S,EAA4B,KAAK,0BAA0B,EAGjE,OAAAA,EAA0B,MAAM,IAAM,CAC/B,KAAA,QAAQ,MAAM,wFAAwF,CAAA,CAC5G,EAEI,KAAA,4BAA4B,IAAI1S,EAAS0S,CAAyB,EAEhE,CACL,YAAa,IAAM,CAEZ,KAAA,4BAA4B,OAAO1S,CAAO,EAC1C,KAAA,QAAQ,MAAM,yBAAyB,EACvC,KAAA,SAAS,IAAIA,CAAO,CAC3B,EACA,uBAAyBgQ,GACvB,KAAK,4BAA4BhQ,EAASgQ,CAAM,CACpD,CAAA,CAGM,cAAc2C,EAA0C,CACzD,KAAA,QAAQ,MAAM,4BAA6B,CAC9C,oBAAAA,CAAA,CACD,EACK,KAAA,CAAE,OAAApD,GAAWoD,EACb9C,EAAQ6B,GAA0B,IAAInC,CAA2B,EACvE,GAAI,CAACM,EAAO,CACV,KAAK,QAAQ,MAAM,4DAA6D,CAAE,OAAAN,EAAQ,EAC1F,MAAA,CAGI,MAAArR,EAAU,KAAK,iBAAiByU,CAAmB,EACpDzU,GAIL,KAAK,SAAS,KAAK2R,EAAO,CAAE,KAAMA,EAAO,QAAA3R,EAAkB,CAAA,CAMrD,iBAAiByU,EAA+D,CAClF,GAAA,CACF,OAAOzC,GAAayC,CAAmB,QAChCC,EAAgB,CACvB,KAAK,QAAQ,MAAM,oCAAqC,CAAE,oBAAAD,EAAqB,MAAAC,EAAgC,CAAA,CACjH,CAEJ,CCreO,MAAMC,EAAQ,CAKnB,YAAYC,EAAyBnT,EAAgB,CAFrD,KAAiB,oBAA8B,EAG7C,KAAK,UAAYmT,EACjB,KAAK,QAAUnT,CAAA,CAGjB,MAAM,YAAYkS,EAAkB7B,EAAmE,CACrG6B,EAAW,mBAAmBA,CAAQ,EAGhC,MAAAN,EAAuC,CAAE,GAAGvB,CAAO,EACzD,GAAIA,EAAO,QACT,OAAQA,EAAO,QAAS,CACtB,KAAK2B,GAAQ,YAAa,CACxBJ,EAAU,UAAY,YACtB,KAAA,CAEF,KAAKI,GAAQ,YAAa,CACxBJ,EAAU,UAAY,WACtB,KAAA,CAEF,QAGQ,MAAA,IAAIzS,EAAK,UAAU,0BAA0BkR,EAAO,OAAO,GAAI,IAAO,GAAG,CACjF,CAIE,MAAAnH,EAAO,MAAM,KAAK,gCACtB,kBAAkBgJ,CAAQ,YAC1BN,CACF,EACO,OAAA,KAAK,2BAA2B1I,CAAI,CAAA,CAGrC,2BAA2BA,EAA8D,CAC/F,MAAMkK,EAA4C,CAAC,EACnC,OAAAA,EAAA,MAAQlK,EAAK,MAAM,IAAKmK,GAAYvB,GAAgBuB,CAAO,CAAC,EAG5ED,EAAgB,KAAO,IACrBlK,EAAK,OAAO,KAAMoK,GAETA,EAAW,KAAK,2BAA2BA,CAAQ,EAAI,IAC/D,EAEaF,EAAA,MAAQ,IAAMlK,EAAK,MAAM,EAAE,KAAMqK,GAAc,KAAK,2BAA2BA,CAAS,CAAC,EAEzFH,EAAA,QAAU,IAAMlK,EAAK,QAAQ,EAAE,KAAMsK,GAAgB,KAAK,2BAA2BA,CAAW,CAAC,EAEjGJ,EAAA,QAAU,IAAMlK,EAAK,QAAQ,EAE7BkK,EAAA,OAAS,IAAMlK,EAAK,OAAO,EAEpC,CAAE,GAAGA,EAAM,GAAGkK,CAAgB,CAAA,CAGvC,cAAclB,EAAkB3C,EAAgBc,EAA8D,CAC5G,MAAMoD,EAAsE,CAC1E,YAAapD,GAAQ,YACrB,SAAUA,GAAQ,QACpB,EACA,OAAAd,EAAS,mBAAmBA,CAAM,EAClC2C,EAAW,mBAAmBA,CAAQ,EAC/B,KAAK,uBACV,kBAAkBA,CAAQ,aAAa3C,CAAM,UAC7C,OACAkE,EACA,CAAA,CACF,CAAA,CAGF,YAAYvB,EAAkB7B,EAA2D,CACvF,MAAMoD,EAIF,CAAE,KAAMpD,EAAO,IAAK,EACxB,OAAIA,EAAO,WACToD,EAAK,SAAWpD,EAAO,UAErBA,EAAO,UACToD,EAAK,QAAUpD,EAAO,SAExB6B,EAAW,mBAAmBA,CAAQ,EAC/B,KAAK,uBAA8C,kBAAkBA,CAAQ,YAAa,OAAQuB,CAAI,CAAA,CAG/G,cAAcvB,EAAkB3C,EAAgBc,EAA6D,CACrG,MAAAqD,EAAgB,mBAAmBnE,CAAM,EAC/C,OAAA2C,EAAW,mBAAmBA,CAAQ,EAC/B,KAAK,uBACV,kBAAkBA,CAAQ,aAAawB,CAAa,GACpD,MACArD,CACF,CAAA,CAGF,mBAAmB6B,EAAkB3C,EAAgBrG,EAA+C,CAC5F,MAAAwK,EAAgB,mBAAmBnE,CAAM,EAC/C,OAAA2C,EAAW,mBAAmBA,CAAQ,EAC/B,KAAK,uBAAuB,kBAAkBA,CAAQ,aAAawB,CAAa,aAAc,OAAQxK,CAAI,CAAA,CAGnH,sBAAsBgJ,EAAkB3C,EAAgBrG,EAAkD,CAClG,MAAAwK,EAAgB,mBAAmBnE,CAAM,EAC/C,OAAA2C,EAAW,mBAAmBA,CAAQ,EAC/B,KAAK,uBACV,kBAAkBA,CAAQ,aAAawB,CAAa,aACpD,SACA,OACAxK,CACF,CAAA,CAGF,aAAagJ,EAA0C,CACrD,OAAAA,EAAW,mBAAmBA,CAAQ,EAC/B,KAAK,uBAAsC,kBAAkBA,CAAQ,aAAc,KAAK,CAAA,CAGjG,MAAc,uBACZyB,EACAC,EACAH,EACApD,EACc,CACR,MAAAuC,EAAW,MAAM,KAAK,UAAU,QAAagB,EAAQD,EAAK,KAAK,oBAAqBtD,EAAQoD,CAAI,EAClG,GAAA,CAACb,EAAS,QACP,WAAA,QAAQ,MAAM,2DAA4D,CAC7E,IAAAe,EACA,WAAYf,EAAS,WACrB,UAAWA,EAAS,UACpB,aAAcA,EAAS,YAAA,CACxB,EACK,IAAIzT,EAAK,UAAUyT,EAAS,aAAcA,EAAS,UAAWA,EAAS,UAAU,EAGlF,OAAAA,EAAS,MAAM,CAAC,CAAA,CAGzB,MAAc,gCACZe,EACAtD,EACAoD,EAC+B,CACzB,MAAAb,EAAW,MAAM,KAAK,UAAU,QAAQ,MAAOe,EAAK,KAAK,oBAAqBtD,EAAQoD,CAAI,EAC5F,GAAA,CAACb,EAAS,QACP,WAAA,QAAQ,MAAM,oEAAqE,CACtF,IAAAe,EACA,WAAYf,EAAS,WACrB,UAAWA,EAAS,UACpB,aAAcA,EAAS,YAAA,CACxB,EACK,IAAIzT,EAAK,UAAUyT,EAAS,aAAcA,EAAS,UAAWA,EAAS,UAAU,EAElF,OAAAA,CAAA,CAEX,CCnSY,IAAAiB,GAAAA,IAIVA,EAAAA,EAAA,WAAa,GAAb,EAAA,aAKAA,EAAAA,EAAA,mCAAqC,KAArC,EAAA,qCAKAA,EAAAA,EAAA,4BAA8B,KAA9B,EAAA,8BAKAA,EAAAA,EAAA,kBAAoB,MAApB,EAAA,oBAOAA,EAAAA,EAAA,kBAAoB,MAApB,EAAA,oBAKAA,EAAAA,EAAA,gBAAkB,MAAlB,EAAA,kBAKAA,EAAAA,EAAA,eAAiB,MAAjB,EAAA,iBAKAA,EAAAA,EAAA,qCAAuC,MAAvC,EAAA,uCAzCUA,IAAAA,GAAA,CAAA,CAAA,EAoDC,MAAAC,GAAc,CAACC,EAA2Bd,IAA8Bc,EAAU,OAASd,ECnD3Fe,GAAW,IAAc,KAAK,SAAS,SAAS,EAAE,EAAE,MAAM,CAAC,ECA3DC,GAAmB/B,GAA6B,GAAGA,CAAQ,UCH3DgC,GAAU,SACVC,GAA+B,WAAWD,EAAO,GACjDE,GAAqC,cAAcF,EAAO,GAE1DG,GAA4C,CAAC,UAAW,WAAW,EACnEC,GAA+C,CAC1D,OAAQ,CAAE,MAAOH,EAA6B,EAC9C,kBAAmB,GACnB,MAAOE,EACT,EAEaE,GAAqD,CAChE,OAAQ,CAAE,MAAOH,EAAmC,EACpD,kBAAmB,GACnB,MAAOC,EACT,ECRO,MAAMG,EAAe,CAQ1B,YAAYtC,EAAkBiB,EAAyBnT,EAAgByU,EAAkB,CACvFzU,EAAO,MAAM,oBAAqB,CAAE,QAAAyU,CAAA,CAAS,EAC7C,KAAK,UAAYtB,EACjB,KAAK,QAAUnT,EACf,KAAK,SAAWyU,EACX,KAAA,mBAAqB,KAAK,uBAAuB,EACjD,KAAA,WAAaR,GAAgB/B,CAAQ,CAAA,CAG5C,aAAawC,EAAoC,CAE/C,GADK,KAAA,QAAQ,MAAM,gCAAgC,EAC/C,KAAK,iBACF,WAAA,QAAQ,MAAM,yEAAyE,EACtF,IAAIvV,EAAK,UAAU,0EAA2E,IAAO,GAAG,EAG3G,KAAA,mBAAqBuV,EAAO,KAAK,kBAAkB,CAAA,CAG1D,KAA4B,CACrB,YAAA,QAAQ,MAAM,uBAAuB,EAErC,KAAA,mBAAqB,KAAK,UAAU,SAAS,IAAI,KAAK,WAAY,KAAK,kBAAkB,EAEvF,KAAK,gBAAA,CAGd,SAAgB,CACd,KAAK,QAAQ,MAAM,4BAA6B,CAAE,UAAW,KAAK,WAAY,EACzE,KAAK,kBAIV,KAAK,UAAU,SAAS,QAAQ,KAAK,UAAU,CAAA,CAGzC,wBAAkD,CACnD,KAAA,QAAQ,MAAM,0CAA0C,EAEvD,MAAAC,EAAc,KAAK,SAAWJ,GAAgCD,GACpE,YAAK,QAAQ,MAAM,KAAK,SAAW,8BAAgC,+BAA+B,EAG3F,CAAE,GAAGK,EAAa,MAAO,CAAC,GAAIA,EAAY,OAAS,CAAA,CAAG,CAAE,CAAA,CAEnE,CCUO,MAAMC,EAAsC,CAiBjD,YACE1C,EACAC,EACAC,EACApS,EACA6R,EACA,CAlBe,KAAA,SAAW,IAAIpS,EAmB9B,KAAK,UAAYyS,EACjB,KAAK,SAAWC,EAChB,KAAK,SAAWC,EAChB,KAAK,QAAUpS,EACf,KAAK,aAAe6R,EAEpB,KAAK,2BAA2B,CAAA,CAM1B,4BAAmC,CAEpC,KAAK,SAAS,UAAU,CAACzQ,GAAsB,SAAS,EAAG,KAAK,2BAA2B,KAAK,IAAI,CAAC,CAAA,CAM5G,UAAUhB,EAA2C,CAGnD,GAFK,KAAA,QAAQ,MAAM,wBAAwB,EAEvC,CAAC,KAAK,aAAa,UAAU,aAC/B,MAAM,IAAIjB,EAAK,UACb,kFACA,IACA,GACF,EAGI,MAAAkB,EAAUX,EAAKU,CAAQ,EACxB,YAAA,SAAS,GAAGC,CAAO,EAEjB,CACL,YAAa,IAAM,CACZ,KAAA,QAAQ,MAAM,0BAA0B,EACxC,KAAA,SAAS,IAAIA,CAAO,CAAA,CAE7B,CAAA,CAMF,MAAM,KAA8B,CAC7B,YAAA,QAAQ,MAAM,kBAAkB,EAC9B,KAAK,SAAS,aAAa,KAAK,SAAS,CAAA,CAMlD,SAAqC,CAInC,GAHK,KAAA,QAAQ,MAAM,sBAAsB,EAGrC,CAAC,KAAK,aAAa,UAAU,aAC/B,MAAM,IAAIlB,EAAK,UACb,iFACA,IACA,GACF,EAKF,OAAO,KAAK,oBAAA,CAON,2BAA2BZ,EAAoC,CAEjE,GADC,KAAA,QAAQ,MAAM,0CAA2CA,CAAO,EACjE,OAAOA,EAAQ,MAAS,SAAU,CACpC,KAAK,QAAQ,MACX,kGACAA,CACF,EACA,MAAA,CAGI,KAAA,CAAE,QAAAsW,GAAYtW,EAAQ,KAE5B,GAAIsW,IAAY,OAAW,CACzB,KAAK,QAAQ,MACX,+FACAtW,CACF,EACA,MAAA,CAGI,KAAA,CAAE,YAAAuW,EAAa,gBAAAC,CAAA,EAAoBF,EAEzC,GAAIC,IAAgB,OAAW,CAC7B,KAAK,QAAQ,MACX,mGACAvW,CACF,EACA,MAAA,CAGF,GAAI,CAAC,OAAO,UAAUuW,CAAW,EAAG,CAClC,KAAK,QAAQ,MACX,wGACAvW,CACF,EACA,MAAA,CAGF,GAAIwW,IAAoB,OAAW,CACjC,KAAK,QAAQ,MACX,uGACAxW,CACF,EACA,MAAA,CAGF,GAAI,CAAC,OAAO,UAAUwW,CAAe,EAAG,CACtC,KAAK,QAAQ,MACX,4GACAxW,CACF,EACA,MAAA,CAGF,KAAK,qBAAuB,CAC1B,YAAAuW,EACA,gBAAAC,CACF,EAEK,KAAA,SAAS,KAAKhT,EAAmB,QAAS,CAC7C,KAAMA,EAAmB,QACzB,UAAW,KAAK,oBAAA,CACjB,CAAA,CAQH,OAAO,oBAAoB8P,EAAwD,CACjF,OAAQhT,GAEDgT,EAAY,UAAU,aAIpB,CAAE,GAAGhT,EAAS,OAAQ,CAAE,GAAGA,EAAQ,OAAQ,UAAW,UAAY,EAHhEA,CAIX,CAEJ,CClGO,MAAMmW,EAAoC,CAe/C,YAAY7C,EAA+B3C,EAAkBxP,EAAgBnB,EAA8B,CAX1F,KAAA,SAAW,IAAIY,EAmJhC,KAAA,kBAAqBwV,GAAiC,CAChD,GAAA,CACF,MAAMC,EAAeD,EAAO,KAGvB,KAAA,SAAS,KAAKA,EAAO,OAA6B,CACrD,KAAMA,EAAO,OACb,OAAQ,CACN,SAAUA,EAAO,SACjB,KAAMC,EAAa,eACnB,OAAQD,EAAO,OACf,UAAWA,EAAO,SAAA,CACpB,CACD,QACMhC,EAAO,CACd,WAAK,QAAQ,MAAM,8DAA+D,CAAE,OAAQgC,EAAO,OAAQ,EACrG,IAAI9V,EAAK,UACb,oBAAoB8V,EAAO,MAAM,8CACjC,IACA,IACChC,EAAgB,OACnB,CAAA,CAEJ,EA9JE,KAAK,SAAWd,EAChB,KAAK,UAAY3C,EACjB,KAAK,QAAUxP,EACf,KAAK,SAAWnB,EAEhB,KAAK,2BAA2B,CAAA,CAM1B,4BAAmC,CAEpC,KAAK,SAAS,SAAS,UAAU,KAAK,kBAAkB,KAAK,IAAI,CAAC,CAAA,CAMzE,MAAM,IAAIwR,EAAiE,CACzE,YAAK,QAAQ,MAAM,iBAAkB,CAAE,OAAAA,EAAQ,EAC/C,KAAK,oBAAoB,GACF,MAAM,KAAK,SAAS,SAAS,IAAIA,CAAM,GAGxC,IAAK8E,IAAU,CACnC,SAAUA,EAAK,SAGf,KAAMA,EAAK,MAAM,eACjB,UAAWA,EAAK,UAEhB,OAAQA,EAAK,MAAA,EACb,CAAA,CAMJ,MAAM,cAAc3F,EAAoC,CACtD,YAAK,QAAQ,MAAM,2BAA4B,CAAE,SAAAA,EAAU,EAC3D,KAAK,oBAAoB,GACL,MAAM,KAAK,SAAS,SAAS,IAAI,CAAE,SAAAA,EAAoB,GACxD,OAAS,CAAA,CAM9B,MAAM,MAAMtG,EAAoC,CAC9C,KAAK,QAAQ,MAAM,mBAAoB,CAAE,KAAAA,EAAM,EAC/C,KAAK,oBAAoB,EACzB,MAAMkM,EAAwC,CAC5C,eAAgBlM,CAClB,EACA,OAAO,KAAK,SAAS,SAAS,YAAY,KAAK,UAAWkM,CAAmB,CAAA,CAM/E,MAAM,OAAOlM,EAAoC,CAC/C,KAAK,QAAQ,MAAM,oBAAqB,CAAE,KAAAA,EAAM,EAChD,KAAK,oBAAoB,EACzB,MAAMkM,EAAwC,CAC5C,eAAgBlM,CAClB,EACA,OAAO,KAAK,SAAS,SAAS,aAAa,KAAK,UAAWkM,CAAmB,CAAA,CAMhF,MAAM,MAAMlM,EAAoC,CAC9C,KAAK,QAAQ,MAAM,mBAAoB,CAAE,KAAAA,EAAM,EAC/C,KAAK,oBAAoB,EACzB,MAAMkM,EAAwC,CAC5C,eAAgBlM,CAClB,EACA,OAAO,KAAK,SAAS,SAAS,YAAY,KAAK,UAAWkM,CAAmB,CAAA,CAW/E,UACEC,EACAjV,EACc,CAId,GAHA,KAAK,QAAQ,MAAM,yCAA0C,CAAE,iBAAAiV,EAAkB,EAG7E,CAAC,KAAK,SAAS,SAAS,aACrB,WAAA,QAAQ,MAAM,kEAAkE,EAC/E,IAAIlW,EAAK,UAAU,mEAAoE,IAAO,GAAG,EAGrG,GAAA,CAACkW,GAAoB,CAACjV,EACnB,WAAA,QAAQ,MAAM,oDAAoD,EACjE,IAAIjB,EAAK,UAAU,kDAAmD,IAAO,GAAG,EAIxF,GAAIiB,EAAU,CACN,MAAAC,EAAUX,EAAKU,CAAQ,EACxB,YAAA,SAAS,GAAGiV,EAAuChV,CAAO,EACxD,CACL,YAAa,IAAM,CACjB,KAAK,QAAQ,MAAM,0BAA2B,CAAE,OAAQgV,EAAkB,EACrE,KAAA,SAAS,IAAIhV,CAAO,CAAA,CAE7B,CAAA,KACK,CACC,MAAAA,EAAUX,EAAK2V,CAAoC,EACpD,YAAA,SAAS,GAAGhV,CAAO,EACjB,CACL,YAAa,IAAM,CACZ,KAAA,QAAQ,MAAM,yBAAyB,EACvC,KAAA,SAAS,IAAIA,CAAO,CAAA,CAE7B,CAAA,CACF,CAwCF,OAAO,oBAAoBwR,EAAwD,CACjF,OAAQhT,IAEDA,EAAQ,MAAM,SAAS,UAAU,GAC5BA,EAAA,MAAM,KAAK,UAAU,EAG3BgT,EAAY,SAAS,cAAgB,CAAChT,EAAQ,MAAM,SAAS,oBAAoB,GAC3EA,EAAA,MAAM,KAAK,oBAAoB,EAElCA,EACT,CAGM,qBAA4B,CAClC,GAAI,KAAK,SAAS,QAAU,aAAe,KAAK,SAAS,QAAU,WAC5D,WAAA,QAAQ,MAAM,4DAA4D,EACzE,IAAIM,EAAK,UAAU,6DAA8D,IAAO,GAAG,CACnG,CAEJ,CCjWA,MAAMmW,GAAa,IAAI,MAAM,2BAA2B,EAExD,IAAIC,GAAoD,SAAUC,EAASC,EAAYC,EAAGC,EAAW,CACjG,SAASC,EAAMvW,EAAO,CAAE,OAAOA,aAAiBqW,EAAIrW,EAAQ,IAAIqW,EAAE,SAAUhD,EAAS,CAAEA,EAAQrT,CAAK,CAAI,CAAA,CAAE,CAC1G,OAAO,IAAKqW,IAAMA,EAAI,UAAU,SAAUhD,EAASC,EAAQ,CACvD,SAASkD,EAAUxW,EAAO,CAAE,GAAI,CAAEyW,EAAKH,EAAU,KAAKtW,CAAK,CAAC,CAAI,OAAQ0W,EAAG,CAAEpD,EAAOoD,CAAC,CAAI,CAAA,CACzF,SAASC,EAAS3W,EAAO,CAAE,GAAI,CAAEyW,EAAKH,EAAU,MAAStW,CAAK,CAAC,CAAI,OAAQ0W,EAAG,CAAEpD,EAAOoD,CAAC,CAAI,CAAA,CAC5F,SAASD,EAAK/P,EAAQ,CAAEA,EAAO,KAAO2M,EAAQ3M,EAAO,KAAK,EAAI6P,EAAM7P,EAAO,KAAK,EAAE,KAAK8P,EAAWG,CAAQ,CAAE,CAC5GF,GAAMH,EAAYA,EAAU,MAAMH,EAASC,GAAc,CAAA,CAAE,GAAG,MAAM,CAC5E,CAAK,CACL,EACA,MAAMQ,EAAU,CACZ,YAAYC,EAAQC,EAAeb,GAAY,CAC3C,KAAK,OAASY,EACd,KAAK,aAAeC,EACpB,KAAK,OAAS,CAAE,EAChB,KAAK,iBAAmB,CAAE,CAClC,CACI,QAAQC,EAAS,EAAGC,EAAW,EAAG,CAC9B,GAAID,GAAU,EACV,MAAM,IAAI,MAAM,kBAAkBA,CAAM,oBAAoB,EAChE,OAAO,IAAI,QAAQ,CAAC1D,EAASC,IAAW,CACpC,MAAM2D,EAAO,CAAE,QAAA5D,EAAS,OAAAC,EAAQ,OAAAyD,EAAQ,SAAAC,CAAU,EAC5CE,EAAIC,GAAiB,KAAK,OAASxH,GAAUqH,GAAYrH,EAAM,QAAQ,EACzEuH,IAAM,IAAMH,GAAU,KAAK,OAE3B,KAAK,cAAcE,CAAI,EAGvB,KAAK,OAAO,OAAOC,EAAI,EAAG,EAAGD,CAAI,CAEjD,CAAS,CACT,CACI,aAAaG,EAAY,CACrB,OAAOlB,GAAY,KAAM,UAAW,OAAQ,UAAWmB,EAAUN,EAAS,EAAGC,EAAW,EAAG,CACvF,KAAM,CAAChX,EAAOsX,CAAO,EAAI,MAAM,KAAK,QAAQP,EAAQC,CAAQ,EAC5D,GAAI,CACA,OAAO,MAAMK,EAASrX,CAAK,CAC3C,QACoB,CACJsX,EAAS,CACzB,CACA,CAAS,CACT,CACI,cAAcP,EAAS,EAAGC,EAAW,EAAG,CACpC,GAAID,GAAU,EACV,MAAM,IAAI,MAAM,kBAAkBA,CAAM,oBAAoB,EAChE,OAAI,KAAK,sBAAsBA,EAAQC,CAAQ,EACpC,QAAQ,QAAS,EAGjB,IAAI,QAAS3D,GAAY,CACvB,KAAK,iBAAiB0D,EAAS,CAAC,IACjC,KAAK,iBAAiBA,EAAS,CAAC,EAAI,CAAE,GAC1CQ,GAAa,KAAK,iBAAiBR,EAAS,CAAC,EAAG,CAAE,QAAA1D,EAAS,SAAA2D,EAAU,CACrF,CAAa,CAEb,CACI,UAAW,CACP,OAAO,KAAK,QAAU,CAC9B,CACI,UAAW,CACP,OAAO,KAAK,MACpB,CACI,SAAShX,EAAO,CACZ,KAAK,OAASA,EACd,KAAK,eAAgB,CAC7B,CACI,QAAQ+W,EAAS,EAAG,CAChB,GAAIA,GAAU,EACV,MAAM,IAAI,MAAM,kBAAkBA,CAAM,oBAAoB,EAChE,KAAK,QAAUA,EACf,KAAK,eAAgB,CAC7B,CACI,QAAS,CACL,KAAK,OAAO,QAAStN,GAAUA,EAAM,OAAO,KAAK,YAAY,CAAC,EAC9D,KAAK,OAAS,CAAE,CACxB,CACI,gBAAiB,CAEb,IADA,KAAK,oBAAqB,EACnB,KAAK,OAAO,OAAS,GAAK,KAAK,OAAO,CAAC,EAAE,QAAU,KAAK,QAC3D,KAAK,cAAc,KAAK,OAAO,MAAK,CAAE,EACtC,KAAK,oBAAqB,CAEtC,CACI,cAAc+N,EAAM,CAChB,MAAMC,EAAgB,KAAK,OAC3B,KAAK,QAAUD,EAAK,OACpBA,EAAK,QAAQ,CAACC,EAAe,KAAK,aAAaD,EAAK,MAAM,CAAC,CAAC,CACpE,CACI,aAAaT,EAAQ,CACjB,IAAIW,EAAS,GACb,MAAO,IAAM,CACLA,IAEJA,EAAS,GACT,KAAK,QAAQX,CAAM,EACtB,CACT,CACI,qBAAsB,CAClB,GAAI,KAAK,OAAO,SAAW,EACvB,QAASA,EAAS,KAAK,OAAQA,EAAS,EAAGA,IAAU,CACjD,MAAMY,EAAU,KAAK,iBAAiBZ,EAAS,CAAC,EAC3CY,IAELA,EAAQ,QAASC,GAAWA,EAAO,QAAO,CAAE,EAC5C,KAAK,iBAAiBb,EAAS,CAAC,EAAI,CAAE,EACtD,KAEa,CACD,MAAMc,EAAiB,KAAK,OAAO,CAAC,EAAE,SACtC,QAASd,EAAS,KAAK,OAAQA,EAAS,EAAGA,IAAU,CACjD,MAAMY,EAAU,KAAK,iBAAiBZ,EAAS,CAAC,EAChD,GAAI,CAACY,EACD,SACJ,MAAMT,EAAIS,EAAQ,UAAWC,GAAWA,EAAO,UAAYC,CAAc,GACxEX,IAAM,GAAKS,EAAUA,EAAQ,OAAO,EAAGT,CAAC,GACpC,QAASU,GAAUA,EAAO,SAAW,CAC1D,CACA,CACA,CACI,sBAAsBb,EAAQC,EAAU,CACpC,OAAQ,KAAK,OAAO,SAAW,GAAK,KAAK,OAAO,CAAC,EAAE,SAAWA,IAC1DD,GAAU,KAAK,MAC3B,CACA,CACA,SAASQ,GAAaO,EAAGC,EAAG,CACxB,MAAMb,EAAIC,GAAiBW,EAAInI,GAAUoI,EAAE,UAAYpI,EAAM,QAAQ,EACrEmI,EAAE,OAAOZ,EAAI,EAAG,EAAGa,CAAC,CACxB,CACA,SAASZ,GAAiBW,EAAGE,EAAW,CACpC,QAASd,EAAIY,EAAE,OAAS,EAAGZ,GAAK,EAAGA,IAC/B,GAAIc,EAAUF,EAAEZ,CAAC,CAAC,EACd,OAAOA,EAGf,MAAO,EACX,CAEA,IAAIe,GAAoD,SAAU9B,EAASC,EAAYC,EAAGC,EAAW,CACjG,SAASC,EAAMvW,EAAO,CAAE,OAAOA,aAAiBqW,EAAIrW,EAAQ,IAAIqW,EAAE,SAAUhD,EAAS,CAAEA,EAAQrT,CAAK,CAAI,CAAA,CAAE,CAC1G,OAAO,IAAKqW,IAAMA,EAAI,UAAU,SAAUhD,EAASC,EAAQ,CACvD,SAASkD,EAAUxW,EAAO,CAAE,GAAI,CAAEyW,EAAKH,EAAU,KAAKtW,CAAK,CAAC,CAAI,OAAQ0W,EAAG,CAAEpD,EAAOoD,CAAC,CAAI,CAAA,CACzF,SAASC,EAAS3W,EAAO,CAAE,GAAI,CAAEyW,EAAKH,EAAU,MAAStW,CAAK,CAAC,CAAI,OAAQ0W,EAAG,CAAEpD,EAAOoD,CAAC,CAAI,CAAA,CAC5F,SAASD,EAAK/P,EAAQ,CAAEA,EAAO,KAAO2M,EAAQ3M,EAAO,KAAK,EAAI6P,EAAM7P,EAAO,KAAK,EAAE,KAAK8P,EAAWG,CAAQ,CAAE,CAC5GF,GAAMH,EAAYA,EAAU,MAAMH,EAASC,GAAc,CAAA,CAAE,GAAG,MAAM,CAC5E,CAAK,CACL,EACA,MAAM8B,EAAM,CACR,YAAYC,EAAa,CACrB,KAAK,WAAa,IAAIvB,GAAU,EAAGuB,CAAW,CACtD,CACI,SAAU,CACN,OAAOF,GAAY,KAAM,UAAW,OAAQ,UAAWjB,EAAW,EAAG,CACjE,KAAM,CAAA,CAAGoB,CAAQ,EAAI,MAAM,KAAK,WAAW,QAAQ,EAAGpB,CAAQ,EAC9D,OAAOoB,CACnB,CAAS,CACT,CACI,aAAaf,EAAUL,EAAW,EAAG,CACjC,OAAO,KAAK,WAAW,aAAa,IAAMK,EAAU,EAAE,EAAGL,CAAQ,CACzE,CACI,UAAW,CACP,OAAO,KAAK,WAAW,SAAU,CACzC,CACI,cAAcA,EAAW,EAAG,CACxB,OAAO,KAAK,WAAW,cAAc,EAAGA,CAAQ,CACxD,CACI,SAAU,CACF,KAAK,WAAW,SAAU,GAC1B,KAAK,WAAW,QAAS,CACrC,CACI,QAAS,CACL,OAAO,KAAK,WAAW,OAAQ,CACvC,CACA,CCvKY,IAAAqB,GAAAA,IAKVA,EAAA,aAAe,eAKfA,EAAA,YAAc,cAKdA,EAAA,UAAY,YAKZA,EAAA,SAAW,WAKXA,EAAA,UAAY,YAKZA,EAAA,SAAW,WAKXA,EAAA,UAAY,YAKZA,EAAA,OAAS,SAKTA,EAAA,UAAY,YAKZA,EAAA,SAAW,WAlDDA,IAAAA,GAAA,CAAA,CAAA,EA0IL,MAAMC,EAAsD,CAWjE,YAAY3X,EAAgB,CAV5B,KAAQ,QAAsB,cAGb,KAAA,iBAAmB,IAAIP,EACvB,KAAA,SAAW,IAAIA,EAO9B,KAAK,QAAUO,CAAA,CAMjB,IAAI,QAAqB,CACvB,OAAO,KAAK,OAAA,CAMd,IAAI,OAAoC,CACtC,OAAO,KAAK,MAAA,CAMd,SAASI,EAAkD,CACnD,MAAAC,EAAUX,EAAKU,CAAQ,EACxB,YAAA,SAAS,GAAGC,CAAO,EAEjB,CACL,IAAK,IAAM,CACJ,KAAA,SAAS,IAAIA,CAAO,CAAA,CAE7B,CAAA,CAGF,UAAUgQ,EAA6B,CACrC,MAAMpQ,EAA2B,CAC/B,QAASoQ,EAAO,OAChB,MAAOA,EAAO,MACd,SAAU,KAAK,OACjB,EAEA,KAAK,QAAUpQ,EAAO,QACtB,KAAK,OAASA,EAAO,MACrB,KAAK,QAAQ,KAAK,sBAAuB,CAAE,GAAGA,EAAQ,EACtD,KAAK,iBAAiB,KAAKA,EAAO,QAASA,CAAM,EACjD,KAAK,SAAS,KAAKA,EAAO,QAASA,CAAM,CAAA,CAE7C,CC5KO,MAAM2X,EAAqB,CAShC,YAAYC,EAAgCC,EAAsC9X,EAAgB,CAChG,KAAK,gBAAkB6X,EACvB,KAAK,eAAiBC,EACtB,KAAK,QAAU9X,EACV,KAAA,cAAgB,IAAIP,EACzB,KAAK,iBAAmB,GACxB,KAAK,sBAAwB,GACxB,KAAA,OAAS,IAAI8X,GAGlB,KAAK,6BAA6B,EAClC,KAAK,8BAA8B,CAAA,CAQ7B,8BAAqC,CAC3B,KAAK,gBAAgB,IAAI,EAGjC,GAAIpX,GAAyC,CAS/C,GARC,KAAA,QAAQ,MAAM,6CAA8C,CAC/D,SAAUA,EAAY,SACtB,SAAUA,EAAY,QACtB,OAAQA,EAAY,OACpB,QAASA,EAAY,OAAA,CACtB,EAGG,KAAK,uBAAwB,CAC/B,KAAK,QAAQ,MACX,6GACA,CACE,OAAQ,KAAK,eAAe,MAAA,CAEhC,EACA,MAAA,CAIF,MAAM4X,EAAY,KAAK,6BAA6B5X,EAAY,OAAO,EAClE,KAAA,WAAW4X,EAAW5X,EAAY,MAAM,CAAA,CAC9C,CAAA,CASK,+BAAsC,CACtC,MAAAgS,EAAU,KAAK,gBAAgB,IAAI,EAGjCA,EAAA,GAAG,WAAahS,GAAyC,CAC/D,GAAI,CAACA,EAAY,SAAW,KAAK,kBAAoB,CAAC,KAAK,sBAAuB,CAC1E,MAAA8S,EAAQ,IAAI9T,EAAK,UACrB,yBACA0U,EAAU,kBACV1T,EAAY,QAAQ,YAAc,EAClCA,EAAY,MACd,EAEK,KAAA,QAAQ,KAAK,+EAAgF,CAChG,MAAA8S,CAAA,CACD,EACD,KAAK,cAAc,KAAKjR,EAAc,cAAeiR,CAAK,CAAA,CAC5D,CACD,EAGOd,EAAA,GAAG,SAAWhS,GAAyC,CAC7D,GACE,CAACA,EAAY,SACb,KAAK,kBACL,CAAC,KAAK,uBACNA,EAAY,UAAY,YACxBA,EAAY,WAAa,WACzB,CACM,MAAA8S,EAAQ,IAAI9T,EAAK,UACrB,yBACA0U,EAAU,kBACV1T,EAAY,QAAQ,YAAc,EAClCA,EAAY,MACd,EAEK,KAAA,QAAQ,KAAK,+EAAgF,CAChG,MAAA8S,CAAA,CACD,EACD,KAAK,cAAc,KAAKjR,EAAc,cAAeiR,CAAK,CAAA,CAC5D,CACD,CAAA,CAQH,gBAAgBhU,EAAoD,CAC7D,KAAA,QAAQ,MAAM,wCAAwC,EACrD,MAAAoB,EAAUX,EAAKT,CAAO,EAC5B,YAAK,cAAc,GAAG+C,EAAc,cAAe3B,CAAO,EACnD,CACL,IAAK,IAAM,CACT,KAAK,cAAc,IAAI2B,EAAc,cAAe3B,CAAO,CAAA,CAE/D,CAAA,CAQF,MAAM,QAAwB,CAEtB,MAAA,KAAK,OAAO,aAAa,SAAY,CAOzC,GANK,KAAA,QAAQ,MAAM,gCAAgC,EAGnD,KAAK,uBAAuB,QAAQ,EAGhC,KAAK,cAAcqX,EAAW,QAAQ,EAAG,CACtC,KAAA,QAAQ,MAAM,6DAA6D,EAChF,MAAA,CAGI,MAAAvF,EAAU,KAAK,gBAAgB,IAAI,EACpC,KAAA,QAAQ,MAAM,gDAAiD,CAClE,aAAcA,EAAQ,KAAA,CACvB,EAEG,GAAA,CAEG,KAAA,WAAWuF,EAAW,SAAS,EAEpC,MAAMvF,EAAQ,OAAO,EAChB,KAAA,WAAWuF,EAAW,QAAQ,EACnC,KAAK,sBAAwB,GAC7B,KAAK,iBAAmB,GACnB,KAAA,QAAQ,MAAM,2DAA2D,QACvEzE,EAAO,CACd,MAAM+E,EAAU/E,EACVgF,EAAc,IAAI9Y,EAAK,UAC3B,0BAA0B6Y,EAAQ,OAAO,GACzCA,EAAQ,KACRA,EAAQ,WACRA,CACF,EAEMD,EAAY,KAAK,6BAA6B5F,EAAQ,KAAK,EAC5D,WAAA,WAAW4F,EAAWE,CAAW,EAChCA,CAAA,GAEP,CAA8B,CAAA,CAQnC,MAAM,QAAwB,CAEtB,MAAA,KAAK,OAAO,aAAa,SAAY,CAIzC,GAHK,KAAA,QAAQ,MAAM,gCAAgC,EAG/C,KAAK,cAAcP,EAAW,MAAM,EACtC,MAAM,IAAIvY,EAAK,UAAU,8CAA+C0U,EAAU,kBAAmB,GAAG,EAO1G,GAHA,KAAK,uBAAuB,QAAQ,EAGhC,KAAK,cAAc6D,EAAW,QAAQ,EAAG,CACtC,KAAA,QAAQ,MAAM,6DAA6D,EAChF,MAAA,CAGI,MAAAvF,EAAU,KAAK,gBAAgB,IAAI,EACpC,KAAA,QAAQ,MAAM,gDAAiD,CAClE,aAAcA,EAAQ,KAAA,CACvB,EAEG,GAAA,CAEG,KAAA,WAAWuF,EAAW,SAAS,EAEpC,MAAMvF,EAAQ,OAAO,EACrB,KAAK,sBAAwB,GACxB,KAAA,WAAWuF,EAAW,QAAQ,EAC9B,KAAA,QAAQ,MAAM,2DAA2D,QACvEzE,EAAO,CACd,MAAM+E,EAAU/E,EACViF,EAAc,IAAI/Y,EAAK,UAC3B,0BAA0B6Y,EAAQ,OAAO,GACzCA,EAAQ,KACRA,EAAQ,WACRA,CACF,EAEMD,EAAY,KAAK,6BAA6B5F,EAAQ,KAAK,EAC5D,WAAA,WAAW4F,EAAWG,CAAW,EAChCA,CAAA,GAEP,CAA8B,CAAA,CAQnC,MAAM,SAAyB,CAEvB,MAAA,KAAK,OAAO,aAAa,SAAY,CAIzC,GAHK,KAAA,QAAQ,MAAM,iCAAiC,EAGhD,KAAK,cAAcR,EAAW,QAAQ,EAAG,CACtC,KAAA,QAAQ,MAAM,8DAA8D,EACjF,MAAA,CAIE,GAAA,KAAK,cAAcA,EAAW,WAAW,GAAK,KAAK,cAAcA,EAAW,QAAQ,EAAG,CACpF,KAAA,QAAQ,MAAM,yFAA0F,CAC3G,OAAQ,KAAK,eAAe,MAAA,CAC7B,EACD,KAAK,gBAAgB,EACrB,MAAA,CAIG,KAAA,WAAWA,EAAW,SAAS,EAC9B,MAAAvF,EAAU,KAAK,gBAAgB,IAAI,EAGpC,KAAA,QAAQ,MAAM,2EAA4E,CAC7F,aAAcA,EAAQ,KAAA,CACvB,EACK,MAAA,KAAK,mBAAmBA,CAAO,EAGrC,KAAK,gBAAgB,GACpB,CAAyB,CAAA,CAMtB,6BAA6BgG,EAA6C,CAChF,OAAQA,EAAc,CACpB,IAAK,cACH,OAAOT,EAAW,YAEpB,IAAK,YACH,OAAOA,EAAW,UAEpB,IAAK,WACH,OAAOA,EAAW,SAEpB,IAAK,YACH,OAAOA,EAAW,UAEpB,IAAK,WACH,OAAOA,EAAW,SAEpB,IAAK,YACH,OAAOA,EAAW,UAEpB,IAAK,SACH,OAAOA,EAAW,OAEpB,QACO,YAAA,QAAQ,MAAM,6EAA8E,CAC/F,aAAAS,CAAA,CACD,EACMT,EAAW,MACpB,CACF,CAGM,uBAAuBU,EAAY,CACjC,OAAA,KAAK,eAAe,OAAQ,CAClC,KAAKV,EAAW,SACR,MAAA,IAAIvY,EAAK,UAAU,UAAUiZ,CAAE,0BAA2BvE,EAAU,eAAgB,GAAG,EAE/F,KAAK6D,EAAW,UACR,MAAA,IAAIvY,EAAK,UAAU,UAAUiZ,CAAE,qCAAsCvE,EAAU,gBAAiB,GAAG,CAC3G,CACF,CAGM,cAAcvT,EAAoB,CACjC,OAAA,KAAK,eAAe,SAAWA,CAAA,CAGxC,MAAc,mBAAmB6R,EAA+B,CACrD,OAAA,CAGP,GADwCA,EAAQ,QAC3B,SAAU,CACxB,KAAA,QAAQ,MAAM,+EAA+E,EAClG,KAAA,CAGE,GAAA,CACF,MAAMA,EAAQ,OAAO,EACrB,YACOc,EAAO,CAET,KAAA,QAAQ,MAAM,qFAAsF,CACvG,MAAAA,CAAA,CACD,EACD,MAAM,IAAI,QAASP,GAAY,WAAWA,EAAS,GAAG,CAAC,CAAA,CACzD,CACF,CAGM,WAAWpS,EAAoB2S,EAAwB,CACxD,KAAA,QAAQ,MAAM,0DAA2D,CAC5E,UAAW,KAAK,eAAe,OAC/B,UAAW3S,EACX,SAAU,CAAC,CAAC2S,CAAA,CACb,EACD,KAAK,eAAe,UAAU,CAAE,OAAA3S,EAAQ,MAAA2S,EAAO,CAAA,CAGzC,iBAAkB,CACxB,KAAK,gBAAgB,QAAQ,EACxB,KAAA,WAAWyE,EAAW,QAAQ,EAC9B,KAAA,QAAQ,MAAM,oEAAoE,CAAA,CAOjF,sBAAgC,CAC/B,OAAA,KAAK,OAAO,SAAS,CAAA,CAG9B,yBAAyBW,EAAsB,CAC7C,KAAK,iBAAmBA,CAAA,CAE5B,CCnYA,MAAMC,GAAiE,CAIrE,OAAQ,CAMN,oBAAqB,GACvB,EAKA,UAAW,CAIT,aAAc,EAChB,EAKA,SAAU,CACR,aAAc,EAChB,EAKA,SAAU,CACR,oBAAqB,GACrB,2BAA4B3W,EAAoB,QAAA,CAEpD,EA0JM4W,GAA4BC,GAChC,IAAIrZ,EAAK,UAAU,+BAA+BqZ,CAAM,GAAI,MAAO,GAAG,EAE3DC,GAAuB5Z,GAAuC,CACzE6Z,GAAsB7Z,EAAQ,MAAM,CACtC,EAEM6Z,GAAyB7Z,GAAyC,CAClE,GAAAA,EAAQ,qBAAuB,EACjC,MAAM0Z,GAAyB,kDAAkD,CAErF,EAEMI,GAA0B9Z,IACvB,CACL,GAAGyZ,GAAmB,OACtB,GAAGzZ,GAAS,MACd,GAGI+Z,GAA6B/Z,IAC1B,CACL,GAAGyZ,GAAmB,UACtB,GAAGzZ,GAAS,SACd,GAGIga,GAA4Bha,IACzB,CACL,GAAGyZ,GAAmB,SACtB,GAAGzZ,GAAS,QACd,GAGIia,GAA2Bja,IACxB,CACL,GAAGyZ,GAAmB,SACtB,GAAGzZ,GAAS,QACd,GAGWka,GAAuB,CAACla,EAAkCma,KAC9D,CACL,OAAQL,GAAuB9Z,CAAO,EACtC,UAAW+Z,GAA0B/Z,CAAO,EAC5C,SAAUga,GAAyBha,CAAO,EAC1C,SAAUia,GAAwBja,CAAO,EACzC,cAAema,CACjB,GC5OWC,GAAmB,CAAC5H,EAAcnI,KACtC,CACL,KAAAmI,EACA,KAAAnI,EACA,OAAQ,CACN,UAAW,EAAA,CAEf,GAUWgQ,GAAsB3a,GAAwC,CACzE,MAAMkS,EAASlS,EAAQ,OAAUA,EAAQ,OAAoB,CAAC,EAEvD,MAAA,CACL,GAAGA,EACH,OAAQ,CACN,GAAGkS,EACH,UAAW,EAAA,CAEf,CACF,ECcO,MAAM0I,EAA4C,CACvD,YACkB9H,EACA7B,EACAM,EACAsJ,EACA1J,EACAC,EAChB,CANgB,KAAA,KAAA0B,EACA,KAAA,SAAA7B,EACA,KAAA,UAAAM,EACA,KAAA,OAAAsJ,EACA,KAAA,SAAA1J,EACA,KAAA,QAAAC,EAGhB,OAAO,OAAO,IAAI,CAAA,CAEtB,CC/CgB,SAAA0J,GAAkB9a,EAA8BiR,EAAiC,CAC/F,MAAM8J,EAAyB/a,EAC3B,GAAA,CAAC+a,EAAuB,KAC1B,MAAM,IAAIna,EAAK,UAAU,uDAAwD,IAAO,GAAG,EAGzF,GAAA,CAACma,EAAuB,KAAK,MAAQ,OAAOA,EAAuB,KAAK,MAAS,SACnF,MAAM,IAAIna,EAAK,UAAU,6CAA8C,IAAO,GAAG,EAG/E,GAAA,CAACma,EAAuB,SAC1B,MAAM,IAAIna,EAAK,UAAU,2DAA4D,IAAO,GAAG,EAG7F,GAAA,CAACma,EAAuB,UAC1B,MAAM,IAAIna,EAAK,UAAU,4DAA6D,IAAO,GAAG,EAGlG,OAAO,IAAIga,GACTG,EAAuB,KAAK,KAC5BA,EAAuB,SACvB,IAAI,KAAKA,EAAuB,SAAS,EACzC9J,EAAWA,IAAa8J,EAAuB,SAAW,GAC1DA,EAAuB,KAAK,UAAY,CAAC,EACzCA,EAAuB,QAAQ,SAAW,CAAA,CAC5C,CACF,CC0DO,MAAMC,EAA8C,CAczD,YAAYpH,EAA+BqH,EAA6BhK,EAAkBxP,EAAgB,CATzF,KAAA,SAAW,IAAIP,EA4ExB,KAAA,WAAcga,GAAiC,CACrD,MAAMC,EAAW,KAAK,kBAAkBD,EAAS,KAAK,SAAS,EAC1DC,GAIA,KAAA,SAAS,KAAKhY,GAAsB,SAAU,CACjD,KAAMA,GAAsB,SAC5B,SAAAgY,CAAA,CACD,CACH,EA5EE,KAAK,SAAWvH,EAChB,KAAK,YAAcqH,EACnB,KAAK,UAAYhK,EACjB,KAAK,QAAUxP,EAEf,KAAK,2BAA2B,CAAA,CAM1B,4BAAmC,CAEpC,KAAK,SAAS,UAAU,CAACyB,GAA8B,QAAQ,EAAG,KAAK,WAAW,KAAK,IAAI,CAAC,CAAA,CAMnG,KAAK4O,EAA2C,CACzC,KAAA,QAAQ,MAAM,wBAAyBA,CAAM,EAElD,KAAM,CAAE,KAAAgB,EAAM,SAAA3B,EAAU,QAAAC,CAAY,EAAAU,EAEpC,GAAI,CAACgB,EACI,OAAA,QAAQ,OAAO,IAAIlS,EAAK,UAAU,2DAA4D,MAAO,GAAG,CAAC,EAI9G,GAAA,KAAK,YAAY,QAAU,YACtB,OAAA,QAAQ,OAAO,IAAIA,EAAK,UAAU,iDAAkD,IAAO,GAAG,CAAC,EAGxG,MAAMkU,EAA2B,CAC/B,KAAAhC,EACA,SAAU3B,GAAY,CAAA,CACxB,EAEMiK,EAAgC,CACpC,KAAMlY,GAA8B,SACpC,KAAM4R,EACN,OAAQ,CACN,QAAS1D,GAAW,CAAA,CAAC,CAEzB,EAEA,OAAO,KAAK,SAAS,QAAQuJ,GAAmBS,CAAe,CAAC,CAAA,CAMlE,UAAUvZ,EAA8C,CACjD,KAAA,QAAQ,MAAM,4BAA4B,EACzC,MAAAC,EAAUX,EAAKU,CAAQ,EACxB,YAAA,SAAS,GAAGC,CAAO,EAEjB,CACL,YAAa,IAAM,CACZ,KAAA,QAAQ,MAAM,8BAA8B,EAC5C,KAAA,SAAS,IAAIA,CAAO,CAAA,CAE7B,CAAA,CAgBM,kBAAkBoZ,EAA8BjK,EAA4C,CAC9F,GAAA,CACK,OAAA6J,GAAkBI,EAASjK,CAAQ,QACnCyD,EAAgB,CAClB,KAAA,QAAQ,MAAM,qCAAsC,CACvD,QAAAwG,EACA,MAAAxG,CAAA,CACD,CAAA,CACH,CAEJ,CC9GO,MAAM2G,WAAsBna,CAAgD,CA2BjF,YACEZ,EACA2a,EACArH,EACA3C,EACAxP,EACA,CACM,MAAA,EAtBR,KAAiB,WAAa,IAKb,KAAA,OAAS,IAAIuX,GAgYtB,KAAA,2BAA8BkC,GAAuC,CACrE,KAAA,CAAE,KAAApI,EAAM,SAAA7B,CAAA,EAAaiK,EAM3B,GALK,KAAA,QAAQ,MAAM,6DAA8D,CAC/E,KAAApI,EACA,SAAA7B,CAAA,CACD,EAEG,CAACA,EAAU,CACR,KAAA,QAAQ,MAAM,iFAAkF,CACnG,QAAAiK,CAAA,CACD,EACD,MAAA,CAIEpI,IAAS9P,EAAgB,OAAS8P,IAAS9P,EAAgB,KACxD,KAAA,uBAAuBiO,EAAU6B,CAAI,EAErC,KAAA,QAAQ,KAAK,iEAAkE,CAClF,KAAAA,CAAA,CACD,CAEL,EApYE,KAAK,UAAY7B,EACjB,KAAK,SAAW2C,EAChB,KAAK,YAAcqH,EAGnB,KAAK,qBAAuB3a,EAAQ,oBAG/B,KAAA,qBAAuB,IAC5B,KAAK,QAAUmB,EAEf,KAAK,2BAA2B,CAAA,CAM1B,4BAAmC,CAGpC,KAAK,SAAS,UACjB,CAACuB,EAAgB,MAAOA,EAAgB,IAAI,EAC5C,KAAK,2BAA2B,KAAK,IAAI,CAC3C,CAAA,CAQM,uBAA8B,CAC/B,KAAA,QAAQ,MAAM,mEAAmE,EACtF,KAAK,qBAAqB,EAC1B,KAAK,sBAAsB,CAAA,CAOrB,sBAA6B,CAC9B,KAAA,QAAQ,MAAM,gEAAgE,EAC/E,KAAK,oBACP,aAAa,KAAK,iBAAiB,EACnC,KAAK,kBAAoB,OAC3B,CAOM,uBAA8B,CAC/B,KAAA,QAAQ,MAAM,4EAA4E,EAE/F,SAAW,CAAG,CAAAsY,CAAS,IAAK,KAAK,iBAAiB,UAChD,aAAaA,CAAS,EAGxB,KAAK,iBAAiB,MAAM,CAAA,CAQ9B,SAAuB,CAChB,YAAA,QAAQ,MAAM,0BAA0B,EACtC,IAAI,IAAY,KAAK,iBAAiB,MAAM,CAAA,CAMrD,IAAI,SAAgC,CAClC,OAAO,KAAK,QAAA,CAMN,sBAA6B,CAC/B,GAAA,CAAC,KAAK,kBAAmB,CACtB,KAAA,QAAQ,MAAM,sCAAsC,EACzD,MAAMC,EAAS,KAAK,kBAAoB,WAAW,IAAM,CAClD,KAAA,QAAQ,MAAM,8DAA8D,EAE7EA,IAAU,KAAK,oBACjB,KAAK,kBAAoB,OAC3B,EACC,KAAK,oBAAoB,CAAA,CAC9B,CAMF,MAAM,WAA2B,CAC1B,KAAA,QAAQ,MAAM,4BAA4B,EAC/C,KAAK,OAAO,OAAO,EAGf,GAAA,CACI,MAAA,KAAK,OAAO,QAAQ,QACnB7G,EAAgB,CACvB,GAAIA,IAAUqC,GAAY,CACnB,KAAA,QAAQ,MAAM,oEAAoE,EACvF,MAAA,CAEF,MAAM,IAAInW,EAAK,UAAU,2BAA4B,IAAO,GAAG,CAAA,CAE7D,GAAA,CAGE,GAAA,KAAK,YAAY,QAAU,YACxB,WAAA,QAAQ,MAAM,yDAA0D,CAC3E,OAAQ,KAAK,YAAY,KAAA,CAC1B,EACK,IAAIA,EAAK,UAAU,2CAA4C,IAAO,GAAG,EAKjF,GAAI,KAAK,kBAAmB,CACrB,KAAA,QAAQ,MAAM,sFAAsF,EACzG,MAAA,CAKF,MAAM,KAAK,SAAS,QAAQ8Z,GAAiB1X,EAAgB,KAAK,CAAC,EAInE,KAAK,qBAAqB,EACrB,KAAA,QAAQ,MAAM,4CAA4C,CAAA,QAC/D,CACK,KAAA,QAAQ,MAAM,4CAA4C,EAC/D,KAAK,OAAO,QAAQ,CAAA,CACtB,CAMF,MAAM,MAAsB,CACrB,KAAA,QAAQ,MAAM,uBAAuB,EAE1C,KAAK,OAAO,OAAO,EAEf,GAAA,CACI,MAAA,KAAK,OAAO,QAAQ,QACnB0R,EAAgB,CACvB,GAAIA,IAAUqC,GAAY,CACnB,KAAA,QAAQ,MAAM,+DAA+D,EAClF,MAAA,CAEF,MAAM,IAAInW,EAAK,UAAU,2BAA4B,IAAO,GAAG,CAAA,CAE7D,GAAA,CAEE,GAAA,KAAK,YAAY,QAAU,YACxB,WAAA,QAAQ,MAAM,oDAAqD,CACtE,OAAQ,KAAK,YAAY,KAAA,CAC1B,EACK,IAAIA,EAAK,UAAU,kDAAmD,IAAO,GAAG,EAKpF,GAAA,CAAC,KAAK,kBAAmB,CACtB,KAAA,QAAQ,MAAM,mDAAmD,EACtE,MAAA,CAIF,MAAM,KAAK,SAAS,QAAQ8Z,GAAiB1X,EAAgB,IAAI,CAAC,EAC7D,KAAA,QAAQ,MAAM,uCAAuC,EAI1D,aAAa,KAAK,iBAAiB,EACnC,KAAK,kBAAoB,MAAA,QACzB,CACK,KAAA,QAAQ,MAAM,uCAAuC,EAC1D,KAAK,OAAO,QAAQ,CAAA,CACtB,CAMF,UAAUnB,EAAwC,CAC3C,KAAA,QAAQ,MAAM,4BAA4B,EACzC,MAAAC,EAAUX,EAAKU,CAAQ,EAC7B,YAAK,GAAGC,CAAO,EAER,CACL,YAAa,IAAM,CACZ,KAAA,QAAQ,MAAM,8BAA8B,EACjD,KAAK,IAAIA,CAAO,CAAA,CAEpB,CAAA,CAOF,MAAM,SAAyB,CAIpB,IAHJ,KAAA,QAAQ,MAAM,0BAA0B,IAIvC,GAAA,CACF,KAAK,OAAO,OAAO,EACb,MAAA,KAAK,OAAO,QAAQ,EAC1B,YACO4S,EAAgB,CACvB,GAAIA,IAAUqC,GAIP,KAAA,QAAQ,MAAM,6CAA6C,EAChE,MAAM,IAAI,QAAS5C,GAAY,WAAWA,EAAS,GAAG,CAAC,EAClD,KAAA,QAAQ,MAAM,qDAAqD,MACnE,CAIA,KAAA,QAAQ,MAAM,yFAA0F,CAC3G,MAAAO,CAAA,CACD,EACD,MAAA,CACF,CAGJ,KAAK,sBAAsB,EAC3B,KAAK,OAAO,QAAQ,CAAA,CASd,uBAAuBzD,EAAkBU,EAA8B,CAC7E,KAAK,QAAQ,MAAM,0CAA2C,CAAE,SAAAV,EAAU,MAAAU,EAAO,EAE7EA,IAAU3O,EAAgB,MAC5B,KAAK,mBAAmBiO,CAAQ,EAEhC,KAAK,kBAAkBA,CAAQ,CACjC,CASM,+BAA+BA,EAAiD,CACjF,KAAA,QAAQ,MAAM,gFAAiF,CAClG,SAAAA,CAAA,CACD,EAEK,MAAAqK,EAAY,WAAW,IAAM,CAKjC,GAJK,KAAA,QAAQ,MAAM,gFAAiF,CAClG,SAAArK,CAAA,CACD,EAEG,KAAK,iBAAiB,IAAIA,CAAQ,IAAMqK,EAAW,CAChD,KAAA,QAAQ,MAAM,oFAAqF,CACtG,SAAArK,CAAA,CACD,EACD,MAAA,CAIG,KAAA,iBAAiB,OAAOA,CAAQ,EAChC,KAAA,KAAKhO,EAAmB,WAAY,CACvC,KAAMA,EAAmB,WACzB,gBAAiB,IAAI,IAAY,KAAK,iBAAiB,MAAM,EAC7D,OAAQ,CACN,SAAAgO,EACA,KAAMjO,EAAgB,IAAA,CACxB,CACD,CACA,EAAA,KAAK,qBAAuB,KAAK,UAAU,EACvC,OAAAsY,CAAA,CAOD,mBAAmBrK,EAAwB,CACjD,KAAK,QAAQ,MAAM,sCAAuC,CAAE,SAAAA,EAAU,EAEhE,MAAAqK,EAAY,KAAK,+BAA+BrK,CAAQ,EAExDuK,EAAkB,KAAK,iBAAiB,IAAIvK,CAAQ,EAGrD,KAAA,iBAAiB,IAAIA,EAAUqK,CAAS,EAEzCE,GAEG,KAAA,QAAQ,MAAM,qFAAsF,CACvG,SAAAvK,CAAA,CACD,EACD,aAAauK,CAAe,IAGvB,KAAA,QAAQ,MAAM,gEAAiE,CAClF,SAAAvK,CAAA,CACD,EACI,KAAA,KAAKhO,EAAmB,WAAY,CACvC,KAAMA,EAAmB,WACzB,gBAAiB,IAAI,IAAY,KAAK,iBAAiB,MAAM,EAC7D,OAAQ,CACN,SAAAgO,EACA,KAAMjO,EAAgB,KAAA,CACxB,CACD,EACH,CAQM,kBAAkBiO,EAAwB,CAChD,MAAMuK,EAAkB,KAAK,iBAAiB,IAAIvK,CAAQ,EAC1D,GAAI,CAACuK,EAAiB,CAEpB,KAAK,QAAQ,MACX,kGACA,CAAE,SAAAvK,CAAS,CACb,EACA,MAAA,CAIF,KAAK,QAAQ,MAAM,2DAA4D,CAAE,SAAAA,EAAU,EAC3F,aAAauK,CAAe,EACvB,KAAA,iBAAiB,OAAOvK,CAAQ,EAEhC,KAAA,KAAKhO,EAAmB,WAAY,CACvC,KAAMA,EAAmB,WACzB,gBAAiB,IAAI,IAAY,KAAK,iBAAiB,MAAM,EAC7D,OAAQ,CACN,SAAAgO,EACA,KAAMjO,EAAgB,IAAA,CACxB,CACD,CAAA,CA8BH,IAAI,qBAA8B,CAChC,OAAO,KAAK,oBAAA,CAGd,IAAI,mBAA6B,CACxB,MAAA,CAAC,CAAC,KAAK,iBAAA,CAElB,CC9YO,MAAMyY,EAA4B,CA+BvC,YACE3I,EACA4I,EACApb,EACAsU,EACAf,EACApS,EACA,CACAyY,GAAoB5Z,CAAO,EAC3B,KAAK,OAASob,EAGT,KAAA,QAAUja,EAAO,YAAY,CAAE,SAAUqR,EAAM,UAAW4I,EAAO,EACtE,KAAK,QAAQ,MAAM,UAAW,CAAE,QAAApb,EAAS,EAEzC,KAAK,MAAQwS,EACb,KAAK,SAAWxS,EAChB,KAAK,SAAWuT,EAChB,KAAK,WAAa,IAAIuF,GAAqB,KAAK,OAAO,EAEjD,MAAAE,EAAkB,KAAK,gBAAkB,KAAK,mBAAmBhZ,EAASsU,EAAU,KAAK,OAAO,EAChGhB,EAAU0F,EAAe,IAAI,EAGnC,KAAK,UAAY,IAAI5F,GACnBZ,EACAxS,EAAQ,SACRsT,EACA,KAAK,SACLgB,EAAS,KAAK,SACd,KAAK,OACP,EACK,KAAA,UAAY,IAAI6B,GAAgB7C,EAASgB,EAAS,KAAK,SAAU,KAAK,QAAStU,CAAO,EAC3F,KAAK,QAAU,IAAI+a,GACjB/a,EAAQ,OACRsU,EAAS,WACThB,EACAgB,EAAS,KAAK,SACd,KAAK,OACP,EACK,KAAA,WAAa,IAAIoG,GAAqBpH,EAASgB,EAAS,WAAYA,EAAS,KAAK,SAAU,KAAK,OAAO,EACxG,KAAA,WAAa,IAAIyB,GAAiBvD,EAAMc,EAAS,KAAK,SAAU,KAAK,QAAStT,CAAO,EAI1F,KAAK,kBAAoB,IAAI+Y,GAAqBC,EAAgB,KAAK,WAAY,KAAK,OAAO,EAG/F,IAAIqC,EAAY,GAChB,KAAK,WAAa,SAAY,CAE5B,GAAIA,EAAW,CACR,KAAA,QAAQ,MAAM,qCAAqC,EACxD,MAAA,CAII,MAAA,KAAK,kBAAkB,QAAQ,EAG/B,MAAA,KAAK,QAAQ,QAAQ,EAEfA,EAAA,EACd,CAAA,CAUM,mBAAmBrb,EAA8BsU,EAAyBnT,EAAgC,CAC1G,MAAAma,EAAU,IAAI3F,GAAe,KAAK,MAAOrB,EAAUnT,EAAQnB,EAAQ,aAAa,EAEtF,OAAAsb,EAAQ,aAAavF,GAAiB,oBAAoB/V,CAAO,CAAC,EAClEsb,EAAQ,aAAanF,GAAgB,oBAAoBnW,CAAO,CAAC,EACjEsb,EAAQ,aAAatJ,GAAwB,oBAAoBhS,CAAO,CAAC,EAClEsb,CAAA,CAMT,IAAI,MAAe,CACjB,OAAO,KAAK,KAAA,CAMd,SAAuB,CACd,OAAApL,EAAU,KAAK,QAAQ,CAAA,CAMhC,IAAI,UAAqB,CACvB,OAAO,KAAK,SAAA,CAMd,IAAI,UAAqB,CACvB,OAAO,KAAK,SAAA,CAMd,IAAI,WAA2B,CAC7B,OAAO,KAAK,UAAA,CAMd,IAAI,QAAiB,CACnB,OAAO,KAAK,OAAA,CAMd,IAAI,WAAuB,CACzB,OAAO,KAAK,UAAA,CAMd,IAAI,QAAqB,CACvB,OAAO,KAAK,WAAW,MAAA,CAMzB,IAAI,OAAoC,CACtC,OAAO,KAAK,WAAW,KAAA,CAMzB,eAAe3O,EAAkD,CACxD,OAAA,KAAK,WAAW,SAASA,CAAQ,CAAA,CAM1C,MAAM,QAAS,CACR,YAAA,QAAQ,MAAM,gBAAgB,EAC5B,KAAK,kBAAkB,OAAO,CAAA,CAMvC,MAAM,QAAwB,CACvB,YAAA,QAAQ,MAAM,gBAAgB,EAC5B,KAAK,kBAAkB,OAAO,CAAA,CAOvC,SAAyB,CAClB,YAAA,QAAQ,MAAM,iBAAiB,EAC7B,KAAK,WAAW,CAAA,CAQzB,IAAI,OAAgB,CAClB,OAAO,KAAK,MAAA,CAQd,IAAI,WAAmC,CACrC,OAAO,KAAK,UAAA,CAMd,IAAI,kBAAyC,CAC3C,OAAO,KAAK,iBAAA,CAMd,gBAAgBnB,EAAoD,CAC7D,YAAA,QAAQ,MAAM,yBAAyB,EACrC,KAAK,kBAAkB,gBAAgBA,CAAO,CAAA,CAMvD,IAAI,SAAgC,CAC3B,OAAA,KAAK,gBAAgB,IAAI,CAAA,CAEpC,CClSO,MAAMmb,EAA8B,CAgBzC,YAAYjH,EAAyBkH,EAA4Cra,EAAgB,CAZhF,KAAA,WAAwC,IACxC,KAAA,eAAiB,IAElC,KAAQ,SAAW,GAUjB,KAAK,UAAYmT,EACjB,KAAK,SAAW,IAAID,GAAQC,EAAUnT,CAAM,EAC5C,KAAK,eAAiBqa,EACtB,KAAK,QAAUra,CAAA,CAMjB,IAAIqR,EAAcxS,EAAsC,CACtD,KAAK,QAAQ,MAAM,eAAgB,CAAE,SAAUwS,EAAM,EAErD,MAAMiJ,EAAW,KAAK,OAAO,IAAIjJ,CAAI,EACrC,GAAIiJ,EACF,OAAK1Z,EAAO0Z,EAAS,QAASzb,CAAO,GAIhC,KAAA,QAAQ,MAAM,uCAAwC,CAAE,SAAUwS,EAAM,MAAOiJ,EAAS,MAAO,EAC7FA,EAAS,SAJP,QAAQ,OAAO,IAAInb,EAAK,UAAU,6CAA8C,IAAO,GAAG,CAAC,EAOtG,MAAMob,EAAY,KAAK,WAAW,IAAIlJ,CAAI,EACpC4I,EAAQjG,GAAS,EAGvB,GAAI,CAACuG,EAAW,CACd,MAAMC,EAAO,KAAK,UAAUnJ,EAAM4I,EAAOpb,CAAO,EAC1CiK,EAAQ,CACZ,QAAS,QAAQ,QAAQ0R,CAAI,EAC7B,MAAAP,EACA,QAAApb,CACF,EAEK,YAAA,OAAO,IAAIwS,EAAMvI,CAAK,EACtB,KAAA,QAAQ,MAAM,kCAAmC,CAAE,SAAUuI,EAAM,MAAOmJ,EAAK,MAAO,EACpF1R,EAAM,OAAA,CAKT,MAAA2R,EAAkB,IAAI,gBACtBC,EAAc,IAAI,QAAqB,CAAChI,EAASC,IAAW,CAChE,MAAMgI,EAAgB,IAAM,CAC1B,KAAK,QAAQ,MAAM,mCAAoC,CAAE,SAAUtJ,EAAM,EACzEsB,EACE,IAAIxT,EAAK,UACP,oDACA0U,EAAU,qCACV,GAAA,CAEJ,CACF,EAEgB4G,EAAA,OAAO,iBAAiB,QAASE,CAAa,EAE9DJ,EACG,KAAK,IAAM,CAEN,GAAAE,EAAgB,OAAO,QAAS,CAClC,KAAK,QAAQ,MAAM,yDAA0D,CAAE,SAAUpJ,EAAM,EAC/F,MAAA,CAGF,KAAK,QAAQ,MAAM,kCAAmC,CAAE,SAAUA,EAAM,EACxE,MAAMmJ,EAAO,KAAK,UAAUnJ,EAAM4I,EAAOpb,CAAO,EAChC4b,EAAA,OAAO,oBAAoB,QAASE,CAAa,EACjEjI,EAAQ8H,CAAI,CAAA,CACb,EACA,MAAOvH,GAAmB,CACzBN,EAAOM,CAAc,CAAA,CACtB,CAAA,CACJ,EAEI,YAAA,OAAO,IAAI5B,EAAM,CACpB,QAASqJ,EACT,QAAA7b,EACA,MAAAob,EACA,MAAOQ,CAAA,CACR,EAED,KAAK,QAAQ,MAAM,kEAAmE,CAAE,SAAUpJ,EAAM,EACjGqJ,CAAA,CAMT,IAAI,eAAmC,CACrC,OAAO,KAAK,cAAA,CAMd,QAAQrJ,EAA6B,CACnC,KAAK,QAAQ,MAAM,mBAAoB,CAAE,SAAUA,EAAM,EAEzD,MAAMiJ,EAAW,KAAK,OAAO,IAAIjJ,CAAI,EAC/BkJ,EAAY,KAAK,WAAW,IAAIlJ,CAAI,EAG1C,GAAI,CAACiJ,EAGH,OAAIC,GACG,KAAA,QAAQ,MAAM,qDAAsD,CACvE,SAAUlJ,CAAA,CACX,EACMkJ,IAIT,KAAK,QAAQ,MAAM,uCAAwC,CAAE,SAAUlJ,EAAM,EACtE,QAAQ,QAAQ,GAMzB,GAAIkJ,EACF,OAAID,EAAS,QACN,KAAA,QAAQ,MAAM,qCAAsC,CAAE,SAAUjJ,EAAM,cAAeiJ,EAAS,MAAO,EAC1GA,EAAS,MAAM,MAAM,EAChB,KAAA,OAAO,OAAOjJ,CAAI,GAGlBkJ,EAIJ,KAAA,OAAO,OAAOlJ,CAAI,EACvB,MAAMuJ,EAAiBN,EAAS,QAAQ,KAAME,IACvC,KAAA,QAAQ,MAAM,kCAAmC,CAAE,SAAUnJ,EAAM,MAAOiJ,EAAS,MAAO,EACxFE,EAAK,UAAU,KAAK,IAAM,CAC1B,KAAA,QAAQ,MAAM,iCAAkC,CAAE,SAAUnJ,EAAM,MAAOiJ,EAAS,MAAO,EACzF,KAAA,WAAW,OAAOjJ,CAAI,CAAA,CAC5B,EACF,EAEI,YAAA,QAAQ,MAAM,gDAAiD,CAAE,SAAUA,EAAM,MAAOiJ,EAAS,MAAO,EACxG,KAAA,WAAW,IAAIjJ,EAAMuJ,CAAc,EAEjCA,CAAA,CAYD,UAAUvJ,EAAc4I,EAAepb,EAA+C,CAC5F,OAAO,IAAImb,GACT3I,EACA4I,EACAlB,GAAqBla,EAAS,KAAK,QAAQ,EAC3C,KAAK,UACL,KAAK,SACL,KAAK,OACP,CAAA,CAMF,UAAiB,CACV,KAAA,QAAQ,MAAM,mBAAmB,EACtC,KAAK,SAAW,EAAA,CAEpB,CCtQO,MAAMgc,EAAW,CA+BtB,YAAY1H,EAAyBkH,EAAmC,CACtE,KAAK,UAAYlH,EACZ,KAAA,eAAiB5T,GAAuB8a,CAAa,EACrD,KAAA,QAAUzb,GAAW,KAAK,cAAc,EAC7C,KAAK,YAAc,IAAIkB,GAAkBqT,EAAU,KAAK,OAAO,EAC/D,KAAK,OAAS,IAAIiH,GAAajH,EAAU,KAAK,eAAgB,KAAK,OAAO,EAC1E,KAAK,UAAU,SAAS,EACxB,KAAK,QAAQ,MAAM,4BAA4Be,EAAO,eAAe,CAAA,CAQvE,IAAI,OAAe,CACjB,OAAO,KAAK,MAAA,CASd,IAAI,YAAyB,CAC3B,OAAO,KAAK,WAAA,CAQd,IAAI,UAAmB,CACd,OAAA,KAAK,UAAU,KAAK,QAAA,CAO7B,IAAI,UAA0B,CAC5B,OAAO,KAAK,SAAA,CAOd,IAAI,eAAmC,CACrC,OAAO,KAAK,cAAA,CAQd,IAAI,QAAiB,CACnB,OAAO,KAAK,OAAA,CAQP,eAAsB,CAC3B,KAAK,UAAU,YAAY,EAC3B,KAAK,OAAO,SAAS,CAAA,CAUhB,oBAAoB4G,EAAejL,EAAuB,CAC1D,KAAA,UAAUiL,EAAOjL,CAAO,EAC7B,KAAK,QAAQ,MAAM,eAAeiL,CAAK,iBAAiBjL,CAAO,EAAE,CAAA,CAQ3D,UAAUiL,EAAejL,EAAwB,CACvD,MAAMsD,EAAW,KAAK,UACtBA,EAAS,QAAQ,OAAS,CAAE,GAAIA,EAAS,QAAQ,QAAUA,EAAS,QAAQ,OAAS,CAAC2H,CAAK,EAAGjL,GAAWqE,EAAQ,CAAA,CAErH","x_google_ignoreList":[4,6,21]}