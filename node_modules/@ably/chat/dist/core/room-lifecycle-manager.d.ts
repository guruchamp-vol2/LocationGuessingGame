import { ChannelManager } from './channel-manager.js';
import { DiscontinuityListener } from './discontinuity.js';
import { RoomEventType } from './events.js';
import { Logger } from './logger.js';
import { InternalRoomLifecycle } from './room-status.js';
import { StatusSubscription } from './subscription.js';
import * as Ably from 'ably';
/**
 * Events that can be emitted by the RoomLifecycleManager
 */
export interface RoomLifeCycleEvents {
    [RoomEventType.Discontinuity]: Ably.ErrorInfo;
}
/**
 * Manages the lifecycle of a room's underlying channel, handling attach, detach and release operations
 * while maintaining the room's status.
 */
export declare class RoomLifecycleManager {
    private readonly _channelManager;
    private readonly _roomLifecycle;
    private readonly _logger;
    private readonly _eventEmitter;
    private _hasAttachedOnce;
    private _isExplicitlyDetached;
    private readonly _mutex;
    constructor(channelManager: ChannelManager, roomLifecycle: InternalRoomLifecycle, logger: Logger);
    /**
     * Sets up monitoring of channel state changes to keep room status in sync.
     * If an operation is in progress (attach/detach/release), state changes are ignored.
     * @private
     */
    private _startMonitoringChannelState;
    /**
     * Sets up monitoring for channel discontinuities.
     * A discontinuity exists when an attached or update event comes from the channel with resume=false.
     * The first time we attach, or if we attach after an explicit detach call are not considered discontinuities.
     * @private
     */
    private _startMonitoringDiscontinuity;
    /**
     * Registers a handler for discontinuity events.
     * @param handler The function to be called when a discontinuity is detected
     * @returns An object with an off() method to deregister the handler
     */
    onDiscontinuity(handler: DiscontinuityListener): StatusSubscription;
    /**
     * Attaches to the channel and updates room status accordingly.
     * If the room is released/releasing, this operation fails.
     * If already attached, this is a no-op.
     */
    attach(): Promise<void>;
    /**
     * Detaches from the channel and updates room status accordingly.
     * If the room is released/releasing, this operation fails.
     * If already detached, this is a no-op.
     */
    detach(): Promise<void>;
    /**
     * Releases the room by detaching the channel and releasing it from the channel manager.
     * If the channel is in a failed state, skips the detach operation.
     * Will retry detach until successful unless in failed state.
     */
    release(): Promise<void>;
    /**
     * Maps an Ably channel state to a room status
     */
    private _mapChannelStateToRoomStatus;
    private _checkRoomNotReleasing;
    private _roomStatusIs;
    private _channelDetachLoop;
    private _setStatus;
    private _releaseChannel;
    /**
     * Returns whether there is currently an operation (attach/detach/release) in progress
     * @private
     */
    private _operationInProgress;
    testForceHasAttachedOnce(firstAttach: boolean): void;
}
