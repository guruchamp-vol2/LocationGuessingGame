import * as H from "react";
import X, { createContext as te, useRef as D, useEffect as d, useCallback as C, useContext as ne, useMemo as k, useState as P } from "react";
import * as F from "ably";
import { jsx as J } from "react/jsx-runtime";
const K = te(void 0), U = Symbol.for("__ABLY_CHAT_CLIENT_CONTEXT__"), Y = typeof globalThis > "u" ? {} : globalThis;
function re() {
  let e = Y[U];
  return e ??= Y[U] = X.createContext({}), e;
}
const V = re(), $ = "default", me = ({ children: e, client: r }) => {
  const o = H.useContext(V), n = H.useMemo(() => {
    r.addReactAgent();
    const u = globalThis.__ABLY_CHAT_REACT_UI_COMPONENTS_VERSION__;
    return typeof u == "string" && r.addAgentWithVersion("chat-ui-kit", u), { ...o, [$]: { client: r } };
  }, [r, o]);
  return /* @__PURE__ */ J(V.Provider, { value: n, children: e });
}, Q = () => {
  const e = X.useContext(V)[$];
  if (!e)
    throw new F.ErrorInfo("useChatClient hook must be used within a chat client provider", 4e4, 400);
  return e.client;
}, S = (e) => {
  const r = D(e);
  d(() => {
    r.current = e;
  });
  const o = C((...n) => {
    r.current && r.current(...n);
  }, []);
  return e ? o : void 0;
}, T = (e) => {
  const r = ne(K);
  if (!r)
    throw new F.ErrorInfo(`${e} hook must be used within a <ChatRoomProvider>`, 4e4, 400);
  return r;
}, Z = () => {
  const e = Q();
  return k(() => e.logger, [e]);
}, L = () => {
  const e = T("useRoomLogger"), r = Q();
  return k(
    () => r.logger.withContext({ roomName: e.roomName }),
    [r, e]
  );
}, O = (e) => {
  const r = Q(), o = Z();
  o.trace("useChatConnection();", e);
  const [n, u] = P(r.connection.status), [g, t] = P(r.connection.error), [s, m] = P(r.connection);
  d(() => {
    m(r.connection), t(r.connection.error), u(r.connection.status);
  }, [r]);
  const i = S(e?.onStatusChange);
  return d(() => {
    o.debug("useChatConnection(); applying internal listener");
    const { off: c } = r.connection.onStatusChange((a) => {
      u(a.current), t(a.error);
    });
    return () => {
      o.debug("useChatConnection(); cleaning up listener"), c();
    };
  }, [r.connection, o]), d(() => {
    if (!i) return;
    o.debug("useChatConnection(); applying client listener");
    const { off: c } = r.connection.onStatusChange(i);
    return () => {
      o.debug("useChatConnection(); cleaning up client listener"), c();
    };
  }, [r.connection, o, i]), {
    currentStatus: n,
    error: g,
    connection: s
  };
};
class oe {
  /**
   * Creates a new DefaultRoomPromise and starts the resolution of the promise.
   *
   * @param room  The promise that resolves to a Room instance.
   * @param onResolve  The callback that is called when the promise resolves to a Room instance.
   * @param logger  The logger to use for logging.
   */
  constructor(r, o, n) {
    this._unmounted = !1, this._onResolve = o, this._logger = n, this.mount(r).catch((u) => {
      this._logger.trace("DefaultRoomPromise(); mount error", { error: u });
    });
  }
  /**
   * Wait for the room promise to resolve, then execute the onResolve callback, storing its response as an unmount function.
   * If the component is unmounted before the promise resolves, then this will do nothing.
   *
   * @param promise The promise that resolves to a Room instance.
   * @returns A promise that we simply resolve when it's done.
   */
  async mount(r) {
    this._logger.debug("DefaultRoomPromise(); mount");
    try {
      const o = await r;
      if (this._unmounted)
        return;
      this._logger.debug("DefaultRoomPromise(); mount resolved"), this._onUnmount = this._onResolve(o);
    } catch (o) {
      this._logger.error("DefaultRoomPromise(); mount error", { error: o });
    }
  }
  /**
   * Returns a function to be called when the component is unmounted. If the room promise has resolved at the time
   * of calling, then the unmount function returned by the onResolve callback will be called.
   *
   * Multiple calls are no-op.
   *
   * Example usage:
   *
   * ```ts
   *  useEffect(() => {
   *    const roomPromise = wrapRoomPromise(...);
   *    return roomPromise.unmount();
   *  }, []);
   * ```
   *
   * @returns A function that should be called when the component is unmounted.
   */
  unmount() {
    return this._unmounted ? () => {
    } : () => {
      this._logger.debug("DefaultRoomPromise(); unmount"), this._unmounted = !0, this._onUnmount?.();
    };
  }
}
function v(e, r, o) {
  return new oe(e, r, o);
}
const se = (e) => {
  const r = D(e);
  return d(() => {
    r.current = e;
  }), C((...o) => r.current(...o), []);
}, ue = () => {
  const [e, r] = P(), o = T("useEventualRoom"), n = L();
  return n.trace("useEventualRoom();"), d(() => {
    n.debug("useEventualRoom(); running useEffect");
    let u = !1;
    return o.room.then((g) => {
      if (u) {
        n.debug("useEventualRoom(); already unmounted");
        return;
      }
      n.debug("useEventualRoom(); resolved"), r(g);
    }).catch((g) => {
      n.error("Failed to get room", { error: g });
    }), () => {
      n.debug("useEventualRoom(); cleanup"), u = !0;
    };
  }, [o, n]), e;
}, N = (e) => {
  const [r, o] = P(), n = T("useEventualRoomProperty"), u = L();
  u.trace("useEventualRoomProperty();");
  const g = se(e);
  return d(() => {
    let t = !1;
    return u.debug("useEventualRoomProperty(); running useEffect"), n.room.then((s) => {
      if (t) {
        u.debug("useEventualRoomProperty(); already unmounted");
        return;
      }
      u.debug("useEventualRoomProperty(); resolved"), o(g(s));
    }).catch((s) => {
      u.error("Failed to get room", { error: s });
    }), () => {
      u.debug("useEventualRoomProperty(); cleanup"), t = !0;
    };
  }, [n, u, g]), r;
};
F.Realtime.EventEmitter;
var A = /* @__PURE__ */ ((e) => (e.Initializing = "initializing", e.Initialized = "initialized", e.Attaching = "attaching", e.Attached = "attached", e.Detaching = "detaching", e.Detached = "detached", e.Suspended = "suspended", e.Failed = "failed", e.Releasing = "releasing", e.Released = "released", e))(A || {});
const B = (e) => {
  const r = T("useRoomStatus"), [o, n] = P(A.Initializing), [u, g] = P(), t = L(), s = S(e?.onRoomStatusChange);
  return d(() => v(
    r.room,
    (i) => {
      t.debug("useRoomStatus(); subscribing internal listener"), n(i.status), g(i.error);
      const { off: c } = i.onStatusChange((a) => {
        t.debug("useRoomStatus(); status change", a), n(a.current), g(a.error);
      });
      return () => {
        t.debug("useRoomStatus(); unsubscribing internal listener"), c();
      };
    },
    t
  ).unmount(), [r, t]), d(() => v(
    r.room,
    (i) => {
      let c;
      return s && (t.debug("useRoomStatus(); subscribing to status changes"), c = i.onStatusChange(s).off), t.debug("useRoomStatus(); setting initial status", { status: i.status }), s && (t.debug("useRoomStatus(); sending initial status event"), s({
        current: i.status,
        previous: A.Initializing,
        error: i.error
      })), () => {
        t.debug("useRoomStatus(); unmounting"), c && (t.debug("useRoomStatus(); unsubscribing from status changes"), c());
      };
    },
    t
  ).unmount(), [r, t, s]), {
    status: o,
    error: u
  };
}, be = (e) => {
  const { currentStatus: r, error: o } = O({
    onStatusChange: e?.onConnectionStatusChange
  }), n = T("useMessages"), { status: u, error: g } = B(e), t = L();
  t.trace("useMessages();", { params: e });
  const s = S(e?.listener), m = S(e?.reactionsListener), i = S(e?.rawReactionsListener), c = S(e?.onDiscontinuity), a = C(
    (h) => n.room.then((f) => f.messages.send(h)),
    [n]
  ), y = C(
    (h, f) => n.room.then((R) => R.messages.delete(h, f)),
    [n]
  ), l = C(
    (h) => n.room.then((f) => f.messages.history(h)),
    [n]
  ), p = C(
    (h, f, R) => n.room.then((x) => x.messages.update(h, f, R)),
    [n]
  ), b = C(
    (h, f) => n.room.then((R) => R.messages.reactions.send(h, f)),
    [n]
  ), M = C(
    (h, f) => n.room.then((R) => R.messages.reactions.delete(h, f)),
    [n]
  ), [E, w] = P();
  return d(() => {
    if (s)
      return v(
        n.room,
        (h) => {
          let f = !1;
          t.debug("useMessages(); applying listener");
          const R = h.messages.subscribe(s);
          return w(() => {
            if (t.debug("useMessages(); setting historyBeforeSubscribe state", {
              status: h.status,
              unmounted: f
            }), !f)
              return (x) => (t.debug("useMessages(); historyBeforeSubscribe called"), f ? Promise.reject(new F.ErrorInfo("component unmounted", 4e4, 400)) : R.historyBeforeSubscribe(x));
          }), () => {
            t.debug("useMessages(); removing listener and historyBeforeSubscribe state"), f = !0, R.unsubscribe(), w(void 0);
          };
        },
        t
      ).unmount();
  }, [n, t, s]), d(() => {
    if (c)
      return v(
        n.room,
        (h) => {
          t.debug("useMessages(); applying onDiscontinuity listener");
          const { off: f } = h.onDiscontinuity(c);
          return () => {
            t.debug("useMessages(); removing onDiscontinuity listener"), f();
          };
        },
        t
      ).unmount();
  }, [n, t, c]), d(() => {
    if (m)
      return v(
        n.room,
        (h) => {
          t.debug("useMessages(); applying reactions listener");
          const { unsubscribe: f } = h.messages.reactions.subscribe(m);
          return () => {
            t.debug("useMessages(); removing reactions listener"), f();
          };
        },
        t
      ).unmount();
  }, [n, t, m]), d(() => {
    if (i)
      return v(
        n.room,
        (h) => {
          t.debug("useMessages(); applying raw reactions listener");
          const { unsubscribe: f } = h.messages.reactions.subscribeRaw(i);
          return () => {
            t.debug("useMessages(); removing raw reactions listener"), f();
          };
        },
        t
      ).unmount();
  }, [n, t, i]), {
    connectionStatus: r,
    connectionError: o,
    roomStatus: u,
    roomError: g,
    send: a,
    update: p,
    history: l,
    deleteMessage: y,
    sendReaction: b,
    deleteReaction: M,
    historyBeforeSubscribe: E,
    messages: N((h) => h.messages)
  };
}, he = (e) => {
  const { currentStatus: r, error: o } = O({
    onStatusChange: e?.onConnectionStatusChange
  }), n = T("useOccupancy"), { status: u, error: g } = B(e), t = L();
  t.trace("useOccupancy();", { params: e });
  const [s, m] = P({
    connections: 0,
    presenceMembers: 0
  }), i = S(e?.listener), c = S(e?.onDiscontinuity);
  return d(() => {
    if (c)
      return v(
        n.room,
        (a) => {
          t.debug("useOccupancy(); applying onDiscontinuity listener");
          const { off: y } = a.onDiscontinuity(c);
          return () => {
            t.debug("useOccupancy(); removing onDiscontinuity listener"), y();
          };
        },
        t
      ).unmount();
  }, [n, c, t]), d(() => v(
    n.room,
    (a) => {
      t.debug("useOccupancy(); applying internal listener");
      const y = a.occupancy.current();
      m({
        connections: y?.connections ?? 0,
        presenceMembers: y?.presenceMembers ?? 0
      });
      const { unsubscribe: l } = a.occupancy.subscribe((p) => {
        m({
          connections: p.occupancy.connections,
          presenceMembers: p.occupancy.presenceMembers
        });
      });
      return () => {
        t.debug("useOccupancy(); cleaning up internal listener"), l();
      };
    },
    t
  ).unmount(), [n, t]), d(() => {
    if (i)
      return v(
        n.room,
        (a) => {
          t.debug("useOccupancy(); applying listener");
          const { unsubscribe: y } = a.occupancy.subscribe(i);
          return () => {
            t.debug("useOccupancy(); cleaning up listener"), y();
          };
        },
        t
      ).unmount();
  }, [i, n, t]), {
    occupancy: N((a) => a.occupancy),
    connectionStatus: r,
    connectionError: o,
    roomStatus: u,
    roomError: g,
    connections: s.connections,
    presenceMembers: s.presenceMembers
  };
};
var j = /* @__PURE__ */ ((e) => (e.Initialized = "initialized", e.Connecting = "connecting", e.Connected = "connected", e.Disconnected = "disconnected", e.Suspended = "suspended", e.Failed = "failed", e))(j || {});
const G = /* @__PURE__ */ new Set([j.Suspended, j.Failed]), fe = (e) => {
  const { currentStatus: r, error: o } = O({
    onStatusChange: e?.onConnectionStatusChange
  }), n = T("usePresence"), { status: u, error: g } = B(e), t = L();
  t.trace("usePresence();", { params: e });
  const [s, m] = P(!1), [i, c] = P(), a = D({ roomStatus: u, connectionStatus: r }), y = S(e?.onDiscontinuity), l = D(e);
  d(() => {
    l.current = e;
  }, [e]), d(() => {
    a.current = { roomStatus: u, connectionStatus: r };
  }, [u, r]), d(() => (t.debug("usePresence(); entering room"), v(
    n.room,
    (b) => b.status === A.Attached && !G.has(r) ? (b.presence.enter(l.current?.enterWithData).then(() => {
      t.debug("usePresence(); entered room"), m(!0), c(void 0);
    }).catch((E) => {
      t.error("usePresence(); error entering room", { error: E }), c(E);
    }), () => {
      const E = b.status === A.Attached && !G.has(a.current.connectionStatus);
      t.debug("usePresence(); unmounting", {
        canLeavePresence: E,
        roomStatus: u,
        connectionStatus: r
      }), E && b.presence.leave(l.current?.leaveWithData).then(() => {
        t.debug("usePresence(); left room"), m(!1), c(void 0);
      }).catch((w) => {
        t.error("usePresence(); error leaving room", { error: w }), c(w);
      });
    }) : (t.debug("usePresence(); skipping enter room", { roomStatus: u, connectionStatus: r }), () => {
    }),
    t
  ).unmount()), [n, r, u, t]), d(() => {
    if (y)
      return v(
        n.room,
        (b) => {
          const { off: M } = b.onDiscontinuity(y);
          return () => {
            t.debug("usePresence(); removing onDiscontinuity listener"), M();
          };
        },
        t
      ).unmount();
  }, [n, y, t]);
  const p = C(
    (b) => n.room.then((M) => M.presence.update(b).then(() => {
      m(!0), c(void 0);
    })),
    [n]
  );
  return {
    presence: N((b) => b.presence),
    connectionStatus: r,
    connectionError: o,
    roomStatus: u,
    roomError: g,
    update: p,
    isPresent: s,
    error: i
  };
};
var ee = /* @__PURE__ */ ((e) => (e[e.BadRequest = 4e4] = "BadRequest", e[e.MessageRejectedByBeforePublishRule = 42211] = "MessageRejectedByBeforePublishRule", e[e.MessageRejectedByModeration = 42213] = "MessageRejectedByModeration", e[e.RoomDiscontinuity = 102100] = "RoomDiscontinuity", e[e.RoomInFailedState = 102101] = "RoomInFailedState", e[e.RoomIsReleasing = 102102] = "RoomIsReleasing", e[e.RoomIsReleased = 102103] = "RoomIsReleased", e[e.RoomReleasedBeforeOperationCompleted = 102106] = "RoomReleasedBeforeOperationCompleted", e))(ee || {});
const ce = (e, r) => e.code === r, ie = 1500, ae = 3e4, ge = 5, Re = (e) => {
  const { currentStatus: r, error: o } = O({
    onStatusChange: e?.onConnectionStatusChange
  }), n = T("usePresenceListener"), { status: u, error: g } = B(e), t = L();
  t.trace("usePresenceListener();");
  const s = D(0), m = D(0), i = D(void 0), c = D(0), a = D([]), [y, l] = P([]), p = D(void 0), [b, M] = P(), E = S(e?.listener), w = S(e?.onDiscontinuity), h = C(
    (R) => {
      t.debug("usePresenceListener(); setting error state", { error: R }), p.current = R, M(R);
    },
    [t]
  ), f = C(() => {
    t.debug("usePresenceListener(); clearing error state"), p.current = void 0, M(void 0);
  }, [t]);
  return d(() => {
    const R = () => {
      s.current += 1, i.current && (clearTimeout(i.current), i.current = void 0, c.current = 0), x(s.current);
    }, x = (I) => {
      v(
        n.room,
        (q) => (q.presence.get({ waitForSync: !0 }).then((_) => {
          t.debug("usePresenceListener(); fetched presence data", { presenceMembers: _ }), i.current && (clearTimeout(i.current), i.current = void 0, c.current = 0), !(m.current >= I) && (m.current = I, a.current = _, l(_), p.current && f());
        }).catch(() => {
          if (!(c.current < ge)) {
            t.error("usePresenceListener(); failed to fetch presence data after max retries"), h(new F.ErrorInfo("failed to fetch presence data after max retries", 5e4, 500));
            return;
          }
          if (i.current) {
            t.debug("usePresenceListener(); waiting for retry but new event received");
            return;
          }
          const z = Math.min(
            ae,
            ie * Math.pow(2, c.current)
          );
          c.current += 1, t.debug("usePresenceListener(); retrying to fetch presence data", {
            numRetries: c.current
          }), i.current = setTimeout(() => {
            i.current = void 0, s.current += 1, x(s.current);
          }, z);
        }), () => {
        }),
        t
      );
    };
    return v(
      n.room,
      (I) => {
        let q;
        return I.status === A.Attached ? I.presence.get({ waitForSync: !0 }).then((_) => {
          t.debug("usePresenceListener(); fetched initial presence data", {
            presenceMembers: _
          }), a.current = _, l(_), f();
        }).catch((_) => {
          const z = _;
          ce(z, ee.RoomIsReleased) || (t.error("usePresenceListener(); error fetching initial presence data", {
            error: _
          }), h(z));
        }).finally(() => {
          t.debug("usePresenceListener(); subscribing internal listener to presence events"), q = I.presence.subscribe(() => {
            R();
          }).unsubscribe;
        }) : (t.debug("usePresenceListener(); not yet attached, subscribing internal listener to presence events"), q = I.presence.subscribe(() => {
          R();
        }).unsubscribe), () => {
          q && (t.debug("usePresenceListener(); cleaning up internal listener"), q());
        };
      },
      t
    ).unmount();
  }, [n, h, f, t]), d(() => {
    if (E)
      return v(
        n.room,
        (R) => {
          t.debug("usePresenceListener(); applying external listener");
          const { unsubscribe: x } = R.presence.subscribe(E);
          return () => {
            t.debug("usePresenceListener(); cleaning up external listener"), x();
          };
        },
        t
      ).unmount();
  }, [n, E, t]), d(() => {
    if (w)
      return v(
        n.room,
        (R) => {
          t.debug("usePresenceListener(); applying onDiscontinuity listener");
          const { off: x } = R.onDiscontinuity(w);
          return () => {
            t.debug("usePresenceListener(); removing onDiscontinuity listener"), x();
          };
        },
        t
      ).unmount();
  }, [n, w, t]), {
    presence: N((R) => R.presence),
    connectionStatus: r,
    connectionError: o,
    roomStatus: u,
    roomError: g,
    error: b,
    presenceData: y
  };
}, ye = (e) => {
  const r = T("useRoom"), o = r.roomName;
  L().debug("useRoom();");
  const { currentStatus: u, error: g } = O({
    onStatusChange: e?.onConnectionStatusChange
  }), t = B({
    onRoomStatusChange: e?.onStatusChange
  }), s = C(() => r.room.then((i) => i.attach()), [r]), m = C(() => r.room.then((i) => i.detach()), [r]);
  return {
    roomName: o,
    room: ue(),
    attach: s,
    detach: m,
    roomStatus: t.status,
    roomError: t.error,
    connectionStatus: u,
    connectionError: g
  };
}, pe = (e) => {
  const { currentStatus: r, error: o } = O({
    onStatusChange: e?.onConnectionStatusChange
  }), n = T("useRoomReactions"), { status: u, error: g } = B(e), t = L();
  t.trace("useRoomReactions();", { params: e });
  const s = S(e?.listener), m = S(e?.onDiscontinuity);
  d(() => {
    if (m)
      return v(
        n.room,
        (c) => {
          t.debug("useRoomReactions(); applying onDiscontinuity listener");
          const { off: a } = c.onDiscontinuity(m);
          return () => {
            t.debug("useRoomReactions(); removing onDiscontinuity listener"), a();
          };
        },
        t
      ).unmount();
  }, [n, m, t]), d(() => {
    if (s)
      return v(
        n.room,
        (c) => {
          t.debug("useRoomReactions(); applying listener");
          const { unsubscribe: a } = c.reactions.subscribe(s);
          return () => {
            t.debug("useRoomReactions(); removing listener"), a();
          };
        },
        t
      ).unmount();
  }, [n, s, t]);
  const i = C(
    (c) => n.room.then((a) => a.reactions.send(c)),
    [n]
  );
  return {
    reactions: N((c) => c.reactions),
    connectionStatus: r,
    connectionError: o,
    roomStatus: u,
    roomError: g,
    send: i
  };
}, ve = (e) => {
  const { currentStatus: r, error: o } = O({
    onStatusChange: e?.onConnectionStatusChange
  }), n = T("useTyping"), { status: u, error: g } = B(e), t = L();
  t.trace("useTyping();");
  const [s, m] = P(/* @__PURE__ */ new Set()), i = S(e?.listener), c = S(e?.onDiscontinuity);
  d(() => (m((l) => l.size === 0 ? l : /* @__PURE__ */ new Set()), v(
    n.room,
    (l) => {
      t.debug("useTyping(); subscribing to typing events");
      const { unsubscribe: p } = l.typing.subscribe((b) => {
        m(b.currentlyTyping);
      });
      if (l.status === A.Attached) {
        const b = l.typing.current();
        t.debug("useTyping(); room attached, getting initial typers", { typing: b }), m(b);
      }
      return () => {
        t.debug("useTyping(); unsubscribing from typing events"), p();
      };
    },
    t
  ).unmount()), [n, t]), d(() => {
    if (c)
      return v(
        n.room,
        (l) => {
          t.debug("useTyping(); applying onDiscontinuity listener");
          const { off: p } = l.onDiscontinuity(c);
          return () => {
            t.debug("useTyping(); removing onDiscontinuity listener"), p();
          };
        },
        t
      ).unmount();
  }, [n, c, t]), d(() => {
    if (i)
      return v(
        n.room,
        (l) => {
          t.debug("useTyping(); applying listener");
          const { unsubscribe: p } = l.typing.subscribe(i);
          return () => {
            t.debug("useTyping(); removing listener"), p();
          };
        },
        t
      ).unmount();
  }, [n, i, t]);
  const a = C(() => n.room.then((l) => l.typing.keystroke()), [n]), y = C(() => n.room.then((l) => l.typing.stop()), [n]);
  return {
    typingIndicators: N((l) => l.typing),
    connectionStatus: r,
    connectionError: o,
    roomStatus: u,
    roomError: g,
    keystroke: a,
    stop: y,
    currentlyTyping: s
  };
};
class W {
  constructor(r) {
    r.trace("RoomReleaseQueue();"), this._queue = [], this._logger = r;
  }
  enqueue(r, o, n) {
    const u = new AbortController(), g = { id: o, options: n, abort: u };
    this._queue.push(g), this._logger.debug("RoomReleaseQueue(); enqueued release", { id: o, options: n }), Promise.resolve().then(() => {
      if (u.signal.aborted) {
        this._logger.debug("RoomReleaseQueue(); aborting release", { id: o, options: n });
        return;
      }
      this._logger.debug("RoomReleaseQueue(); releasing room", { id: o, options: n }), r.rooms.release(o).catch(() => {
      });
    }).catch(() => {
    }).finally(() => {
      this._logger.debug("RoomReleaseQueue(); dequeued release", { id: o, options: n }), this._queue.splice(this._queue.indexOf(g), 1);
    });
  }
  abort(r, o) {
    this._logger.debug("RoomReleaseQueue(); checking for abort", { id: r, options: o, length: this._queue.length });
    const n = this._queue.find((u) => u.id === r && u.options === o);
    n && (this._logger.debug("RoomReleaseQueue(); triggering abort", { id: r, options: o }), n.abort.abort());
  }
  get logger() {
    return this._logger;
  }
}
const Ce = ({
  name: e,
  options: r,
  release: o = !0,
  attach: n = !0,
  children: u
}) => {
  const g = Q(), t = Z(), s = k(() => t.withContext({ roomName: e }), [t, e]);
  s.debug("ChatRoomProvider();", { options: r, release: o, attach: n });
  const [m, i] = P(() => {
    s.debug("ChatRoomProvider(); initializing value", { options: r });
    const a = g.rooms.get(e, r);
    return a.catch(() => {
    }), { room: a, roomName: e, options: r, client: g };
  }), c = D(new W(s));
  return d(() => {
    c.current.logger !== s && (s.debug("ChatRoomProvider(); updating release queue"), c.current = new W(s));
  }, [s]), d(() => {
    s.debug("ChatRoomProvider(); running lifecycle useEffect");
    let a = !1, y;
    const l = c.current;
    l.abort(e, r);
    const p = g.rooms.get(e, r);
    return p.catch(() => {
    }), i((b) => b.client === g && b.roomName === e && b.options === r ? (s.debug("ChatRoomProvider(); no change in room id or options", { options: r }), b) : (s.debug("ChatRoomProvider(); updating value", { options: r }), { room: p, roomName: e, options: r, client: g })), p.then((b) => {
      if (a) {
        s.debug("ChatRoomProvider(); unmounted before room resolved");
        return;
      }
      s.debug("ChatRoomProvider(); room resolved"), y = b, n && (s.debug("ChatRoomProvider(); attaching room"), b.attach().catch(() => {
      }));
    }).catch(() => {
    }), () => {
      if (a = !0, s.debug("ChatRoomProvider(); cleaning up lifecycle useEffect"), o) {
        s.debug("ChatRoomProvider(); releasing room"), l.enqueue(g, e, r);
        return;
      } else y && n && (s.debug("ChatRoomProvider(); detaching room"), y.detach().catch(() => {
      }));
    };
  }, [e, r, s, n, o, g]), /* @__PURE__ */ J(K.Provider, { value: m, children: u });
};
export {
  me as ChatClientProvider,
  K as ChatRoomContext,
  Ce as ChatRoomProvider,
  Q as useChatClient,
  O as useChatConnection,
  be as useMessages,
  he as useOccupancy,
  fe as usePresence,
  Re as usePresenceListener,
  ye as useRoom,
  pe as useRoomReactions,
  ve as useTyping
};
//# sourceMappingURL=ably-chat-react.js.map
