(function(C,o){typeof exports=="object"&&typeof module<"u"?o(exports,require("react"),require("ably"),require("react/jsx-runtime")):typeof define=="function"&&define.amd?define(["exports","react","ably","react/jsx-runtime"],o):(C=typeof globalThis<"u"?globalThis:C||self,o(C.AblyChat={},C.React,C.Ably,C.jsxRuntime))})(this,function(C,o,$,Q){"use strict";function V(e){const r=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(e){for(const s in e)if(s!=="default"){const n=Object.getOwnPropertyDescriptor(e,s);Object.defineProperty(r,s,n.get?n:{enumerable:!0,get:()=>e[s]})}}return r.default=e,Object.freeze(r)}const H=V(o),B=V($),N=o.createContext(void 0),U=Symbol.for("__ABLY_CHAT_CLIENT_CONTEXT__"),Y=typeof globalThis>"u"?{}:globalThis;function Z(){let e=Y[U];return e??=Y[U]=o.createContext({}),e}const z=Z(),G="default",ee=({children:e,client:r})=>{const s=H.useContext(z),n=H.useMemo(()=>{r.addReactAgent();const i=globalThis.__ABLY_CHAT_REACT_UI_COMPONENTS_VERSION__;return typeof i=="string"&&r.addAgentWithVersion("chat-ui-kit",i),{...s,[G]:{client:r}}},[r,s]);return Q.jsx(z.Provider,{value:n,children:e})},j=()=>{const e=o.useContext(z)[G];if(!e)throw new B.ErrorInfo("useChatClient hook must be used within a chat client provider",4e4,400);return e.client},R=e=>{const r=o.useRef(e);o.useEffect(()=>{r.current=e});const s=o.useCallback((...n)=>{r.current&&r.current(...n)},[]);return e?s:void 0},P=e=>{const r=o.useContext(N);if(!r)throw new B.ErrorInfo(`${e} hook must be used within a <ChatRoomProvider>`,4e4,400);return r},W=()=>{const e=j();return o.useMemo(()=>e.logger,[e])},D=()=>{const e=P("useRoomLogger"),r=j();return o.useMemo(()=>r.logger.withContext({roomName:e.roomName}),[r,e])},w=e=>{const r=j(),s=W();s.trace("useChatConnection();",e);const[n,i]=o.useState(r.connection.status),[l,t]=o.useState(r.connection.error),[u,f]=o.useState(r.connection);o.useEffect(()=>{f(r.connection),t(r.connection.error),i(r.connection.status)},[r]);const a=R(e?.onStatusChange);return o.useEffect(()=>{s.debug("useChatConnection(); applying internal listener");const{off:c}=r.connection.onStatusChange(g=>{i(g.current),t(g.error)});return()=>{s.debug("useChatConnection(); cleaning up listener"),c()}},[r.connection,s]),o.useEffect(()=>{if(!a)return;s.debug("useChatConnection(); applying client listener");const{off:c}=r.connection.onStatusChange(a);return()=>{s.debug("useChatConnection(); cleaning up client listener"),c()}},[r.connection,s,a]),{currentStatus:n,error:l,connection:u}};class te{constructor(r,s,n){this._unmounted=!1,this._onResolve=s,this._logger=n,this.mount(r).catch(i=>{this._logger.trace("DefaultRoomPromise(); mount error",{error:i})})}async mount(r){this._logger.debug("DefaultRoomPromise(); mount");try{const s=await r;if(this._unmounted)return;this._logger.debug("DefaultRoomPromise(); mount resolved"),this._onUnmount=this._onResolve(s)}catch(s){this._logger.error("DefaultRoomPromise(); mount error",{error:s})}}unmount(){return this._unmounted?()=>{}:()=>{this._logger.debug("DefaultRoomPromise(); unmount"),this._unmounted=!0,this._onUnmount?.()}}}function p(e,r,s){return new te(e,r,s)}const ne=e=>{const r=o.useRef(e);return o.useEffect(()=>{r.current=e}),o.useCallback((...s)=>r.current(...s),[])},re=()=>{const[e,r]=o.useState(),s=P("useEventualRoom"),n=D();return n.trace("useEventualRoom();"),o.useEffect(()=>{n.debug("useEventualRoom(); running useEffect");let i=!1;return s.room.then(l=>{if(i){n.debug("useEventualRoom(); already unmounted");return}n.debug("useEventualRoom(); resolved"),r(l)}).catch(l=>{n.error("Failed to get room",{error:l})}),()=>{n.debug("useEventualRoom(); cleanup"),i=!0}},[s,n]),e},A=e=>{const[r,s]=o.useState(),n=P("useEventualRoomProperty"),i=D();i.trace("useEventualRoomProperty();");const l=ne(e);return o.useEffect(()=>{let t=!1;return i.debug("useEventualRoomProperty(); running useEffect"),n.room.then(u=>{if(t){i.debug("useEventualRoomProperty(); already unmounted");return}i.debug("useEventualRoomProperty(); resolved"),s(l(u))}).catch(u=>{i.error("Failed to get room",{error:u})}),()=>{i.debug("useEventualRoomProperty(); cleanup"),t=!0}},[n,i,l]),r};B.Realtime.EventEmitter;var I=(e=>(e.Initializing="initializing",e.Initialized="initialized",e.Attaching="attaching",e.Attached="attached",e.Detaching="detaching",e.Detached="detached",e.Suspended="suspended",e.Failed="failed",e.Releasing="releasing",e.Released="released",e))(I||{});const x=e=>{const r=P("useRoomStatus"),[s,n]=o.useState(I.Initializing),[i,l]=o.useState(),t=D(),u=R(e?.onRoomStatusChange);return o.useEffect(()=>p(r.room,a=>{t.debug("useRoomStatus(); subscribing internal listener"),n(a.status),l(a.error);const{off:c}=a.onStatusChange(g=>{t.debug("useRoomStatus(); status change",g),n(g.current),l(g.error)});return()=>{t.debug("useRoomStatus(); unsubscribing internal listener"),c()}},t).unmount(),[r,t]),o.useEffect(()=>p(r.room,a=>{let c;return u&&(t.debug("useRoomStatus(); subscribing to status changes"),c=a.onStatusChange(u).off),t.debug("useRoomStatus(); setting initial status",{status:a.status}),u&&(t.debug("useRoomStatus(); sending initial status event"),u({current:a.status,previous:I.Initializing,error:a.error})),()=>{t.debug("useRoomStatus(); unmounting"),c&&(t.debug("useRoomStatus(); unsubscribing from status changes"),c())}},t).unmount(),[r,t,u]),{status:s,error:i}},oe=e=>{const{currentStatus:r,error:s}=w({onStatusChange:e?.onConnectionStatusChange}),n=P("useMessages"),{status:i,error:l}=x(e),t=D();t.trace("useMessages();",{params:e});const u=R(e?.listener),f=R(e?.reactionsListener),a=R(e?.rawReactionsListener),c=R(e?.onDiscontinuity),g=o.useCallback(b=>n.room.then(h=>h.messages.send(b)),[n]),S=o.useCallback((b,h)=>n.room.then(y=>y.messages.delete(b,h)),[n]),d=o.useCallback(b=>n.room.then(h=>h.messages.history(b)),[n]),v=o.useCallback((b,h,y)=>n.room.then(T=>T.messages.update(b,h,y)),[n]),m=o.useCallback((b,h)=>n.room.then(y=>y.messages.reactions.send(b,h)),[n]),M=o.useCallback((b,h)=>n.room.then(y=>y.messages.reactions.delete(b,h)),[n]),[_,L]=o.useState();return o.useEffect(()=>{if(u)return p(n.room,b=>{let h=!1;t.debug("useMessages(); applying listener");const y=b.messages.subscribe(u);return L(()=>{if(t.debug("useMessages(); setting historyBeforeSubscribe state",{status:b.status,unmounted:h}),!h)return T=>(t.debug("useMessages(); historyBeforeSubscribe called"),h?Promise.reject(new B.ErrorInfo("component unmounted",4e4,400)):y.historyBeforeSubscribe(T))}),()=>{t.debug("useMessages(); removing listener and historyBeforeSubscribe state"),h=!0,y.unsubscribe(),L(void 0)}},t).unmount()},[n,t,u]),o.useEffect(()=>{if(c)return p(n.room,b=>{t.debug("useMessages(); applying onDiscontinuity listener");const{off:h}=b.onDiscontinuity(c);return()=>{t.debug("useMessages(); removing onDiscontinuity listener"),h()}},t).unmount()},[n,t,c]),o.useEffect(()=>{if(f)return p(n.room,b=>{t.debug("useMessages(); applying reactions listener");const{unsubscribe:h}=b.messages.reactions.subscribe(f);return()=>{t.debug("useMessages(); removing reactions listener"),h()}},t).unmount()},[n,t,f]),o.useEffect(()=>{if(a)return p(n.room,b=>{t.debug("useMessages(); applying raw reactions listener");const{unsubscribe:h}=b.messages.reactions.subscribeRaw(a);return()=>{t.debug("useMessages(); removing raw reactions listener"),h()}},t).unmount()},[n,t,a]),{connectionStatus:r,connectionError:s,roomStatus:i,roomError:l,send:g,update:v,history:d,deleteMessage:S,sendReaction:m,deleteReaction:M,historyBeforeSubscribe:_,messages:A(b=>b.messages)}},se=e=>{const{currentStatus:r,error:s}=w({onStatusChange:e?.onConnectionStatusChange}),n=P("useOccupancy"),{status:i,error:l}=x(e),t=D();t.trace("useOccupancy();",{params:e});const[u,f]=o.useState({connections:0,presenceMembers:0}),a=R(e?.listener),c=R(e?.onDiscontinuity);return o.useEffect(()=>{if(c)return p(n.room,g=>{t.debug("useOccupancy(); applying onDiscontinuity listener");const{off:S}=g.onDiscontinuity(c);return()=>{t.debug("useOccupancy(); removing onDiscontinuity listener"),S()}},t).unmount()},[n,c,t]),o.useEffect(()=>p(n.room,g=>{t.debug("useOccupancy(); applying internal listener");const S=g.occupancy.current();f({connections:S?.connections??0,presenceMembers:S?.presenceMembers??0});const{unsubscribe:d}=g.occupancy.subscribe(v=>{f({connections:v.occupancy.connections,presenceMembers:v.occupancy.presenceMembers})});return()=>{t.debug("useOccupancy(); cleaning up internal listener"),d()}},t).unmount(),[n,t]),o.useEffect(()=>{if(a)return p(n.room,g=>{t.debug("useOccupancy(); applying listener");const{unsubscribe:S}=g.occupancy.subscribe(a);return()=>{t.debug("useOccupancy(); cleaning up listener"),S()}},t).unmount()},[a,n,t]),{occupancy:A(g=>g.occupancy),connectionStatus:r,connectionError:s,roomStatus:i,roomError:l,connections:u.connections,presenceMembers:u.presenceMembers}};var F=(e=>(e.Initialized="initialized",e.Connecting="connecting",e.Connected="connected",e.Disconnected="disconnected",e.Suspended="suspended",e.Failed="failed",e))(F||{});const X=new Set([F.Suspended,F.Failed]),ue=e=>{const{currentStatus:r,error:s}=w({onStatusChange:e?.onConnectionStatusChange}),n=P("usePresence"),{status:i,error:l}=x(e),t=D();t.trace("usePresence();",{params:e});const[u,f]=o.useState(!1),[a,c]=o.useState(),g=o.useRef({roomStatus:i,connectionStatus:r}),S=R(e?.onDiscontinuity),d=o.useRef(e);o.useEffect(()=>{d.current=e},[e]),o.useEffect(()=>{g.current={roomStatus:i,connectionStatus:r}},[i,r]),o.useEffect(()=>(t.debug("usePresence(); entering room"),p(n.room,m=>m.status===I.Attached&&!X.has(r)?(m.presence.enter(d.current?.enterWithData).then(()=>{t.debug("usePresence(); entered room"),f(!0),c(void 0)}).catch(_=>{t.error("usePresence(); error entering room",{error:_}),c(_)}),()=>{const _=m.status===I.Attached&&!X.has(g.current.connectionStatus);t.debug("usePresence(); unmounting",{canLeavePresence:_,roomStatus:i,connectionStatus:r}),_&&m.presence.leave(d.current?.leaveWithData).then(()=>{t.debug("usePresence(); left room"),f(!1),c(void 0)}).catch(L=>{t.error("usePresence(); error leaving room",{error:L}),c(L)})}):(t.debug("usePresence(); skipping enter room",{roomStatus:i,connectionStatus:r}),()=>{}),t).unmount()),[n,r,i,t]),o.useEffect(()=>{if(S)return p(n.room,m=>{const{off:M}=m.onDiscontinuity(S);return()=>{t.debug("usePresence(); removing onDiscontinuity listener"),M()}},t).unmount()},[n,S,t]);const v=o.useCallback(m=>n.room.then(M=>M.presence.update(m).then(()=>{f(!0),c(void 0)})),[n]);return{presence:A(m=>m.presence),connectionStatus:r,connectionError:s,roomStatus:i,roomError:l,update:v,isPresent:u,error:a}};var J=(e=>(e[e.BadRequest=4e4]="BadRequest",e[e.MessageRejectedByBeforePublishRule=42211]="MessageRejectedByBeforePublishRule",e[e.MessageRejectedByModeration=42213]="MessageRejectedByModeration",e[e.RoomDiscontinuity=102100]="RoomDiscontinuity",e[e.RoomInFailedState=102101]="RoomInFailedState",e[e.RoomIsReleasing=102102]="RoomIsReleasing",e[e.RoomIsReleased=102103]="RoomIsReleased",e[e.RoomReleasedBeforeOperationCompleted=102106]="RoomReleasedBeforeOperationCompleted",e))(J||{});const ie=(e,r)=>e.code===r,ce=1500,ae=3e4,ge=5,le=e=>{const{currentStatus:r,error:s}=w({onStatusChange:e?.onConnectionStatusChange}),n=P("usePresenceListener"),{status:i,error:l}=x(e),t=D();t.trace("usePresenceListener();");const u=o.useRef(0),f=o.useRef(0),a=o.useRef(void 0),c=o.useRef(0),g=o.useRef([]),[S,d]=o.useState([]),v=o.useRef(void 0),[m,M]=o.useState(),_=R(e?.listener),L=R(e?.onDiscontinuity),b=o.useCallback(y=>{t.debug("usePresenceListener(); setting error state",{error:y}),v.current=y,M(y)},[t]),h=o.useCallback(()=>{t.debug("usePresenceListener(); clearing error state"),v.current=void 0,M(void 0)},[t]);return o.useEffect(()=>{const y=()=>{u.current+=1,a.current&&(clearTimeout(a.current),a.current=void 0,c.current=0),T(u.current)},T=O=>{p(n.room,k=>(k.presence.get({waitForSync:!0}).then(E=>{t.debug("usePresenceListener(); fetched presence data",{presenceMembers:E}),a.current&&(clearTimeout(a.current),a.current=void 0,c.current=0),!(f.current>=O)&&(f.current=O,g.current=E,d(E),v.current&&h())}).catch(()=>{if(!(c.current<ge)){t.error("usePresenceListener(); failed to fetch presence data after max retries"),b(new B.ErrorInfo("failed to fetch presence data after max retries",5e4,500));return}if(a.current){t.debug("usePresenceListener(); waiting for retry but new event received");return}const q=Math.min(ae,ce*Math.pow(2,c.current));c.current+=1,t.debug("usePresenceListener(); retrying to fetch presence data",{numRetries:c.current}),a.current=setTimeout(()=>{a.current=void 0,u.current+=1,T(u.current)},q)}),()=>{}),t)};return p(n.room,O=>{let k;return O.status===I.Attached?O.presence.get({waitForSync:!0}).then(E=>{t.debug("usePresenceListener(); fetched initial presence data",{presenceMembers:E}),g.current=E,d(E),h()}).catch(E=>{const q=E;ie(q,J.RoomIsReleased)||(t.error("usePresenceListener(); error fetching initial presence data",{error:E}),b(q))}).finally(()=>{t.debug("usePresenceListener(); subscribing internal listener to presence events"),k=O.presence.subscribe(()=>{y()}).unsubscribe}):(t.debug("usePresenceListener(); not yet attached, subscribing internal listener to presence events"),k=O.presence.subscribe(()=>{y()}).unsubscribe),()=>{k&&(t.debug("usePresenceListener(); cleaning up internal listener"),k())}},t).unmount()},[n,b,h,t]),o.useEffect(()=>{if(_)return p(n.room,y=>{t.debug("usePresenceListener(); applying external listener");const{unsubscribe:T}=y.presence.subscribe(_);return()=>{t.debug("usePresenceListener(); cleaning up external listener"),T()}},t).unmount()},[n,_,t]),o.useEffect(()=>{if(L)return p(n.room,y=>{t.debug("usePresenceListener(); applying onDiscontinuity listener");const{off:T}=y.onDiscontinuity(L);return()=>{t.debug("usePresenceListener(); removing onDiscontinuity listener"),T()}},t).unmount()},[n,L,t]),{presence:A(y=>y.presence),connectionStatus:r,connectionError:s,roomStatus:i,roomError:l,error:m,presenceData:S}},de=e=>{const r=P("useRoom"),s=r.roomName;D().debug("useRoom();");const{currentStatus:i,error:l}=w({onStatusChange:e?.onConnectionStatusChange}),t=x({onRoomStatusChange:e?.onStatusChange}),u=o.useCallback(()=>r.room.then(a=>a.attach()),[r]),f=o.useCallback(()=>r.room.then(a=>a.detach()),[r]);return{roomName:s,room:re(),attach:u,detach:f,roomStatus:t.status,roomError:t.error,connectionStatus:i,connectionError:l}},fe=e=>{const{currentStatus:r,error:s}=w({onStatusChange:e?.onConnectionStatusChange}),n=P("useRoomReactions"),{status:i,error:l}=x(e),t=D();t.trace("useRoomReactions();",{params:e});const u=R(e?.listener),f=R(e?.onDiscontinuity);o.useEffect(()=>{if(f)return p(n.room,c=>{t.debug("useRoomReactions(); applying onDiscontinuity listener");const{off:g}=c.onDiscontinuity(f);return()=>{t.debug("useRoomReactions(); removing onDiscontinuity listener"),g()}},t).unmount()},[n,f,t]),o.useEffect(()=>{if(u)return p(n.room,c=>{t.debug("useRoomReactions(); applying listener");const{unsubscribe:g}=c.reactions.subscribe(u);return()=>{t.debug("useRoomReactions(); removing listener"),g()}},t).unmount()},[n,u,t]);const a=o.useCallback(c=>n.room.then(g=>g.reactions.send(c)),[n]);return{reactions:A(c=>c.reactions),connectionStatus:r,connectionError:s,roomStatus:i,roomError:l,send:a}},me=e=>{const{currentStatus:r,error:s}=w({onStatusChange:e?.onConnectionStatusChange}),n=P("useTyping"),{status:i,error:l}=x(e),t=D();t.trace("useTyping();");const[u,f]=o.useState(new Set),a=R(e?.listener),c=R(e?.onDiscontinuity);o.useEffect(()=>(f(d=>d.size===0?d:new Set),p(n.room,d=>{t.debug("useTyping(); subscribing to typing events");const{unsubscribe:v}=d.typing.subscribe(m=>{f(m.currentlyTyping)});if(d.status===I.Attached){const m=d.typing.current();t.debug("useTyping(); room attached, getting initial typers",{typing:m}),f(m)}return()=>{t.debug("useTyping(); unsubscribing from typing events"),v()}},t).unmount()),[n,t]),o.useEffect(()=>{if(c)return p(n.room,d=>{t.debug("useTyping(); applying onDiscontinuity listener");const{off:v}=d.onDiscontinuity(c);return()=>{t.debug("useTyping(); removing onDiscontinuity listener"),v()}},t).unmount()},[n,c,t]),o.useEffect(()=>{if(a)return p(n.room,d=>{t.debug("useTyping(); applying listener");const{unsubscribe:v}=d.typing.subscribe(a);return()=>{t.debug("useTyping(); removing listener"),v()}},t).unmount()},[n,a,t]);const g=o.useCallback(()=>n.room.then(d=>d.typing.keystroke()),[n]),S=o.useCallback(()=>n.room.then(d=>d.typing.stop()),[n]);return{typingIndicators:A(d=>d.typing),connectionStatus:r,connectionError:s,roomStatus:i,roomError:l,keystroke:g,stop:S,currentlyTyping:u}};class K{constructor(r){r.trace("RoomReleaseQueue();"),this._queue=[],this._logger=r}enqueue(r,s,n){const i=new AbortController,l={id:s,options:n,abort:i};this._queue.push(l),this._logger.debug("RoomReleaseQueue(); enqueued release",{id:s,options:n}),Promise.resolve().then(()=>{if(i.signal.aborted){this._logger.debug("RoomReleaseQueue(); aborting release",{id:s,options:n});return}this._logger.debug("RoomReleaseQueue(); releasing room",{id:s,options:n}),r.rooms.release(s).catch(()=>{})}).catch(()=>{}).finally(()=>{this._logger.debug("RoomReleaseQueue(); dequeued release",{id:s,options:n}),this._queue.splice(this._queue.indexOf(l),1)})}abort(r,s){this._logger.debug("RoomReleaseQueue(); checking for abort",{id:r,options:s,length:this._queue.length});const n=this._queue.find(i=>i.id===r&&i.options===s);n&&(this._logger.debug("RoomReleaseQueue(); triggering abort",{id:r,options:s}),n.abort.abort())}get logger(){return this._logger}}const be=({name:e,options:r,release:s=!0,attach:n=!0,children:i})=>{const l=j(),t=W(),u=o.useMemo(()=>t.withContext({roomName:e}),[t,e]);u.debug("ChatRoomProvider();",{options:r,release:s,attach:n});const[f,a]=o.useState(()=>{u.debug("ChatRoomProvider(); initializing value",{options:r});const g=l.rooms.get(e,r);return g.catch(()=>{}),{room:g,roomName:e,options:r,client:l}}),c=o.useRef(new K(u));return o.useEffect(()=>{c.current.logger!==u&&(u.debug("ChatRoomProvider(); updating release queue"),c.current=new K(u))},[u]),o.useEffect(()=>{u.debug("ChatRoomProvider(); running lifecycle useEffect");let g=!1,S;const d=c.current;d.abort(e,r);const v=l.rooms.get(e,r);return v.catch(()=>{}),a(m=>m.client===l&&m.roomName===e&&m.options===r?(u.debug("ChatRoomProvider(); no change in room id or options",{options:r}),m):(u.debug("ChatRoomProvider(); updating value",{options:r}),{room:v,roomName:e,options:r,client:l})),v.then(m=>{if(g){u.debug("ChatRoomProvider(); unmounted before room resolved");return}u.debug("ChatRoomProvider(); room resolved"),S=m,n&&(u.debug("ChatRoomProvider(); attaching room"),m.attach().catch(()=>{}))}).catch(()=>{}),()=>{if(g=!0,u.debug("ChatRoomProvider(); cleaning up lifecycle useEffect"),s){u.debug("ChatRoomProvider(); releasing room"),d.enqueue(l,e,r);return}else S&&n&&(u.debug("ChatRoomProvider(); detaching room"),S.detach().catch(()=>{}))}},[e,r,u,n,s,l]),Q.jsx(N.Provider,{value:f,children:i})};C.ChatClientProvider=ee,C.ChatRoomContext=N,C.ChatRoomProvider=be,C.useChatClient=j,C.useChatConnection=w,C.useMessages=oe,C.useOccupancy=se,C.usePresence=ue,C.usePresenceListener=le,C.useRoom=de,C.useRoomReactions=fe,C.useTyping=me,Object.defineProperty(C,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=ably-chat-react.umd.cjs.map
