{"version":3,"file":"ably-chat-react.umd.cjs","sources":["../../src/react/contexts/chat-room-context.tsx","../../src/react/contexts/chat-client-context.tsx","../../src/react/providers/chat-client-provider.tsx","../../src/react/hooks/use-chat-client.ts","../../src/react/helper/use-event-listener-ref.ts","../../src/react/helper/use-room-context.ts","../../src/react/hooks/use-logger.ts","../../src/react/hooks/use-chat-connection.ts","../../src/react/helper/room-promise.ts","../../src/react/helper/use-stable-reference.ts","../../src/react/helper/use-eventual-room.ts","../../src/core/utils/event-emitter.ts","../../src/core/room-status.ts","../../src/react/helper/use-room-status.ts","../../src/react/hooks/use-messages.ts","../../src/react/hooks/use-occupancy.ts","../../src/core/connection.ts","../../src/react/hooks/use-presence.ts","../../src/core/errors.ts","../../src/react/hooks/use-presence-listener.ts","../../src/react/hooks/use-room.ts","../../src/react/hooks/use-room-reactions.ts","../../src/react/hooks/use-typing.ts","../../src/react/providers/chat-room-provider.tsx"],"sourcesContent":["import { createContext } from 'react';\n\nimport { ChatClient } from '../../core/chat.js';\nimport { Room } from '../../core/room.js';\nimport { RoomOptions } from '../../core/room-options.js';\n\n/**\n * Data type for {@link ChatRoomContext}.\n */\nexport interface ChatRoomContextType {\n  /**\n   * Promise that resolves to the chat room.\n   */\n  room: Promise<Room>;\n\n  /**\n   * The unique identifier of the room that promise will resolve to.\n   */\n  roomName: string;\n\n  /**\n   * Options used to create the room.\n   */\n  options?: RoomOptions;\n\n  /**\n   * The chat client used to create the room.\n   */\n  client: ChatClient;\n}\n\n/**\n * {@link ChatRoomContext} is used to keep a chat room in a React context. Use\n * {@link ChatRoomProvider} to set a room in this context and {@link useRoom} to\n * use the room from the context.\n */\nexport const ChatRoomContext = createContext<ChatRoomContextType | undefined>(undefined);\n","import React from 'react';\n\nimport { ChatClient } from '../../core/chat.js';\n\n/**\n * The Context key to handle global context for the {@link ChatClient}.\n * Only a single instance the {@link ChatClientContext} should exist to avoid issues resulting from multiple identical contexts,\n * e.g., a {@link ChatClient} instance added in one context, and then attempting to retrieve it from a different context.\n *\n */\nconst contextKey = Symbol.for('__ABLY_CHAT_CLIENT_CONTEXT__');\n\n/**\n * Extends GlobalThis interface with chat context.\n * The {@link ChatClientContext} is created once and stored in the global state to ensure a single context instance.\n *\n * @property {React.Context<ChatClientContextValue> | undefined} contextKey Ably Chat client context.\n */\ninterface GlobalThis {\n  [contextKey]?: React.Context<ChatClientContextValue>;\n}\n\n/**\n * Object to encapsulate global context.\n * Uses {@link GlobalThis} if defined.\n * Protects against creating multiple instances of the {@link ChatClientContext} due to misconfigurations\n * in the module bundler or package manager configurations.\n *\n */\nconst globalObjectForContext: GlobalThis = typeof globalThis === 'undefined' ? {} : (globalThis as GlobalThis);\n\n/**\n * Props for the chat client context provider.\n */\nexport interface ChatClientContextProviderProps {\n  /**\n   Instance of the {@link ChatClient}\n   */\n  client: ChatClient;\n}\n\n/**\n * Record of provider props for each chat client context provider, indexed by provider id.\n *\n */\nexport type ChatClientContextValue = Record<string, ChatClientContextProviderProps>;\n\n/**\n * Returns a {@link ChatClientContext}.\n * Retrieve the context from the global object if initialized,\n * else, initialize and store the context in the global object.\n *\n * @return {React.Context<ChatClientContextValue>} Global context for {@link ChatClient}.\n *\n */\nfunction getChatContext(): React.Context<ChatClientContextValue> {\n  let context = globalObjectForContext[contextKey];\n\n  context ??= globalObjectForContext[contextKey] = React.createContext<ChatClientContextValue>({});\n\n  return context;\n}\n\n/**\n * Global context for {@link ChatClientProvider}.\n * Access point for {@link ChatClient} context in the application.\n *\n * @type {React.Context<ChatClientContextValue>}\n */\nexport const ChatClientContext: React.Context<ChatClientContextValue> = getChatContext();\n","import * as React from 'react';\nimport { ReactNode } from 'react';\n\nimport { ChatClient } from '../../core/chat.js';\nimport { ChatClientContext, ChatClientContextValue } from '../contexts/chat-client-context.js';\n\n/**\n * The default identifier for the {@link ChatClientContext}.\n */\nexport const DEFAULT_CHAT_CLIENT_ID = 'default';\n\n/**\n * Props for the {@link ChatClientProvider} component.\n */\nexport interface ChatClientProviderProps {\n  /**\n   * The child components to be rendered within this provider.\n   */\n  children?: ReactNode | ReactNode[] | null;\n\n  /**\n   * An instance of the {@link ChatClient} to be used in the provider.\n   */\n  client: ChatClient;\n}\n\n/**\n * Returns a React component that provides a {@link ChatClient} in a React context to the component subtree.\n * Updates the context value when the client prop changes.\n *\n * @param {ChatClientProviderProps} props - The props for the {@link ChatClientProvider} component.\n *\n * @returns {ChatClientProvider} component.\n */\nexport const ChatClientProvider = ({ children, client }: ChatClientProviderProps) => {\n  const context = React.useContext(ChatClientContext);\n\n  const value: ChatClientContextValue = React.useMemo(() => {\n    (client as unknown as { addReactAgent(): void }).addReactAgent();\n\n    const uiKitVersion = globalThis.__ABLY_CHAT_REACT_UI_COMPONENTS_VERSION__;\n    if (typeof uiKitVersion === 'string') {\n      (\n        client as unknown as {\n          addAgentWithVersion(agent: string, version: string): void;\n        }\n      ).addAgentWithVersion('chat-ui-kit', uiKitVersion);\n    }\n\n    return { ...context, [DEFAULT_CHAT_CLIENT_ID]: { client: client } };\n  }, [client, context]);\n\n  return <ChatClientContext.Provider value={value}>{children}</ChatClientContext.Provider>;\n};\n","import * as Ably from 'ably';\nimport React from 'react';\n\nimport { ChatClient } from '../../core/chat.js';\nimport { ChatClientContext } from '../contexts/chat-client-context.js';\nimport { DEFAULT_CHAT_CLIENT_ID } from '../providers/chat-client-provider.js';\n\n/**\n * Hook to access the chat client provided the current {@link ChatClientProvider}.\n * This hook must be used within a {@link ChatClientProvider}.\n *\n * @throws {ErrorInfo} When the hook is not used within a {@link ChatClientProvider}.\n *\n * @returns {ChatClient} The {@link ChatClient} instance provided by the context.\n *\n */\nexport const useChatClient = (): ChatClient => {\n  const context = React.useContext(ChatClientContext)[DEFAULT_CHAT_CLIENT_ID];\n  if (!context) {\n    throw new Ably.ErrorInfo('useChatClient hook must be used within a chat client provider', 40000, 400);\n  }\n  return context.client;\n};\n","import { useCallback, useEffect, useRef } from 'react';\n\n/**\n * The type of a callback function that can be stored in the reference.\n */\ntype Callback<CallbackArguments extends unknown[]> = (...args: CallbackArguments) => void;\n\n/**\n * A hook that creates a reference to an event listener callback function. It is used to stabilize the reference\n * across renders, so that listeners don't get unsubscribed and resubscribed on every render when passed in as a prop.\n *\n * For example, doing this:\n *\n * ```jsx\n *   export function MySubscription() {\n *     useHookWithListener(() => {})\n *\n *     return <div>My Subscription</div>\n *   }\n * ```\n *\n * Where the `useHookWithListener` hook is defined as:\n *\n * ```jsx\n *  export function useHookWithListener(listener) {\n *    const listenerRef = useEventListenerRef(listener);\n *    useEffect(() => {\n *      // Use the listenerRef\n *    }, [listenerRef]);\n * }\n * ```\n *\n * Will ensure that the listener is not unsubscribed and resubscribed on every render (i.e. the useEffect will not be called\n * on every render).\n *\n * We allow for the callback to be undefined, as callbacks in the majority of our hooks are optional. In this instance we return undefined,\n * so that subscriptions will be unwound by the useEffect hook that's using them.\n *\n * @internal\n * @template Arguments - The type of arguments accepted by the callback function.\n * @param callback - The callback function to be stored in the reference.\n * @returns A static callback function that wraps the provided callback function, or undefined if no callback is provided.\n */\nexport const useEventListenerRef = <Arguments extends unknown[]>(\n  callback?: Callback<Arguments>,\n): Callback<Arguments> | undefined => {\n  const ref = useRef<Callback<Arguments> | undefined>(callback);\n  useEffect(() => {\n    ref.current = callback;\n  });\n\n  const returnVal = useCallback((...args: Arguments) => {\n    if (ref.current) {\n      ref.current(...args);\n    }\n  }, []);\n\n  return callback ? returnVal : undefined;\n};\n","import * as Ably from 'ably';\nimport { useContext } from 'react';\n\nimport { ChatRoomContext, ChatRoomContextType } from '../contexts/chat-room-context.js';\n\n/**\n * A hook that returns the current ChatRoomContext. This should be used within a ChatRoomProvider.\n *\n * @internal\n * @param callingHook The name of the hook that is calling this function, for logging purposes.\n * @throws {@link Ably.ErrorInfo} if the hook is not used within a ChatRoomProvider.\n * @returns The ChatRoomContext.\n */\nexport const useRoomContext = (callingHook: string): ChatRoomContextType => {\n  const context = useContext(ChatRoomContext);\n  if (!context) {\n    throw new Ably.ErrorInfo(`${callingHook} hook must be used within a <ChatRoomProvider>`, 40000, 400);\n  }\n\n  return context;\n};\n","import { useMemo } from 'react';\n\nimport { Logger } from '../../core/logger.js';\nimport { useRoomContext } from '../helper/use-room-context.js';\nimport { useChatClient } from './use-chat-client.js';\n/**\n * A hook that provides access to the {@link Logger} instance of the {@link ChatClient}.\n * It will use the instance belonging to the {@link ChatClient} in the nearest {@link ChatClientProvider} in the component tree.\n * @internal\n *\n * @returns Logger - The logger instance.\n */\nexport const useLogger = (): Logger => {\n  const chatClient = useChatClient();\n  return useMemo(() => (chatClient as unknown as { logger: Logger }).logger, [chatClient]);\n};\n\n/**\n * A hook that returns a logger with the room context pre-applied.\n * @internal\n *\n * @returns Logger - The logger instance.\n */\nexport const useRoomLogger = (): Logger => {\n  const roomContext = useRoomContext('useRoomLogger');\n  const chatClient = useChatClient();\n\n  return useMemo(\n    () => (chatClient as unknown as { logger: Logger }).logger.withContext({ roomName: roomContext.roomName }),\n    [chatClient, roomContext],\n  );\n};\n","import { ErrorInfo } from 'ably';\nimport { useEffect, useState } from 'react';\n\nimport {\n  Connection,\n  ConnectionStatus,\n  ConnectionStatusChange,\n  ConnectionStatusListener,\n} from '../../core/connection.js';\nimport { useEventListenerRef } from '../helper/use-event-listener-ref.js';\nimport { useChatClient } from './use-chat-client.js';\nimport { useLogger } from './use-logger.js';\n\n/**\n * The options for the {@link useChatConnection} hook.\n */\nexport interface UseChatConnectionOptions {\n  /**\n   * A callback that will be called whenever the connection status changes.\n   * The listener is removed when the component unmounts.\n   */\n  onStatusChange?: ConnectionStatusListener;\n}\n\n/**\n * The response from the {@link useChatConnection} hook.\n */\nexport interface UseChatConnectionResponse {\n  /**\n   * The current status of the {@link connection}.\n   */\n  currentStatus: ConnectionStatus;\n\n  /**\n   * An error that provides a reason why the {@link connection} has entered the new status, if applicable.\n   */\n  error?: ErrorInfo;\n\n  /**\n   * The current Ably {@link Connection} instance.\n   */\n  connection: Connection;\n}\n\n/**\n * A hook that provides the current connection status and error, and allows the user to listen to connection status changes.\n *\n * @param options - The options for the hook\n * @returns The current connection status and error, as well as the {@link Connection} instance.\n */\nexport const useChatConnection = (options?: UseChatConnectionOptions): UseChatConnectionResponse => {\n  const chatClient = useChatClient();\n  const logger = useLogger();\n  logger.trace('useChatConnection();', options);\n\n  // Initialize states with the current values from chatClient\n  const [currentStatus, setCurrentStatus] = useState<ConnectionStatus>(chatClient.connection.status);\n  const [error, setError] = useState<ErrorInfo | undefined>(chatClient.connection.error);\n  const [connection, setConnection] = useState<Connection>(chatClient.connection);\n\n  // Update the states when the chatClient changes\n  useEffect(() => {\n    setConnection(chatClient.connection);\n    setError(chatClient.connection.error);\n    setCurrentStatus(chatClient.connection.status);\n  }, [chatClient]);\n\n  // Create stable references for the listeners\n  const onStatusChangeRef = useEventListenerRef(options?.onStatusChange);\n\n  // Apply the listener to the chatClient's connection status changes to keep the state update across re-renders\n  useEffect(() => {\n    logger.debug('useChatConnection(); applying internal listener');\n    const { off } = chatClient.connection.onStatusChange((change: ConnectionStatusChange) => {\n      // Update states with new values\n      setCurrentStatus(change.current);\n      setError(change.error);\n    });\n    // Cleanup listener on un-mount\n    return () => {\n      logger.debug('useChatConnection(); cleaning up listener');\n      off();\n    };\n  }, [chatClient.connection, logger]);\n\n  // Register the listener for the user-provided onStatusChange callback\n  useEffect(() => {\n    if (!onStatusChangeRef) return;\n    logger.debug('useChatConnection(); applying client listener');\n    const { off } = chatClient.connection.onStatusChange(onStatusChangeRef);\n\n    return () => {\n      logger.debug('useChatConnection(); cleaning up client listener');\n      off();\n    };\n  }, [chatClient.connection, logger, onStatusChangeRef]);\n\n  return {\n    currentStatus,\n    error,\n    connection,\n  };\n};\n","import { Logger } from '../../core/logger.js';\nimport { Room } from '../../core/room.js';\n\n/**\n * RoomPromise is a wrapper around a promise that resolves to a Room instance.\n *\n * It is designed to better integrate into the React lifecycle, and control whether an unmount\n * function needs to be called depending on where the promise resolution occurs relative to the\n * component lifecycle.\n */\nexport interface RoomPromise {\n  /**\n   * Returns a function to be called when the component is unmounted. If the room promise has resolved at the time,\n   * of calling, then the unmount function returned by the onResolve callback will be called.\n   *\n   * Multiple calls are no-op.\n   *\n   * This should be used in conjunction with React's useEffect hook to ensure that resources are cleaned up.\n   *\n   * Example usage:\n   *\n   * ```ts\n   * useEffect(() => {\n   *   const roomPromise: RoomPromise;\n   *   return roomPromise.unmount();\n   * }, []);\n   *\n   * @returns A function that should be called when the component is unmounted.\n   */\n  unmount: () => () => void;\n}\n\n/**\n * A callback that can be returned by the onResolve callback to clean up any resources.\n */\ntype UnmountCallback = () => void;\n\n/**\n * A callback that is called when the promise resolves to a Room instance.\n */\nexport type RoomResolutionCallback = (room: Room) => UnmountCallback;\n\n/**\n * Default implementation of RoomPromise.\n */\nclass DefaultRoomPromise implements RoomPromise {\n  private readonly _logger: Logger;\n  private readonly _onResolve: RoomResolutionCallback;\n  private _onUnmount?: UnmountCallback;\n  private _unmounted = false;\n\n  /**\n   * Creates a new DefaultRoomPromise and starts the resolution of the promise.\n   *\n   * @param room  The promise that resolves to a Room instance.\n   * @param onResolve  The callback that is called when the promise resolves to a Room instance.\n   * @param logger  The logger to use for logging.\n   */\n  constructor(room: Promise<Room>, onResolve: RoomResolutionCallback, logger: Logger) {\n    this._onResolve = onResolve;\n    this._logger = logger;\n\n    this.mount(room).catch((error: unknown) => {\n      this._logger.trace('DefaultRoomPromise(); mount error', { error: error });\n    });\n  }\n\n  /**\n   * Wait for the room promise to resolve, then execute the onResolve callback, storing its response as an unmount function.\n   * If the component is unmounted before the promise resolves, then this will do nothing.\n   *\n   * @param promise The promise that resolves to a Room instance.\n   * @returns A promise that we simply resolve when it's done.\n   */\n  async mount(promise: Promise<Room>): Promise<void> {\n    this._logger.debug('DefaultRoomPromise(); mount');\n    try {\n      const room = await promise;\n      if (this._unmounted) {\n        return;\n      }\n\n      this._logger.debug('DefaultRoomPromise(); mount resolved');\n      this._onUnmount = this._onResolve(room);\n    } catch (error) {\n      this._logger.error('DefaultRoomPromise(); mount error', { error });\n    }\n  }\n\n  /**\n   * Returns a function to be called when the component is unmounted. If the room promise has resolved at the time\n   * of calling, then the unmount function returned by the onResolve callback will be called.\n   *\n   * Multiple calls are no-op.\n   *\n   * Example usage:\n   *\n   * ```ts\n   *  useEffect(() => {\n   *    const roomPromise = wrapRoomPromise(...);\n   *    return roomPromise.unmount();\n   *  }, []);\n   * ```\n   *\n   * @returns A function that should be called when the component is unmounted.\n   */\n  unmount() {\n    if (this._unmounted) {\n      return () => {\n        // noop\n      };\n    }\n\n    return () => {\n      this._logger.debug('DefaultRoomPromise(); unmount');\n      this._unmounted = true;\n      this._onUnmount?.();\n    };\n  }\n}\n\n/**\n * Provides a convenient way to wrap a promise that resolves to a Room instance, and execute a callback.\n * This should be used in conjunction with React's useEffect hook to ensure that resources are cleaned up.\n *\n * Example usage:\n *\n * ```ts\n *  useEffect(() => {\n *    const roomPromise = wrapRoomPromise(...);\n *    return roomPromise.unmount();\n *  }, []);\n * ```\n *\n * @internal\n * @param room The promise that resolves to a Room instance.\n * @param onResolve The callback that is called when the promise resolves to a Room instance.\n * @param logger The logger to use for logging.\n * @returns A RoomPromise instance that can be used to clean up resources.\n */\nexport function wrapRoomPromise(room: Promise<Room>, onResolve: RoomResolutionCallback, logger: Logger): RoomPromise {\n  return new DefaultRoomPromise(room, onResolve, logger);\n}\n","import { useCallback, useEffect, useRef } from 'react';\n\n/**\n * The type of a callback function that can be stored in the reference.\n */\ntype Callback<CallbackArguments extends unknown[], ReturnType> = (...args: CallbackArguments) => ReturnType;\n\n/**\n * In some cases, we want to use a callback that is always the same, and always persists across renders.\n * This function creates a stable reference to a callback, so that it can be used in a `useEffect` or `useCallback`\n * without causing unnecessary re-renders.\n *\n * @internal\n * @param callback The callback to turn into a stable reference\n * @returns A stable reference to the callback\n */\nexport const useStableReference = <Arguments extends unknown[], ReturnType>(\n  callback: Callback<Arguments, ReturnType>,\n): Callback<Arguments, ReturnType> => {\n  const ref = useRef<Callback<Arguments, ReturnType>>(callback);\n  useEffect(() => {\n    ref.current = callback;\n  });\n\n  return useCallback((...args: Arguments) => ref.current(...args), []);\n};\n","import { useEffect, useState } from 'react';\n\nimport { Room } from '../../core/room.js';\nimport { useRoomLogger } from '../hooks/use-logger.js';\nimport { useRoomContext } from './use-room-context.js';\nimport { useStableReference } from './use-stable-reference.js';\n\n/**\n * This hook will take the room promise from the current context and return the room object once it has been resolved.\n * This is useful in hooks like useRoom to provide a direct reference to the room object, as Promises aren't usually\n * the best thing to be passing around React components.\n *\n * @internal\n * @returns The room object if it has resolved, otherwise undefined\n */\nexport const useEventualRoom = (): Room | undefined => {\n  const [roomState, setRoomState] = useState<Room | undefined>();\n  const context = useRoomContext('useEventualRoom');\n  const logger = useRoomLogger();\n  logger.trace('useEventualRoom();');\n\n  useEffect(() => {\n    logger.debug('useEventualRoom(); running useEffect');\n    let unmounted = false;\n    void context.room\n      .then((room: Room) => {\n        if (unmounted) {\n          logger.debug('useEventualRoom(); already unmounted');\n          return;\n        }\n\n        logger.debug('useEventualRoom(); resolved');\n        setRoomState(room);\n      })\n      .catch((error: unknown) => {\n        logger.error('Failed to get room', { error });\n      });\n\n    return () => {\n      logger.debug('useEventualRoom(); cleanup');\n      unmounted = true;\n    };\n  }, [context, logger]);\n\n  return roomState;\n};\n\n/**\n * Similar to useEventualRoom, but instead of providing the room itself, it provides a property of the room - e.g.\n * Messages. We use this to eventually provide access to underlying room interfaces as non-promise values\n * in hooks like useMessages.\n *\n * @internal\n * @returns The property of the room object that's been resolved, as returned by the onResolve callback,\n * or undefined if the room hasn't resolved yet.\n */\nexport const useEventualRoomProperty = <T>(onResolve: (room: Room) => T) => {\n  const [roomState, setRoomState] = useState<T | undefined>();\n  const context = useRoomContext('useEventualRoomProperty');\n  const logger = useRoomLogger();\n  logger.trace('useEventualRoomProperty();');\n  const onResolveRef = useStableReference(onResolve);\n\n  useEffect(() => {\n    let unmounted = false;\n    logger.debug('useEventualRoomProperty(); running useEffect');\n    void context.room\n      .then((room: Room) => {\n        if (unmounted) {\n          logger.debug('useEventualRoomProperty(); already unmounted');\n          return;\n        }\n\n        logger.debug('useEventualRoomProperty(); resolved');\n        setRoomState(onResolveRef(room));\n      })\n      .catch((error: unknown) => {\n        logger.error('Failed to get room', { error });\n      });\n\n    return () => {\n      logger.debug('useEventualRoomProperty(); cleanup');\n      unmounted = true;\n    };\n  }, [context, logger, onResolveRef]);\n\n  return roomState;\n};\n","import * as Ably from 'ably';\n\n/**\n * This type represents a callback that can be registered with an EventEmitter.\n *\n * The EventsMap is an interface of event names to the types of the payloads of\n * those events. For example:\n *\n *     interface MyEvents {\n *         reaction: {emoji: string}\n *     }\n *\n * There is no need to use this type directly, it is used for defining the\n * InterfaceEventEmitter.\n */\ntype Callback<EventsMap> = (arg: EventsMap[keyof EventsMap]) => void;\ntype CallbackSingle<K> = (arg: K) => void;\n\n/**\n * This interface extends the Ably.EventEmitter interface to add a type-safe\n * emit method as well as convert an EventsMap into the type parameters used by\n * Ably.EventEmitter.\n */\ninterface InterfaceEventEmitter<EventsMap> extends Ably.EventEmitter<Callback<EventsMap>, void, keyof EventsMap> {\n  emit<K extends keyof EventsMap>(event: K, arg: EventsMap[K]): void;\n\n  on<K extends keyof EventsMap>(event: K, callback: CallbackSingle<EventsMap[K]>): void;\n  on<K1 extends keyof EventsMap, K2 extends keyof EventsMap>(\n    events: [K1, K2],\n    callback: CallbackSingle<EventsMap[K1] | EventsMap[K2]>,\n  ): void;\n  on<K1 extends keyof EventsMap, K2 extends keyof EventsMap, K3 extends keyof EventsMap>(\n    events: [K1, K2, K3],\n    callback: CallbackSingle<EventsMap[K1] | EventsMap[K2] | EventsMap[K3]>,\n  ): void;\n  on(events: (keyof EventsMap)[], callback: Callback<EventsMap>): void;\n  on(callback: Callback<EventsMap>): void;\n\n  off<K extends keyof EventsMap>(event: K, listener: CallbackSingle<EventsMap[K]>): void;\n  off(listener?: Callback<EventsMap>): void;\n  off<K extends EventsMap[keyof EventsMap]>(listener: CallbackSingle<K>): void;\n}\n\n/**\n * This is a workaround for the fact that the EventEmitter constructor is only\n * exported from the ably-js package for internal use by other Ably SDKs (like\n * this one).\n *\n * It is a correctly-typed constructor for the ably-js EventEmitter.\n *\n * We do not export this directly because we prefer to export a class, which is\n * what we normally expect EventEmitter to be.\n */\nconst InternalEventEmitter: new <EventsMap>() => InterfaceEventEmitter<EventsMap> = (\n  Ably.Realtime as unknown as { EventEmitter: new <EventsMap>() => InterfaceEventEmitter<EventsMap> }\n).EventEmitter;\n\n/**\n * EventEmitter class based on the internal ably-js EventEmitter. It is\n * different from the ably-js EventEmitter because it takes an EventsMap type\n * parameter as opposed to the three type parameters required by\n * {@link Ably.EventEmitter}.\n *\n * We find the EventsMap type parameter to be more convenient to use in this\n * Chat SDK.\n *\n * The EventsMap is an interface of event names to the types of the payloads of\n * those events. For example:\n *\n *     interface MyEvents {\n *         reaction: {emoji: string}\n *     }\n *\n * There is no need to use this type directly, it is used for defining the\n * InterfaceEventEmitter.\n */\nclass EventEmitter<EventsMap> extends InternalEventEmitter<EventsMap> {}\n\nexport default EventEmitter;\n\n/**\n * Creates a wrapper function that forwards all arguments to the provided function.\n * @param fn The function to wrap\n * @returns A new function with the same signature as the input function\n */\nexport const wrap = <Args extends unknown[], Return>(fn: (...args: Args) => Return): ((...args: Args) => Return) => {\n  return (...args: Args) => fn(...args);\n};\n","import * as Ably from 'ably';\n\nimport { Logger } from './logger.js';\nimport { StatusSubscription } from './subscription.js';\nimport EventEmitter, { wrap } from './utils/event-emitter.js';\n\n/**\n * The different states that a room can be in throughout its lifecycle.\n */\nexport enum RoomStatus {\n  /**\n   * The library is currently initializing the room. This state is a temporary state used in React prior\n   * to the room being resolved.\n   */\n  Initializing = 'initializing',\n\n  /**\n   * A temporary state for when the room object is first initialized.\n   */\n  Initialized = 'initialized',\n\n  /**\n   * The library is currently attempting to attach the room.\n   */\n  Attaching = 'attaching',\n\n  /**\n   * The room is currently attached and receiving events.\n   */\n  Attached = 'attached',\n\n  /**\n   * The room is currently detaching and will not receive events.\n   */\n  Detaching = 'detaching',\n\n  /**\n   * The room is currently detached and will not receive events.\n   */\n  Detached = 'detached',\n\n  /**\n   * The room is in an extended state of detachment, but will attempt to re-attach when able.\n   */\n  Suspended = 'suspended',\n\n  /**\n   * The room is currently detached and will not attempt to re-attach. User intervention is required.\n   */\n  Failed = 'failed',\n\n  /**\n   * The room is in the process of releasing. Attempting to use a room in this state may result in undefined behavior.\n   */\n  Releasing = 'releasing',\n\n  /**\n   * The room has been released and is no longer usable.\n   */\n  Released = 'released',\n}\n\n/**\n * Represents a change in the status of the room.\n */\nexport interface RoomStatusChange {\n  /**\n   * The new status of the room.\n   */\n  current: RoomStatus;\n\n  /**\n   * The previous status of the room.\n   */\n  previous: RoomStatus;\n\n  /**\n   * An error that provides a reason why the room has\n   * entered the new status, if applicable.\n   */\n  error?: Ably.ErrorInfo;\n}\n\n/**\n * A function that can be called when the room status changes.\n * @param change The change in status.\n */\nexport type RoomStatusListener = (change: RoomStatusChange) => void;\n\n/**\n * Represents the status of a Room.\n */\nexport interface RoomLifecycle {\n  /**\n   * The current status of the room.\n   */\n  get status(): RoomStatus;\n\n  /**\n   * The current error, if any, that caused the room to enter the current status.\n   */\n  get error(): Ably.ErrorInfo | undefined;\n\n  /**\n   * Registers a listener that will be called whenever the room status changes.\n   * @param listener The function to call when the status changes.\n   * @returns An object that can be used to unregister the listener.\n   */\n  onChange(listener: RoomStatusListener): StatusSubscription;\n}\n\n/**\n * An internal interface for the status of a room, which can be used to separate critical\n * internal functionality from user listeners.\n * @internal\n */\nexport interface InternalRoomLifecycle extends RoomLifecycle {\n  /**\n   * Sets the status of the room.\n   *\n   * @param params The new status of the room.\n   */\n  setStatus(params: NewRoomStatus): void;\n}\n\n/**\n * A new room status that can be set.\n */\nexport interface NewRoomStatus {\n  /**\n   * The new status of the room.\n   */\n  status: RoomStatus;\n\n  /**\n   * An error that provides a reason why the room has\n   * entered the new status, if applicable.\n   */\n  error?: Ably.ErrorInfo;\n}\n\ntype RoomStatusEventsMap = Record<RoomStatus, RoomStatusChange>;\n\n/**\n * An implementation of the `Status` interface.\n * @internal\n */\nexport class DefaultRoomLifecycle implements InternalRoomLifecycle {\n  private _status: RoomStatus = RoomStatus.Initialized;\n  private _error?: Ably.ErrorInfo;\n  private readonly _logger: Logger;\n  private readonly _internalEmitter = new EventEmitter<RoomStatusEventsMap>();\n  private readonly _emitter = new EventEmitter<RoomStatusEventsMap>();\n\n  /**\n   * Constructs a new DefaultRoomLifecycle instance.\n   * @param logger An instance of the Logger.\n   */\n  constructor(logger: Logger) {\n    this._logger = logger;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get status(): RoomStatus {\n    return this._status;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get error(): Ably.ErrorInfo | undefined {\n    return this._error;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  onChange(listener: RoomStatusListener): StatusSubscription {\n    const wrapped = wrap(listener);\n    this._emitter.on(wrapped);\n\n    return {\n      off: () => {\n        this._emitter.off(wrapped);\n      },\n    };\n  }\n\n  setStatus(params: NewRoomStatus): void {\n    const change: RoomStatusChange = {\n      current: params.status,\n      error: params.error,\n      previous: this._status,\n    };\n\n    this._status = change.current;\n    this._error = change.error;\n    this._logger.info(`room status changed`, { ...change });\n    this._internalEmitter.emit(change.current, change);\n    this._emitter.emit(change.current, change);\n  }\n}\n","import * as Ably from 'ably';\nimport { useEffect, useState } from 'react';\n\nimport { Room } from '../../core/room.js';\nimport { RoomStatus, RoomStatusChange } from '../../core/room-status.js';\nimport { useRoomLogger } from '../hooks/use-logger.js';\nimport { wrapRoomPromise } from './room-promise.js';\nimport { useEventListenerRef } from './use-event-listener-ref.js';\nimport { useRoomContext } from './use-room-context.js';\n\n/**\n * The response object for the useRoomStatus hook.\n */\nexport interface UseRoomStatusResponse {\n  /**\n   * The current status of the room.\n   */\n  readonly status: RoomStatus;\n\n  /**\n   * The error that caused the room to transition to an errored state.\n   */\n  readonly error?: Ably.ErrorInfo;\n}\n\n/**\n * The parameters for the useRoomStatus hook.\n */\nexport interface UseRoomStatusParams {\n  /**\n   * A listener for room status changes.\n   */\n  onRoomStatusChange?: (change: RoomStatusChange) => void;\n}\n\n/**\n * A hook that returns the current status of the room, and listens for changes to the room status.\n *\n * @internal\n * @param params An optional user-provided listener for room status changes.\n * @returns The current status of the room, and an error if the room is in an errored state.\n */\nexport const useRoomStatus = (params?: UseRoomStatusParams): UseRoomStatusResponse => {\n  const context = useRoomContext('useRoomStatus');\n\n  const [status, setStatus] = useState<RoomStatus>(RoomStatus.Initializing);\n  const [error, setError] = useState<Ably.ErrorInfo | undefined>();\n  const logger = useRoomLogger();\n\n  // create stable references for the listeners and register the user-provided callbacks\n  const onRoomStatusChangeRef = useEventListenerRef(params?.onRoomStatusChange);\n\n  // create an internal listener to update the status\n  useEffect(() => {\n    const roomPromise = wrapRoomPromise(\n      context.room,\n      (room: Room) => {\n        logger.debug('useRoomStatus(); subscribing internal listener');\n        // Set instantaneous values\n        setStatus(room.status);\n        setError(room.error);\n\n        // Add the subscription\n        const { off } = room.onStatusChange((change) => {\n          logger.debug('useRoomStatus(); status change', change);\n          setStatus(change.current);\n          setError(change.error);\n        });\n\n        return () => {\n          logger.debug('useRoomStatus(); unsubscribing internal listener');\n          off();\n        };\n      },\n      logger,\n    );\n\n    return roomPromise.unmount();\n  }, [context, logger]);\n\n  useEffect(() => {\n    const roomPromise = wrapRoomPromise(\n      context.room,\n      (room: Room) => {\n        let off: (() => void) | undefined;\n        if (onRoomStatusChangeRef) {\n          logger.debug('useRoomStatus(); subscribing to status changes');\n          off = room.onStatusChange(onRoomStatusChangeRef).off;\n        }\n\n        logger.debug('useRoomStatus(); setting initial status', { status: room.status });\n        if (onRoomStatusChangeRef) {\n          logger.debug('useRoomStatus(); sending initial status event');\n          onRoomStatusChangeRef({\n            current: room.status,\n            previous: RoomStatus.Initializing,\n            error: room.error,\n          });\n        }\n\n        return () => {\n          logger.debug('useRoomStatus(); unmounting');\n          if (off) {\n            logger.debug('useRoomStatus(); unsubscribing from status changes');\n            off();\n          }\n        };\n      },\n      logger,\n    );\n\n    return roomPromise.unmount();\n  }, [context, logger, onRoomStatusChangeRef]);\n\n  return {\n    status,\n    error,\n  };\n};\n","import * as Ably from 'ably';\nimport { useCallback, useEffect, useState } from 'react';\n\nimport {\n  DeleteMessageParams,\n  MessageListener,\n  Messages,\n  MessageSubscriptionResponse,\n  OperationDetails,\n  QueryOptions,\n  SendMessageParams,\n  UpdateMessageParams,\n} from '../../core/messages.js';\nimport type {\n  AddMessageReactionParams,\n  DeleteMessageReactionParams,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  MessagesReactions,\n} from '../../core/messages-reactions.js'; // imported for typedoc links\nimport { MessageRawReactionListener, MessageReactionListener } from '../../core/messages-reactions.js';\nimport { Serial } from '../../core/serial.js';\nimport { wrapRoomPromise } from '../helper/room-promise.js';\nimport { useEventListenerRef } from '../helper/use-event-listener-ref.js';\nimport { useEventualRoomProperty } from '../helper/use-eventual-room.js';\nimport { useRoomContext } from '../helper/use-room-context.js';\nimport { useRoomStatus } from '../helper/use-room-status.js';\nimport { ChatStatusResponse } from '../types/chat-status-response.js';\nimport { Listenable } from '../types/listenable.js';\nimport { StatusParams } from '../types/status-params.js';\nimport { useChatConnection } from './use-chat-connection.js';\nimport { useRoomLogger } from './use-logger.js';\n\n/**\n * The response from the {@link useMessages} hook.\n */\nexport interface UseMessagesResponse extends ChatStatusResponse {\n  /**\n   * A shortcut to the {@link Messages.send} method.\n   */\n  readonly send: Messages['send'];\n\n  /**\n   * A shortcut to the {@link Messages.update} method.\n   */\n  readonly update: Messages['update'];\n\n  /**\n   * A shortcut to the {@link Messages.history} method.\n   */\n  readonly history: Messages['history'];\n\n  /**\n   * A shortcut to the {@link Messages.delete} method.\n   */\n  readonly deleteMessage: Messages['delete'];\n\n  /**\n   * A shortcut to the {@link MessagesReactions.send} method.\n   */\n  readonly sendReaction: Messages['reactions']['send'];\n\n  /**\n   * A shortcut to the {@link MessagesReactions.delete} method.\n   */\n  readonly deleteReaction: Messages['reactions']['delete'];\n\n  /**\n   * Provides access to the underlying {@link Messages} instance of the room.\n   */\n  readonly messages?: Messages;\n\n  /**\n   * Retrieves the previous messages in the room.\n   *\n   * This method is available only if a {@link MessageListener} has been provided in the {@link UseMessagesParams}.\n   * Calling will return a promise that resolves to a paginated response of the previous messages received in the room,\n   * up until the listener was attached, in newest-to-oldest order.\n   *\n   * It is advised to call this method after any discontinuity event; to retrieve messages that may have been missed\n   * before the listener was re-attached.\n   *\n   * This is removed when the component unmounts or when the previously provided listener is removed.\n   *\n   * @param options - The query options to use when fetching the previous messages.\n   *\n   * @defaultValue - This will be undefined if no listener is provided in the {@link UseMessagesParams}.\n   */\n  readonly historyBeforeSubscribe?: MessageSubscriptionResponse['historyBeforeSubscribe'];\n}\n\nexport interface UseMessagesParams extends StatusParams, Listenable<MessageListener> {\n  /**\n   * An optional listener that can be provided to receive new messages in the room.\n   * The listener is removed when the component unmounts.\n   */\n  listener?: MessageListener;\n\n  /**\n   * An optional listener that can be provided to receive reaction summaries to\n   * messages in the room. The listener is removed when the component unmounts.\n   */\n  reactionsListener?: MessageReactionListener;\n\n  /**\n   * An optional listener that can be provided to receive individual reactions\n   * to messages in the room. The listener is removed when the component\n   * unmounts.\n   */\n  rawReactionsListener?: MessageRawReactionListener;\n}\n\n/**\n * A hook that provides access to the {@link Messages} instance in the room.\n * It will use the instance belonging to the room in the nearest {@link ChatRoomProvider} in the component tree.\n * If a listener is provided, it will subscribe to new messages in the room,\n * and will also set the {@link UseMessagesResponse.historyBeforeSubscribe}.\n *\n * @param params - Allows the registering of optional callbacks.\n * @returns UsePresenceResponse - An object containing the {@link Messages} instance and methods to interact with it.\n */\nexport const useMessages = (params?: UseMessagesParams): UseMessagesResponse => {\n  const { currentStatus: connectionStatus, error: connectionError } = useChatConnection({\n    onStatusChange: params?.onConnectionStatusChange,\n  });\n  const context = useRoomContext('useMessages');\n  const { status: roomStatus, error: roomError } = useRoomStatus(params);\n\n  const logger = useRoomLogger();\n  logger.trace('useMessages();', { params });\n\n  // we are storing the params in a ref so that we don't end up with an infinite loop should the user pass\n  // in an unstable reference\n  const listenerRef = useEventListenerRef(params?.listener);\n  const reactionsListenerRef = useEventListenerRef(params?.reactionsListener);\n  const rawReactionsListenerRef = useEventListenerRef(params?.rawReactionsListener);\n  const onDiscontinuityRef = useEventListenerRef(params?.onDiscontinuity);\n\n  const send = useCallback(\n    (params: SendMessageParams) => context.room.then((room) => room.messages.send(params)),\n    [context],\n  );\n  const deleteMessage = useCallback(\n    (serial: Serial, deleteMessageParams?: DeleteMessageParams) =>\n      context.room.then((room) => room.messages.delete(serial, deleteMessageParams)),\n    [context],\n  );\n  const history = useCallback(\n    (options: QueryOptions) => context.room.then((room) => room.messages.history(options)),\n    [context],\n  );\n  const update = useCallback(\n    (serial: Serial, updateParams: UpdateMessageParams, details?: OperationDetails) =>\n      context.room.then((room) => room.messages.update(serial, updateParams, details)),\n    [context],\n  );\n\n  const sendReaction: Messages['reactions']['send'] = useCallback(\n    (serial: Serial, params: AddMessageReactionParams) =>\n      context.room.then((room) => room.messages.reactions.send(serial, params)),\n    [context],\n  );\n\n  const deleteReaction: Messages['reactions']['delete'] = useCallback(\n    (serial: Serial, params?: DeleteMessageReactionParams) =>\n      context.room.then((room) => room.messages.reactions.delete(serial, params)),\n    [context],\n  );\n\n  const [historyBeforeSubscribe, setHistoryBeforeSubscribe] =\n    useState<MessageSubscriptionResponse['historyBeforeSubscribe']>();\n\n  useEffect(() => {\n    if (!listenerRef) return;\n\n    return wrapRoomPromise(\n      context.room,\n      (room) => {\n        let unmounted = false;\n        logger.debug('useMessages(); applying listener');\n        const sub = room.messages.subscribe(listenerRef);\n\n        // set the historyBeforeSubscribe method if a listener is provided\n        setHistoryBeforeSubscribe(() => {\n          logger.debug('useMessages(); setting historyBeforeSubscribe state', {\n            status: room.status,\n            unmounted,\n          });\n          if (unmounted) {\n            return;\n          }\n\n          return (params: Omit<QueryOptions, 'orderBy'>) => {\n            // If we've unmounted, then the subscription is gone and we can't call historyBeforeSubscribe\n            // So return a dummy object that should be thrown away anyway\n            logger.debug('useMessages(); historyBeforeSubscribe called');\n            if (unmounted) {\n              return Promise.reject(new Ably.ErrorInfo('component unmounted', 40000, 400));\n            }\n            return sub.historyBeforeSubscribe(params);\n          };\n        });\n\n        return () => {\n          logger.debug('useMessages(); removing listener and historyBeforeSubscribe state');\n          unmounted = true;\n          sub.unsubscribe();\n          setHistoryBeforeSubscribe(undefined);\n        };\n      },\n      logger,\n    ).unmount();\n  }, [context, logger, listenerRef]);\n\n  useEffect(() => {\n    if (!onDiscontinuityRef) return;\n    return wrapRoomPromise(\n      context.room,\n      (room) => {\n        logger.debug('useMessages(); applying onDiscontinuity listener');\n        const { off } = room.onDiscontinuity(onDiscontinuityRef);\n        return () => {\n          logger.debug('useMessages(); removing onDiscontinuity listener');\n          off();\n        };\n      },\n      logger,\n    ).unmount();\n  }, [context, logger, onDiscontinuityRef]);\n\n  useEffect(() => {\n    if (!reactionsListenerRef) return;\n    return wrapRoomPromise(\n      context.room,\n      (room) => {\n        logger.debug('useMessages(); applying reactions listener');\n        const { unsubscribe } = room.messages.reactions.subscribe(reactionsListenerRef);\n        return () => {\n          logger.debug('useMessages(); removing reactions listener');\n          unsubscribe();\n        };\n      },\n      logger,\n    ).unmount();\n  }, [context, logger, reactionsListenerRef]);\n\n  useEffect(() => {\n    if (!rawReactionsListenerRef) return;\n    return wrapRoomPromise(\n      context.room,\n      (room) => {\n        logger.debug('useMessages(); applying raw reactions listener');\n        const { unsubscribe } = room.messages.reactions.subscribeRaw(rawReactionsListenerRef);\n        return () => {\n          logger.debug('useMessages(); removing raw reactions listener');\n          unsubscribe();\n        };\n      },\n      logger,\n    ).unmount();\n  }, [context, logger, rawReactionsListenerRef]);\n\n  return {\n    connectionStatus,\n    connectionError,\n    roomStatus,\n    roomError,\n    send,\n    update,\n    history,\n    deleteMessage,\n    sendReaction,\n    deleteReaction,\n    historyBeforeSubscribe,\n    messages: useEventualRoomProperty((room) => room.messages),\n  };\n};\n","import { useEffect, useState } from 'react';\n\nimport { Occupancy, OccupancyListener } from '../../core/occupancy.js';\nimport { wrapRoomPromise } from '../helper/room-promise.js';\nimport { useEventListenerRef } from '../helper/use-event-listener-ref.js';\nimport { useEventualRoomProperty } from '../helper/use-eventual-room.js';\nimport { useRoomContext } from '../helper/use-room-context.js';\nimport { useRoomStatus } from '../helper/use-room-status.js';\nimport { ChatStatusResponse } from '../types/chat-status-response.js';\nimport { Listenable } from '../types/listenable.js';\nimport { StatusParams } from '../types/status-params.js';\nimport { useChatConnection } from './use-chat-connection.js';\nimport { useRoomLogger } from './use-logger.js';\n\n/**\n * The options for the {@link useOccupancy} hook.\n */\nexport interface UseOccupancyParams extends StatusParams, Listenable<OccupancyListener> {\n  /**\n   * A listener that will be called whenever an occupancy event is received.\n   * The listener is removed when the component unmounts.\n   */\n  listener?: OccupancyListener;\n}\n\n/**\n * The response type from the {@link useOccupancy} hook.\n */\nexport interface UseOccupancyResponse extends ChatStatusResponse {\n  /**\n   * The current number of users connected to the room, kept up to date by the hook.\n   */\n  readonly connections: number;\n\n  /**\n   * The current number of users present in the room, kept up to date by the hook.\n   */\n  readonly presenceMembers: number;\n\n  /**\n   * Provides access to the underlying {@link Occupancy} instance of the room.\n   */\n  readonly occupancy?: Occupancy;\n}\n\n/**\n * A hook that provides access to the {@link Occupancy} instance of the room.\n * It will use the instance belonging to the nearest {@link ChatRoomProvider} in the component tree.\n *\n * @param params - Allows the registering of optional callbacks.\n * @returns UseOccupancyResponse\n */\nexport const useOccupancy = (params?: UseOccupancyParams): UseOccupancyResponse => {\n  const { currentStatus: connectionStatus, error: connectionError } = useChatConnection({\n    onStatusChange: params?.onConnectionStatusChange,\n  });\n  const context = useRoomContext('useOccupancy');\n  const { status: roomStatus, error: roomError } = useRoomStatus(params);\n\n  const logger = useRoomLogger();\n  logger.trace('useOccupancy();', { params });\n\n  const [occupancyMetrics, setOccupancyMetrics] = useState<{ connections: number; presenceMembers: number }>({\n    connections: 0,\n    presenceMembers: 0,\n  });\n\n  // create stable references for the listeners\n  const listenerRef = useEventListenerRef(params?.listener);\n  const onDiscontinuityRef = useEventListenerRef(params?.onDiscontinuity);\n\n  // if provided, subscribes the user provided discontinuity listener\n  useEffect(() => {\n    if (!onDiscontinuityRef) return;\n    return wrapRoomPromise(\n      context.room,\n      (room) => {\n        logger.debug('useOccupancy(); applying onDiscontinuity listener');\n        const { off } = room.onDiscontinuity(onDiscontinuityRef);\n        return () => {\n          logger.debug('useOccupancy(); removing onDiscontinuity listener');\n          off();\n        };\n      },\n      logger,\n    ).unmount();\n  }, [context, onDiscontinuityRef, logger]);\n\n  // subscribe to occupancy events internally, to update the state metrics\n  useEffect(() => {\n    return wrapRoomPromise(\n      context.room,\n      (room) => {\n        logger.debug('useOccupancy(); applying internal listener');\n        // Set the initial metrics from current(), or 0 if not available\n        const currentOccupancy = room.occupancy.current();\n        setOccupancyMetrics({\n          connections: currentOccupancy?.connections ?? 0,\n          presenceMembers: currentOccupancy?.presenceMembers ?? 0,\n        });\n\n        const { unsubscribe } = room.occupancy.subscribe((occupancyEvent) => {\n          setOccupancyMetrics({\n            connections: occupancyEvent.occupancy.connections,\n            presenceMembers: occupancyEvent.occupancy.presenceMembers,\n          });\n        });\n        return () => {\n          logger.debug('useOccupancy(); cleaning up internal listener');\n          unsubscribe();\n        };\n      },\n      logger,\n    ).unmount();\n  }, [context, logger]);\n\n  // if provided, subscribes the user provided listener to occupancy events\n  useEffect(() => {\n    if (!listenerRef) return;\n    return wrapRoomPromise(\n      context.room,\n      (room) => {\n        logger.debug('useOccupancy(); applying listener');\n        const { unsubscribe } = room.occupancy.subscribe(listenerRef);\n        return () => {\n          logger.debug('useOccupancy(); cleaning up listener');\n          unsubscribe();\n        };\n      },\n      logger,\n    ).unmount();\n  }, [listenerRef, context, logger]);\n\n  return {\n    occupancy: useEventualRoomProperty((room) => room.occupancy),\n    connectionStatus,\n    connectionError,\n    roomStatus,\n    roomError,\n    connections: occupancyMetrics.connections,\n    presenceMembers: occupancyMetrics.presenceMembers,\n  };\n};\n","import * as Ably from 'ably';\n\nimport { Logger } from './logger.js';\nimport { StatusSubscription } from './subscription.js';\nimport EventEmitter, { wrap } from './utils/event-emitter.js';\n\n/**\n * The different states that the connection can be in through its lifecycle.\n */\nexport enum ConnectionStatus {\n  /**\n   * A temporary state for when the library is first initialized.\n   */\n  Initialized = 'initialized',\n\n  /**\n   * The library is currently connecting to Ably.\n   */\n  Connecting = 'connecting',\n\n  /**\n   * The library is currently connected to Ably.\n   */\n  Connected = 'connected',\n\n  /**\n   * The library is currently disconnected from Ably, but will attempt to reconnect.\n   */\n  Disconnected = 'disconnected',\n\n  /**\n   * The library is in an extended state of disconnection, but will attempt to reconnect.\n   */\n  Suspended = 'suspended',\n\n  /**\n   * The library is currently disconnected from Ably and will not attempt to reconnect.\n   */\n  Failed = 'failed',\n}\n\n/**\n * Represents a change in the status of the connection.\n */\nexport interface ConnectionStatusChange {\n  /**\n   * The new status of the connection.\n   */\n  current: ConnectionStatus;\n\n  /**\n   * The previous status of the connection.\n   */\n  previous: ConnectionStatus;\n\n  /**\n   * An error that provides a reason why the connection has\n   * entered the new status, if applicable.\n   */\n  error?: Ably.ErrorInfo;\n\n  /**\n   * The time in milliseconds that the client will wait before attempting to reconnect.\n   */\n  retryIn?: number;\n}\n\n/**\n * A function that can be called when the connection status changes.\n * @param change The change in status.\n */\nexport type ConnectionStatusListener = (change: ConnectionStatusChange) => void;\n\n/**\n * Represents a connection to Ably.\n */\nexport interface Connection {\n  /**\n   * The current status of the connection.\n   */\n  get status(): ConnectionStatus;\n\n  /**\n   * The current error, if any, that caused the connection to enter the current status.\n   */\n  get error(): Ably.ErrorInfo | undefined;\n\n  /**\n   * Registers a listener that will be called whenever the connection status changes.\n   * @param listener The function to call when the status changes.\n   * @returns An object that can be used to unregister the listener.\n   */\n  onStatusChange(listener: ConnectionStatusListener): StatusSubscription;\n}\n\ntype ConnectionEventsMap = Record<ConnectionStatus, ConnectionStatusChange>;\n\n/**\n * An implementation of the `Connection` interface.\n * @internal\n */\nexport class DefaultConnection implements Connection {\n  private _status: ConnectionStatus = ConnectionStatus.Initialized;\n  private _error?: Ably.ErrorInfo;\n  private readonly _connection: Ably.Connection;\n  private readonly _logger: Logger;\n  private _emitter = new EventEmitter<ConnectionEventsMap>();\n\n  /**\n   * Constructs a new `DefaultConnection` instance.\n   * @param ably The Ably Realtime client.\n   * @param logger The logger to use.\n   */\n  constructor(ably: Ably.Realtime, logger: Logger) {\n    this._logger = logger;\n\n    // Set our initial status and error\n    // CHA-RS5\n    this._status = this._mapAblyStatusToChat(ably.connection.state);\n    this._error = ably.connection.errorReason;\n\n    // Listen for changes to the connection status\n    this._connection = ably.connection;\n    this._connection.on((change: Ably.ConnectionStateChange) => {\n      const chatState = this._mapAblyStatusToChat(change.current);\n      if (chatState === this._status) {\n        return;\n      }\n\n      const stateChange: ConnectionStatusChange = {\n        current: chatState,\n        previous: this._status,\n        error: change.reason,\n        retryIn: change.retryIn,\n      };\n\n      this._applyStatusChange(stateChange);\n    });\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get status(): ConnectionStatus {\n    return this._status;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  get error(): Ably.ErrorInfo | undefined {\n    return this._error;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  onStatusChange(listener: ConnectionStatusListener): StatusSubscription {\n    const wrapped = wrap(listener);\n    this._emitter.on(wrapped);\n\n    return {\n      off: () => {\n        this._emitter.off(wrapped);\n      },\n    };\n  }\n\n  private _applyStatusChange(change: ConnectionStatusChange): void {\n    this._status = change.current;\n    this._error = change.error;\n    this._logger.info(`Connection state changed`, change);\n    this._emitter.emit(change.current, change);\n  }\n\n  private _mapAblyStatusToChat(status: Ably.ConnectionState): ConnectionStatus {\n    switch (status) {\n      case 'closing':\n      case 'closed': {\n        return ConnectionStatus.Failed;\n      }\n      default: {\n        return status as ConnectionStatus;\n      }\n    }\n  }\n}\n","import { type ErrorInfo } from 'ably';\nimport { useCallback, useEffect, useRef, useState } from 'react';\n\nimport { ConnectionStatus } from '../../core/connection.js';\nimport { Presence, PresenceData } from '../../core/presence.js';\nimport { Room } from '../../core/room.js';\nimport { RoomStatus } from '../../core/room-status.js';\nimport { wrapRoomPromise } from '../helper/room-promise.js';\nimport { useEventListenerRef } from '../helper/use-event-listener-ref.js';\nimport { useEventualRoomProperty } from '../helper/use-eventual-room.js';\nimport { useRoomContext } from '../helper/use-room-context.js';\nimport { useRoomStatus } from '../helper/use-room-status.js';\nimport { ChatStatusResponse } from '../types/chat-status-response.js';\nimport { StatusParams } from '../types/status-params.js';\nimport { useChatConnection } from './use-chat-connection.js';\nimport { useRoomLogger } from './use-logger.js';\n\n/**\n * The options for the {@link usePresence} hook.\n */\nexport interface UsePresenceParams extends StatusParams {\n  /**\n   * The data to enter the room with. Any JSON serializable data can be provided.\n   */\n  enterWithData?: PresenceData;\n\n  /**\n   * The data to leave the room with. Any JSON serializable data can be provided.\n   */\n  leaveWithData?: PresenceData;\n}\n\nexport interface UsePresenceResponse extends ChatStatusResponse {\n  /**\n   * A shortcut to the {@link Presence.update} method.\n   */\n  readonly update: Presence['update'];\n\n  /**\n   * Provides access to the underlying {@link Presence} instance of the room.\n   */\n  readonly presence?: Presence;\n\n  /**\n   * Indicates whether the current user is present in the room.\n   */\n  readonly isPresent: boolean;\n\n  /**\n   * Indicates if an error occurred while entering or leaving the room.\n   */\n  readonly error?: ErrorInfo;\n}\n\n/**\n * A set of connection states that are considered inactive and where presence operations should not be attempted.\n */\nconst INACTIVE_CONNECTION_STATES = new Set<ConnectionStatus>([ConnectionStatus.Suspended, ConnectionStatus.Failed]);\n\n/**\n * A hook that provides access to the {@link Presence} instance in the room.\n * It will use the instance belonging to the room in the nearest {@link ChatRoomProvider} in the component tree.\n * On calling, the hook will `enter` the room with the provided data and `leave` the room when the component unmounts.\n * The {@link UsePresenceResponse.isPresent} flag will indicate when the user has become present in the room.\n *\n * @param params - Allows the registering of optional callbacks.\n * @returns UsePresenceResponse - An object containing the {@link Presence} instance and methods to interact with it.\n */\nexport const usePresence = (params?: UsePresenceParams): UsePresenceResponse => {\n  const { currentStatus: connectionStatus, error: connectionError } = useChatConnection({\n    onStatusChange: params?.onConnectionStatusChange,\n  });\n\n  const context = useRoomContext('usePresence');\n  const { status: roomStatus, error: roomError } = useRoomStatus(params);\n  const logger = useRoomLogger();\n  logger.trace('usePresence();', { params });\n\n  const [isPresent, setIsPresent] = useState(false);\n  const [error, setError] = useState<ErrorInfo | undefined>();\n\n  // store the roomStatus in a ref to ensure the correct value is used in the effect cleanup\n  const roomStatusAndConnectionStatusRef = useRef({ roomStatus, connectionStatus });\n\n  // create a stable reference for the onDiscontinuity listener\n  const onDiscontinuityRef = useEventListenerRef(params?.onDiscontinuity);\n\n  // we can't use the data param directly in a dependency array as it will cause an infinite loop\n  const dataRef = useRef(params);\n  useEffect(() => {\n    dataRef.current = params;\n  }, [params]);\n\n  useEffect(() => {\n    // Update the ref when roomStatus changes\n    roomStatusAndConnectionStatusRef.current = { roomStatus, connectionStatus };\n  }, [roomStatus, connectionStatus]);\n\n  // enter the room when the hook is mounted\n  useEffect(() => {\n    logger.debug('usePresence(); entering room');\n    return wrapRoomPromise(\n      context.room,\n      (room: Room) => {\n        const canJoinPresence =\n          room.status === RoomStatus.Attached && !INACTIVE_CONNECTION_STATES.has(connectionStatus);\n\n        // wait until the room is attached before attempting to enter, and ensure the connection is active\n        if (!canJoinPresence) {\n          logger.debug('usePresence(); skipping enter room', { roomStatus, connectionStatus });\n          return () => {\n            // no-op\n          };\n        }\n\n        room.presence\n          .enter(dataRef.current?.enterWithData)\n          .then(() => {\n            logger.debug('usePresence(); entered room');\n            setIsPresent(true);\n            setError(undefined);\n          })\n          .catch((error: unknown) => {\n            logger.error('usePresence(); error entering room', { error });\n            setError(error as ErrorInfo);\n          });\n\n        return () => {\n          const canLeavePresence =\n            room.status === RoomStatus.Attached &&\n            !INACTIVE_CONNECTION_STATES.has(roomStatusAndConnectionStatusRef.current.connectionStatus);\n\n          logger.debug('usePresence(); unmounting', {\n            canLeavePresence,\n            roomStatus,\n            connectionStatus,\n          });\n          if (canLeavePresence) {\n            room.presence\n              .leave(dataRef.current?.leaveWithData)\n              .then(() => {\n                logger.debug('usePresence(); left room');\n                setIsPresent(false);\n                setError(undefined);\n              })\n              .catch((error: unknown) => {\n                logger.error('usePresence(); error leaving room', { error });\n                setError(error as ErrorInfo);\n              });\n          }\n        };\n      },\n      logger,\n    ).unmount();\n  }, [context, connectionStatus, roomStatus, logger]);\n\n  // if provided, subscribes the user provided onDiscontinuity listener\n  useEffect(() => {\n    if (!onDiscontinuityRef) return;\n    return wrapRoomPromise(\n      context.room,\n      (room: Room) => {\n        const { off } = room.onDiscontinuity(onDiscontinuityRef);\n        return () => {\n          logger.debug('usePresence(); removing onDiscontinuity listener');\n          off();\n        };\n      },\n      logger,\n    ).unmount();\n  }, [context, onDiscontinuityRef, logger]);\n\n  // memoize the methods to avoid re-renders and ensure the same instance is used\n  const update = useCallback(\n    (data?: PresenceData) =>\n      context.room.then((room: Room) => {\n        return room.presence.update(data).then(() => {\n          setIsPresent(true);\n          setError(undefined);\n        });\n      }),\n\n    [context],\n  );\n\n  return {\n    presence: useEventualRoomProperty((room) => room.presence),\n    connectionStatus,\n    connectionError,\n    roomStatus,\n    roomError,\n    update,\n    isPresent,\n    error,\n  };\n};\n","import * as Ably from 'ably';\n\n/**\n * Error codes for the Chat SDK.\n */\nexport enum ErrorCode {\n  /**\n   * The request was invalid.\n   */\n  BadRequest = 40000,\n\n  /**\n   * The message was rejected before publishing by a rule on the chat room.\n   */\n  MessageRejectedByBeforePublishRule = 42211,\n\n  /**\n   * The message was rejected before publishing by a moderation rule on the chat room.\n   */\n  MessageRejectedByModeration = 42213,\n\n  /**\n   * The room has experienced a discontinuity.\n   */\n  RoomDiscontinuity = 102100,\n\n  // Unable to perform operation;\n\n  /**\n   * Cannot perform operation because the room is in a failed state.\n   */\n  RoomInFailedState = 102101,\n\n  /**\n   * Cannot perform operation because the room is in a releasing state.\n   */\n  RoomIsReleasing = 102102,\n\n  /**\n   * Cannot perform operation because the room is in a released state.\n   */\n  RoomIsReleased = 102103,\n\n  /**\n   * Room was released before the operation could complete.\n   */\n  RoomReleasedBeforeOperationCompleted = 102106,\n}\n\n/**\n * Returns true if the {@link Ably.ErrorInfo} code matches the provided ErrorCode value.\n *\n * @param errorInfo The error info to check.\n * @param error The error code to compare against.\n * @returns true if the error code matches, false otherwise.\n */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\nexport const errorInfoIs = (errorInfo: Ably.ErrorInfo, error: ErrorCode): boolean => errorInfo.code === error;\n","import * as Ably from 'ably';\nimport { useCallback, useEffect, useRef, useState } from 'react';\n\nimport { ErrorCode, errorInfoIs } from '../../core/errors.js';\nimport { Presence, PresenceListener, PresenceMember } from '../../core/presence.js';\nimport { Room } from '../../core/room.js';\nimport { RoomStatus } from '../../core/room-status.js';\nimport { wrapRoomPromise } from '../helper/room-promise.js';\nimport { useEventListenerRef } from '../helper/use-event-listener-ref.js';\nimport { useEventualRoomProperty } from '../helper/use-eventual-room.js';\nimport { useRoomContext } from '../helper/use-room-context.js';\nimport { useRoomStatus } from '../helper/use-room-status.js';\nimport { ChatStatusResponse } from '../types/chat-status-response.js';\nimport { Listenable } from '../types/listenable.js';\nimport { StatusParams } from '../types/status-params.js';\nimport { useChatConnection } from './use-chat-connection.js';\nimport { useRoomLogger } from './use-logger.js';\n\n/**\n * The interval between retries when fetching presence data.\n */\nconst PRESENCE_GET_RETRY_INTERVAL_MS = 1500;\n\n/**\n * The maximum interval between retries when fetching presence data.\n */\nconst PRESENCE_GET_RETRY_MAX_INTERVAL_MS = 30000;\n\n/**\n * The maximum number of retries when fetching presence data with {@link Presence.get}.\n */\nconst PRESENCE_GET_MAX_RETRIES = 5;\n\n/**\n * The options for the {@link usePresenceListener} hook.\n */\nexport interface UsePresenceListenerParams extends StatusParams, Listenable<PresenceListener> {\n  /**\n   * The listener to be called when the presence state changes.\n   * The listener is removed when the component unmounts.\n   */\n  listener?: PresenceListener;\n}\n\nexport interface UsePresenceListenerResponse extends ChatStatusResponse {\n  /**\n   * The current state of all the presence members, observed as a whole change, and only emitted while presence is not syncing.\n   */\n  readonly presenceData: PresenceMember[];\n\n  /**\n   * Provides access to the underlying {@link Presence} instance of the room.\n   */\n  readonly presence?: Presence;\n\n  /**\n   * The error state of the presence listener.\n   * The hook keeps {@link presenceData} up to date asynchronously, so this error state is provided to allow\n   * the user to handle errors that may occur when fetching presence data.\n   * It will be set if there is an error fetching the initial presence data,\n   * or if there is an error when fetching presence data after a presence event.\n   * The error will be cleared once a new presence event is received and successfully processed.\n   */\n  readonly error?: Ably.ErrorInfo;\n}\n\n/**\n * A hook that provides access to the {@link Presence} instance in the room and the current presence state.\n * It will use the instance belonging to the room in the nearest {@link ChatRoomProvider} in the component tree.\n * On calling, the hook will subscribe to the presence state of the room and update the state accordingly.\n *\n * @param params - Allows the registering of optional callbacks.\n * @returns UsePresenceResponse - An object containing the {@link Presence} instance and the current presence state.\n */\nexport const usePresenceListener = (params?: UsePresenceListenerParams): UsePresenceListenerResponse => {\n  const { currentStatus: connectionStatus, error: connectionError } = useChatConnection({\n    onStatusChange: params?.onConnectionStatusChange,\n  });\n\n  const context = useRoomContext('usePresenceListener');\n  const { status: roomStatus, error: roomError } = useRoomStatus(params);\n\n  const logger = useRoomLogger();\n  logger.trace('usePresenceListener();');\n\n  const receivedEventNumber = useRef(0);\n  const triggeredEventNumber = useRef(0);\n  const retryTimeout = useRef<ReturnType<typeof setTimeout>>(undefined);\n  const numRetries = useRef(0);\n  const latestPresentData = useRef<PresenceMember[]>([]);\n  const [presenceData, setPresenceData] = useState<PresenceMember[]>([]);\n  const errorRef = useRef<Ably.ErrorInfo | undefined>(undefined);\n\n  const [error, setError] = useState<Ably.ErrorInfo | undefined>();\n\n  // create stable references for the listeners\n  const listenerRef = useEventListenerRef(params?.listener);\n  const onDiscontinuityRef = useEventListenerRef(params?.onDiscontinuity);\n\n  const setErrorState = useCallback(\n    (error: Ably.ErrorInfo) => {\n      logger.debug('usePresenceListener(); setting error state', { error });\n      errorRef.current = error;\n      setError(error);\n    },\n    [logger],\n  );\n\n  const clearErrorState = useCallback(() => {\n    logger.debug('usePresenceListener(); clearing error state');\n    errorRef.current = undefined;\n    setError(undefined);\n  }, [logger]);\n\n  useEffect(() => {\n    // ensure we only process and return the latest presence data.\n    const updatePresenceData = () => {\n      receivedEventNumber.current += 1;\n\n      // clear the previous retry if we have received a new event\n      if (retryTimeout.current) {\n        clearTimeout(retryTimeout.current);\n        retryTimeout.current = undefined;\n        numRetries.current = 0;\n      }\n\n      // attempt to get the presence data\n      getAndSetState(receivedEventNumber.current);\n    };\n\n    const getAndSetState = (eventNumber: number) => {\n      wrapRoomPromise(\n        context.room,\n        (room: Room) => {\n          room.presence\n            .get({ waitForSync: true })\n            .then((presenceMembers) => {\n              logger.debug('usePresenceListener(); fetched presence data', { presenceMembers });\n\n              // clear the retry now we have resolved\n              if (retryTimeout.current) {\n                clearTimeout(retryTimeout.current);\n                retryTimeout.current = undefined;\n                numRetries.current = 0;\n              }\n\n              // ensure the current event is still the latest\n              if (triggeredEventNumber.current >= eventNumber) {\n                return;\n              }\n\n              triggeredEventNumber.current = eventNumber;\n\n              // update the presence data\n              latestPresentData.current = presenceMembers;\n              setPresenceData(presenceMembers);\n\n              // clear any previous errors as we have now resolved to the latest state\n              if (errorRef.current) {\n                clearErrorState();\n              }\n            })\n            .catch(() => {\n              const willReattempt = numRetries.current < PRESENCE_GET_MAX_RETRIES;\n\n              if (!willReattempt) {\n                // since we have reached the maximum number of retries, set the error state\n                logger.error('usePresenceListener(); failed to fetch presence data after max retries');\n                setErrorState(new Ably.ErrorInfo(`failed to fetch presence data after max retries`, 50000, 500));\n                return;\n              }\n\n              // if we are currently waiting for a retry, do nothing as a new event has been received\n              if (retryTimeout.current) {\n                logger.debug('usePresenceListener(); waiting for retry but new event received');\n                return;\n              }\n\n              const waitBeforeRetry = Math.min(\n                PRESENCE_GET_RETRY_MAX_INTERVAL_MS,\n                PRESENCE_GET_RETRY_INTERVAL_MS * Math.pow(2, numRetries.current),\n              );\n\n              numRetries.current += 1;\n              logger.debug('usePresenceListener(); retrying to fetch presence data', {\n                numRetries: numRetries.current,\n              });\n\n              retryTimeout.current = setTimeout(() => {\n                retryTimeout.current = undefined;\n                receivedEventNumber.current += 1;\n                getAndSetState(receivedEventNumber.current);\n              }, waitBeforeRetry);\n            });\n\n          return () => {\n            // No-op\n          };\n        },\n        logger,\n      );\n    };\n\n    return wrapRoomPromise(\n      context.room,\n      (room) => {\n        let unsubscribe: (() => void) | undefined;\n        // If the room isn't attached yet, we can't do the initial fetch\n        if (room.status === RoomStatus.Attached) {\n          room.presence\n            .get({ waitForSync: true })\n            .then((presenceMembers) => {\n              logger.debug('usePresenceListener(); fetched initial presence data', {\n                presenceMembers,\n              });\n              // on mount, fetch the initial presence data\n              latestPresentData.current = presenceMembers;\n              setPresenceData(presenceMembers);\n\n              // clear any previous errors\n              clearErrorState();\n            })\n            .catch((error: unknown) => {\n              const errorInfo = error as Ably.ErrorInfo;\n              if (errorInfoIs(errorInfo, ErrorCode.RoomIsReleased)) return;\n\n              logger.error('usePresenceListener(); error fetching initial presence data', {\n                error,\n              });\n              setErrorState(errorInfo);\n            })\n            .finally(() => {\n              // subscribe to presence events\n              logger.debug('usePresenceListener(); subscribing internal listener to presence events');\n              const result = room.presence.subscribe(() => {\n                updatePresenceData();\n              });\n              unsubscribe = result.unsubscribe;\n            });\n        } else {\n          // subscribe to presence events\n          logger.debug('usePresenceListener(); not yet attached, subscribing internal listener to presence events');\n          const result = room.presence.subscribe(() => {\n            updatePresenceData();\n          });\n          unsubscribe = result.unsubscribe;\n        }\n\n        return () => {\n          if (unsubscribe) {\n            logger.debug('usePresenceListener(); cleaning up internal listener');\n            unsubscribe();\n          }\n        };\n      },\n      logger,\n    ).unmount();\n  }, [context, setErrorState, clearErrorState, logger]);\n\n  // subscribe the user provided listener to presence changes\n  useEffect(() => {\n    if (!listenerRef) return;\n    return wrapRoomPromise(\n      context.room,\n      (room) => {\n        logger.debug('usePresenceListener(); applying external listener');\n        const { unsubscribe } = room.presence.subscribe(listenerRef);\n\n        return () => {\n          logger.debug('usePresenceListener(); cleaning up external listener');\n          unsubscribe();\n        };\n      },\n      logger,\n    ).unmount();\n  }, [context, listenerRef, logger]);\n\n  // subscribe the user provided onDiscontinuity listener\n  useEffect(() => {\n    if (!onDiscontinuityRef) return;\n    return wrapRoomPromise(\n      context.room,\n      (room) => {\n        logger.debug('usePresenceListener(); applying onDiscontinuity listener');\n        const { off } = room.onDiscontinuity(onDiscontinuityRef);\n\n        return () => {\n          logger.debug('usePresenceListener(); removing onDiscontinuity listener');\n          off();\n        };\n      },\n      logger,\n    ).unmount();\n  }, [context, onDiscontinuityRef, logger]);\n\n  return {\n    presence: useEventualRoomProperty((room) => room.presence),\n    connectionStatus,\n    connectionError,\n    roomStatus,\n    roomError,\n    error,\n    presenceData: presenceData,\n  };\n};\n","import { useCallback } from 'react';\n\nimport { ConnectionStatusChange } from '../../core/connection.js';\nimport { Room } from '../../core/room.js';\nimport { RoomStatusChange } from '../../core/room-status.js';\nimport { useEventualRoom } from '../helper/use-eventual-room.js';\nimport { useRoomContext } from '../helper/use-room-context.js';\nimport { useRoomStatus } from '../helper/use-room-status.js';\nimport { ChatStatusResponse } from '../types/chat-status-response.js';\nimport { useChatConnection } from './use-chat-connection.js';\nimport { useRoomLogger } from './use-logger.js';\n\n/**\n * The parameters for the {@link useRoom} hook.\n */\nexport interface UseRoomParams {\n  /**\n   * Callback for when the room status changes. The listener is removed when\n   * the component unmounts.\n   * @param change The change object.\n   */\n  onStatusChange?: (change: RoomStatusChange) => void;\n\n  /**\n   * Callback for when the connection status changes. The listener is removed\n   * when the component unmounts.\n   * @param change The change object.\n   */\n  onConnectionStatusChange?: (change: ConnectionStatusChange) => void;\n}\n\n/**\n * The return type for the {@link useRoom} hook.\n */\nexport interface UseRoomResponse extends ChatStatusResponse {\n  /**\n   * The unique identifier of the room.\n   */\n  readonly roomName: string;\n\n  /** The room object. */\n  room?: Room;\n\n  /**\n   * Shortcut to {@link Room.attach}. Not needed if the {@link ChatRoomProvider}\n   * has `attach=true` set, which is the default.\n   */\n  attach: () => Promise<void>;\n\n  /**\n   * Shortcut to {@link Room.detach}. Not needed if the {@link ChatRoomProvider}\n   * has `attach=true` or `release=true` set, which are the default values.\n   */\n  detach: () => Promise<void>;\n}\n\n/**\n * A hook that provides access to the current room.\n *\n * @param params Register optional callbacks, see {@link UseRoomParams}.\n * @returns {@link UseRoomResponse}\n */\nexport const useRoom = (params?: UseRoomParams): UseRoomResponse => {\n  const context = useRoomContext('useRoom');\n  const roomName = context.roomName;\n  const logger = useRoomLogger();\n  logger.debug('useRoom();');\n\n  const { currentStatus: connectionStatus, error: connectionError } = useChatConnection({\n    onStatusChange: params?.onConnectionStatusChange,\n  });\n\n  // room error and status callbacks\n  const roomStatus = useRoomStatus({\n    onRoomStatusChange: params?.onStatusChange,\n  });\n\n  const attach = useCallback(() => context.room.then((room: Room) => room.attach()), [context]);\n  const detach = useCallback(() => context.room.then((room: Room) => room.detach()), [context]);\n\n  return {\n    roomName: roomName,\n    room: useEventualRoom(),\n    attach: attach,\n    detach: detach,\n    roomStatus: roomStatus.status,\n    roomError: roomStatus.error,\n    connectionStatus: connectionStatus,\n    connectionError: connectionError,\n  };\n};\n","import { useCallback, useEffect } from 'react';\n\nimport { RoomReactionListener, RoomReactions, SendReactionParams } from '../../core/room-reactions.js';\nimport { wrapRoomPromise } from '../helper/room-promise.js';\nimport { useEventListenerRef } from '../helper/use-event-listener-ref.js';\nimport { useEventualRoomProperty } from '../helper/use-eventual-room.js';\nimport { useRoomContext } from '../helper/use-room-context.js';\nimport { useRoomStatus } from '../helper/use-room-status.js';\nimport { ChatStatusResponse } from '../types/chat-status-response.js';\nimport { Listenable } from '../types/listenable.js';\nimport { StatusParams } from '../types/status-params.js';\nimport { useChatConnection } from './use-chat-connection.js';\nimport { useRoomLogger } from './use-logger.js';\n\n/**\n * The parameters for the {@link useRoomReactions} hook.\n */\nexport interface UseRoomReactionsParams extends StatusParams, Listenable<RoomReactionListener> {\n  /**\n   * A listener that will be called whenever a reaction is sent to the room.\n   */\n  listener?: RoomReactionListener;\n}\n\n/**\n * The response type from the {@link useRoomReactions} hook.\n */\nexport interface UseRoomReactionsResponse extends ChatStatusResponse {\n  /**\n   * A shortcut to the {@link RoomReactions.send} method.\n   */\n  readonly send: RoomReactions['send'];\n\n  /**\n   * Provides access to the underlying {@link RoomReactions} instance of the room.\n   */\n  readonly reactions?: RoomReactions;\n}\n\n/**\n * A hook that provides access to the {@link RoomReactions} instance in the room.\n * It will use the instance belonging to the nearest {@link ChatRoomProvider} in the component tree.\n *\n * @param params - Allows the registering of optional callbacks.\n * @returns UseRoomReactionsResponse\n */\nexport const useRoomReactions = (params?: UseRoomReactionsParams): UseRoomReactionsResponse => {\n  const { currentStatus: connectionStatus, error: connectionError } = useChatConnection({\n    onStatusChange: params?.onConnectionStatusChange,\n  });\n\n  const context = useRoomContext('useRoomReactions');\n  const { status: roomStatus, error: roomError } = useRoomStatus(params);\n  const logger = useRoomLogger();\n  logger.trace('useRoomReactions();', { params });\n\n  // create stable references for the listeners\n  const listenerRef = useEventListenerRef(params?.listener);\n  const onDiscontinuityRef = useEventListenerRef(params?.onDiscontinuity);\n\n  // if provided, subscribes the user provided discontinuity listener\n  useEffect(() => {\n    if (!onDiscontinuityRef) return;\n    return wrapRoomPromise(\n      context.room,\n      (room) => {\n        logger.debug('useRoomReactions(); applying onDiscontinuity listener');\n        const { off } = room.onDiscontinuity(onDiscontinuityRef);\n        return () => {\n          logger.debug('useRoomReactions(); removing onDiscontinuity listener');\n          off();\n        };\n      },\n      logger,\n    ).unmount();\n  }, [context, onDiscontinuityRef, logger]);\n\n  // if provided, subscribe the user provided listener to room reactions\n  useEffect(() => {\n    if (!listenerRef) return;\n    return wrapRoomPromise(\n      context.room,\n      (room) => {\n        logger.debug('useRoomReactions(); applying listener');\n        const { unsubscribe } = room.reactions.subscribe(listenerRef);\n        return () => {\n          logger.debug('useRoomReactions(); removing listener');\n          unsubscribe();\n        };\n      },\n      logger,\n    ).unmount();\n  }, [context, listenerRef, logger]);\n\n  const send = useCallback(\n    (params: SendReactionParams) => context.room.then((room) => room.reactions.send(params)),\n    [context],\n  );\n\n  return {\n    reactions: useEventualRoomProperty((room) => room.reactions),\n    connectionStatus,\n    connectionError,\n    roomStatus,\n    roomError,\n    send,\n  };\n};\n","import * as Ably from 'ably';\nimport { useCallback, useEffect, useState } from 'react';\n\nimport { TypingSetEvent } from '../../core/events.js';\nimport { RoomStatus } from '../../core/room-status.js';\nimport { Typing, TypingListener } from '../../core/typing.js';\nimport { wrapRoomPromise } from '../helper/room-promise.js';\nimport { useEventListenerRef } from '../helper/use-event-listener-ref.js';\nimport { useEventualRoomProperty } from '../helper/use-eventual-room.js';\nimport { useRoomContext } from '../helper/use-room-context.js';\nimport { useRoomStatus } from '../helper/use-room-status.js';\nimport { ChatStatusResponse } from '../types/chat-status-response.js';\nimport { Listenable } from '../types/listenable.js';\nimport { StatusParams } from '../types/status-params.js';\nimport { useChatConnection } from './use-chat-connection.js';\nimport { useRoomLogger } from './use-logger.js';\n\n/**\n * The parameters for the {@link useTyping} hook.\n */\nexport interface TypingParams extends StatusParams, Listenable<TypingListener> {\n  /**\n   * A listener that will be called whenever a typing event is sent to the room.\n   * The listener is removed when the component unmounts.\n   *\n   */\n  listener?: TypingListener;\n}\n\nexport interface UseTypingResponse extends ChatStatusResponse {\n  /**\n   * A shortcut to the {@link Typing.keystroke} method.\n   */\n  readonly keystroke: Typing['keystroke'];\n\n  /**\n   * A shortcut to the {@link Typing.stop} method.\n   */\n  readonly stop: Typing['stop'];\n\n  /**\n   * A state value representing the set of client IDs that are currently typing in the room.\n   * It automatically updates based on typing events received from the room.\n   */\n  readonly currentlyTyping: TypingSetEvent['currentlyTyping'];\n\n  /**\n   * Provides access to the underlying {@link Typing} instance of the room.\n   */\n  readonly typingIndicators?: Typing;\n\n  /**\n   * A state value representing the current error state of the hook, this will be an instance of {@link Ably.ErrorInfo} or `undefined`.\n   * An error can occur during mount when initially fetching the current typing state; this does not mean that further\n   * updates will not be received, and so the hook might recover from this state on its own.\n   */\n  readonly error?: Ably.ErrorInfo;\n}\n\n/**\n * A hook that provides access to the {@link Typing} instance in the room.\n * It will use the instance belonging to the room in the nearest {@link ChatRoomProvider} in the component tree.\n *\n * @param params - Allows the registering of optional callbacks.\n * @returns UseTypingResponse - An object containing the {@link Typing} instance and methods to interact with it.\n */\nexport const useTyping = (params?: TypingParams): UseTypingResponse => {\n  const { currentStatus: connectionStatus, error: connectionError } = useChatConnection({\n    onStatusChange: params?.onConnectionStatusChange,\n  });\n\n  const context = useRoomContext('useTyping');\n  const { status: roomStatus, error: roomError } = useRoomStatus(params);\n  const logger = useRoomLogger();\n  logger.trace('useTyping();');\n\n  const [currentlyTyping, setCurrentlyTyping] = useState<Set<string>>(new Set());\n\n  // Create a stable reference for the listeners\n  const listenerRef = useEventListenerRef(params?.listener);\n  const onDiscontinuityRef = useEventListenerRef(params?.onDiscontinuity);\n\n  useEffect(() => {\n    // Start with a clean slate - empty set\n    setCurrentlyTyping((prev) => {\n      // keep reference constant if it's already empty\n      if (prev.size === 0) return prev;\n      return new Set<string>();\n    });\n\n    return wrapRoomPromise(\n      context.room,\n      (room) => {\n        logger.debug('useTyping(); subscribing to typing events');\n        const { unsubscribe } = room.typing.subscribe((event) => {\n          setCurrentlyTyping(event.currentlyTyping);\n        });\n\n        // If we're not attached, we can't call typing.current() right now\n        if (room.status === RoomStatus.Attached) {\n          const typing = room.typing.current();\n          logger.debug('useTyping(); room attached, getting initial typers', { typing });\n          setCurrentlyTyping(typing);\n        }\n\n        return () => {\n          logger.debug('useTyping(); unsubscribing from typing events');\n          unsubscribe();\n        };\n      },\n      logger,\n    ).unmount();\n  }, [context, logger]);\n\n  // if provided, subscribes the user-provided onDiscontinuity listener\n  useEffect(() => {\n    if (!onDiscontinuityRef) return;\n    return wrapRoomPromise(\n      context.room,\n      (room) => {\n        logger.debug('useTyping(); applying onDiscontinuity listener');\n        const { off } = room.onDiscontinuity(onDiscontinuityRef);\n        return () => {\n          logger.debug('useTyping(); removing onDiscontinuity listener');\n          off();\n        };\n      },\n      logger,\n    ).unmount();\n  }, [context, onDiscontinuityRef, logger]);\n\n  // if provided, subscribe the user-provided listener to TypingEvents\n  useEffect(() => {\n    if (!listenerRef) return;\n    return wrapRoomPromise(\n      context.room,\n      (room) => {\n        logger.debug('useTyping(); applying listener');\n        const { unsubscribe } = room.typing.subscribe(listenerRef);\n        return () => {\n          logger.debug('useTyping(); removing listener');\n          unsubscribe();\n        };\n      },\n      logger,\n    ).unmount();\n  }, [context, listenerRef, logger]);\n\n  // memoize the methods to avoid re-renders, and ensure the same instance is used\n  const keystroke = useCallback(() => context.room.then((room) => room.typing.keystroke()), [context]);\n  const stop = useCallback(() => context.room.then((room) => room.typing.stop()), [context]);\n\n  return {\n    typingIndicators: useEventualRoomProperty((room) => room.typing),\n    connectionStatus,\n    connectionError,\n    roomStatus,\n    roomError,\n    keystroke,\n    stop,\n    currentlyTyping,\n  };\n};\n","// imported for docs linking\nimport React, { ReactNode, useEffect, useMemo, useRef, useState } from 'react';\n\nimport { ChatClient } from '../../core/chat.js';\nimport { Logger } from '../../core/logger.js';\nimport { Room } from '../../core/room.js';\nimport { RoomOptions } from '../../core/room-options.js';\nimport { ChatRoomContext, ChatRoomContextType } from '../contexts/chat-room-context.js';\nimport { useChatClient } from '../hooks/use-chat-client.js';\nimport { useLogger } from '../hooks/use-logger.js';\n\n/**\n * Props for the {@link ChatRoomProvider} component.\n */\nexport interface ChatRoomProviderProps {\n  /** The name of the room. */\n  name: string;\n\n  /**\n   * Overriding options to use when creating the room.\n   *\n   * NOTE: This value is not memoized by the provider. It must be memoized in your component to prevent\n   * re-renders of a parent component from causing the room to be recreated.\n   */\n  options?: RoomOptions;\n\n  /**\n   * Set to `false` to disable auto-releasing the room when component unmounts,\n   * to support multiple {@link ChatRoomProvider}s for the same room.\n   *\n   * If set to `false`, you must manually release the room using\n   * `chatClient.rooms.release(id)` or have another {@link ChatRoomProvider} for\n   * the same room and {@link release} set to `true`.\n   *\n   * @defaultValue `true`\n   */\n  release?: boolean;\n\n  /**\n   * Set to `false` to disable auto-attaching the room when component mounts\n   * and auto-detaching when it unmounts.\n   *\n   * If set to `false`, you must manually attach and detach the room using\n   * `room.attach()` and `room.detach()` or the provided shortcut functions\n   * that {@link useRoom} provides.\n   * Setting this flag to `false` is useful in the case where you have more providers for the same room,\n   * and you need to control the attachment manually or by choosing which provider handles it.\n   *\n   * @defaultValue `true`\n   */\n  attach?: boolean;\n\n  /** Children nodes. */\n  children?: ReactNode | ReactNode[] | null;\n}\n\ninterface RoomReleaseOp {\n  id: string;\n  options: RoomOptions | undefined;\n  abort: AbortController;\n}\n\nclass RoomReleaseQueue {\n  private readonly _queue: RoomReleaseOp[];\n  private readonly _logger: Logger;\n  constructor(logger: Logger) {\n    logger.trace('RoomReleaseQueue();');\n    this._queue = [];\n    this._logger = logger;\n  }\n\n  enqueue(client: ChatClient, id: string, options: RoomOptions | undefined) {\n    const abort = new AbortController();\n    const op: RoomReleaseOp = { id, options, abort };\n    this._queue.push(op);\n    this._logger.debug(`RoomReleaseQueue(); enqueued release`, { id, options });\n\n    void Promise.resolve()\n      .then(() => {\n        if (abort.signal.aborted) {\n          this._logger.debug(`RoomReleaseQueue(); aborting release`, { id, options });\n          return;\n        }\n\n        this._logger.debug(`RoomReleaseQueue(); releasing room`, { id, options });\n        void client.rooms.release(id).catch(() => void 0);\n      })\n      .catch(() => void 0)\n      .finally(() => {\n        this._logger.debug(`RoomReleaseQueue(); dequeued release`, { id, options });\n        this._queue.splice(this._queue.indexOf(op), 1);\n      });\n  }\n\n  abort(id: string, options: RoomOptions | undefined) {\n    this._logger.debug(`RoomReleaseQueue(); checking for abort`, { id, options, length: this._queue.length });\n    const op = this._queue.find((op) => op.id === id && op.options === options);\n    if (op) {\n      this._logger.debug(`RoomReleaseQueue(); triggering abort`, { id, options });\n      op.abort.abort();\n    }\n  }\n\n  get logger(): Logger {\n    return this._logger;\n  }\n}\n\n/**\n * Provider for a {@link Room}. Must be wrapped in a {@link ChatClientProvider}.\n *\n * See {@link ChatRoomProviderProps} for the available props and configuring the\n * provider to automatically attach, detach and/or release the room.\n */\nexport const ChatRoomProvider: React.FC<ChatRoomProviderProps> = ({\n  name: roomName,\n  options,\n  release = true,\n  attach = true,\n  children,\n}) => {\n  const client = useChatClient();\n  const clientLogger = useLogger();\n  const logger = useMemo(() => clientLogger.withContext({ roomName }), [clientLogger, roomName]);\n  logger.debug(`ChatRoomProvider();`, { options, release, attach });\n\n  // Set the initial room promise, we do this in a function to avoid rooms.get being called\n  // every time the component re-renders\n  // In StrictMode this will be called twice one after the other, but that's ok\n  const [value, setValue] = useState<ChatRoomContextType>(() => {\n    logger.debug(`ChatRoomProvider(); initializing value`, { options });\n    const room = client.rooms.get(roomName, options);\n    room.catch(() => void 0);\n    return { room: room, roomName: roomName, options: options, client: client };\n  });\n\n  // Create a queue to manage release ops\n  const roomReleaseQueue = useRef(new RoomReleaseQueue(logger));\n\n  // update the release queue if the logger changes - as it means we have a new client\n  // and only if it actually changes, not because strict mode ran it twice\n  useEffect(() => {\n    // Don't create a new queue if the logger hasn't actually changed\n    if (roomReleaseQueue.current.logger === logger) {\n      return;\n    }\n\n    logger.debug(`ChatRoomProvider(); updating release queue`);\n    roomReleaseQueue.current = new RoomReleaseQueue(logger);\n  }, [logger]);\n\n  // Create an effect that manages the room state, handles attaching and releasing\n  useEffect(() => {\n    logger.debug(`ChatRoomProvider(); running lifecycle useEffect`);\n    let unmounted = false;\n    let resolvedRoom: Room | undefined;\n    const currentReleaseQueue = roomReleaseQueue.current;\n\n    // If there was a previous release queued for this room (same id and options), abort it\n    currentReleaseQueue.abort(roomName, options);\n\n    // Get the room promise\n    const room = client.rooms.get(roomName, options);\n    room.catch(() => void 0);\n\n    // If we've had a change in the room id or options, update the value in the state\n    setValue((prev: ChatRoomContextType) => {\n      // If the room id and options haven't changed, then we don't need to do anything\n      if (prev.client === client && prev.roomName === roomName && prev.options === options) {\n        logger.debug(`ChatRoomProvider(); no change in room id or options`, { options });\n        return prev;\n      }\n\n      logger.debug(`ChatRoomProvider(); updating value`, { options });\n      return { room: room, roomName, options, client };\n    });\n\n    // Use the room promise to attach\n    void room\n      .then((room: Room) => {\n        if (unmounted) {\n          logger.debug(`ChatRoomProvider(); unmounted before room resolved`);\n          return;\n        }\n\n        logger.debug(`ChatRoomProvider(); room resolved`);\n        resolvedRoom = room;\n\n        if (attach) {\n          // attachment error and/or room status is available via useRoom\n          // or room.status, no need to do anything with the promise here\n          logger.debug(`ChatRoomProvider(); attaching room`);\n          void room.attach().catch(() => {\n            // Ignore, the error will be available via various room status properties\n          });\n        }\n      })\n      .catch(() => void 0);\n\n    // Cleanup function\n    return () => {\n      unmounted = true;\n      logger.debug(`ChatRoomProvider(); cleaning up lifecycle useEffect`);\n\n      // If we're releasing, release the room. We'll do this in an abortable way so that we don't kill off the value\n      // when using StrictMode\n      if (release) {\n        logger.debug(`ChatRoomProvider(); releasing room`);\n        currentReleaseQueue.enqueue(client, roomName, options);\n        return;\n      } else if (resolvedRoom && attach) {\n        // If we're not releasing, but we are attaching, then we should detach the room, but only iff the room\n        // was resolved in time\n        logger.debug(`ChatRoomProvider(); detaching room`);\n        void resolvedRoom.detach().catch(() => {\n          // Ignore, the error will be available via various room status properties\n        });\n      }\n    };\n  }, [roomName, options, logger, attach, release, client]);\n\n  return <ChatRoomContext.Provider value={value}>{children}</ChatRoomContext.Provider>;\n};\n"],"names":["ChatRoomContext","createContext","contextKey","globalObjectForContext","getChatContext","context","React","ChatClientContext","DEFAULT_CHAT_CLIENT_ID","ChatClientProvider","children","client","value","uiKitVersion","jsx","useChatClient","Ably","useEventListenerRef","callback","ref","useRef","useEffect","returnVal","useCallback","args","useRoomContext","callingHook","useContext","useLogger","chatClient","useMemo","useRoomLogger","roomContext","useChatConnection","options","logger","currentStatus","setCurrentStatus","useState","error","setError","connection","setConnection","onStatusChangeRef","off","change","DefaultRoomPromise","room","onResolve","promise","wrapRoomPromise","useStableReference","useEventualRoom","roomState","setRoomState","unmounted","useEventualRoomProperty","onResolveRef","RoomStatus","useRoomStatus","params","status","setStatus","onRoomStatusChangeRef","useMessages","connectionStatus","connectionError","roomStatus","roomError","listenerRef","reactionsListenerRef","rawReactionsListenerRef","onDiscontinuityRef","send","deleteMessage","serial","deleteMessageParams","history","update","updateParams","details","sendReaction","deleteReaction","historyBeforeSubscribe","setHistoryBeforeSubscribe","sub","unsubscribe","useOccupancy","occupancyMetrics","setOccupancyMetrics","currentOccupancy","occupancyEvent","ConnectionStatus","INACTIVE_CONNECTION_STATES","usePresence","isPresent","setIsPresent","roomStatusAndConnectionStatusRef","dataRef","canLeavePresence","data","ErrorCode","errorInfoIs","errorInfo","PRESENCE_GET_RETRY_INTERVAL_MS","PRESENCE_GET_RETRY_MAX_INTERVAL_MS","PRESENCE_GET_MAX_RETRIES","usePresenceListener","receivedEventNumber","triggeredEventNumber","retryTimeout","numRetries","latestPresentData","presenceData","setPresenceData","errorRef","setErrorState","clearErrorState","updatePresenceData","getAndSetState","eventNumber","presenceMembers","waitBeforeRetry","useRoom","roomName","attach","detach","useRoomReactions","useTyping","currentlyTyping","setCurrentlyTyping","prev","event","typing","keystroke","stop","RoomReleaseQueue","id","abort","op","ChatRoomProvider","release","clientLogger","setValue","roomReleaseQueue","resolvedRoom","currentReleaseQueue"],"mappings":"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"}